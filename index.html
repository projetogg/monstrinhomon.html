<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Monstrinhomon - Therapeutic Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --fire-color: #ff6b35; --water-color: #4ecdc4; --plant-color: #95e06c; --electric-color: #ffe66d;
            --primary: #6c5ce7; --secondary: #fd79a8; --success: #00b894; --warning: #fdcb6e;
            --danger: #d63031; --dark: #2d3436; --light: #dfe6e9;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--dark); min-height: 100vh; overflow-x: hidden;
        }
        
        .app-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .error-panel {
            position: fixed; top: 0; left: 0; right: 0; background: #d63031; color: white;
            padding: 15px; z-index: 10000; display: none; font-family: monospace; font-size: 14px;
        }
        .error-panel.show { display: block; }
        .error-panel button {
            background: white; color: #d63031; border: none; padding: 8px 15px; margin: 5px;
            border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;
        }
        
        .header {
            background: white; border-radius: 20px; padding: 20px; margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header h1 { color: var(--primary); font-size: 2.5em; text-align: center; margin-bottom: 10px; }
        
        .tabs {
            display: flex; gap: 10px; overflow-x: auto; padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab-button {
            background: var(--light); border: none; padding: 15px 25px; border-radius: 15px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;
            white-space: nowrap; min-width: 100px; min-height: 44px;
        }
        .tab-button.active {
            background: var(--primary); color: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }
        
        .tab-content {
            display: none; background: white; border-radius: 20px; padding: 25px;
            min-height: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tab-content.active { display: block; animation: fadeIn 0.3s; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .btn {
            background: var(--primary); color: white; border: none; padding: 15px 30px;
            border-radius: 12px; font-size: 16px; font-weight: bold; cursor: pointer;
            transition: all 0.3s; min-height: 44px; min-width: 44px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-success { background: var(--success); }
        .btn-danger { background: var(--danger); }
        .btn-warning { background: var(--warning); color: var(--dark); }
        .btn-secondary { background: var(--secondary); }
        .btn-large { font-size: 20px; padding: 20px 40px; }
        
        input, select, textarea {
            width: 100%; padding: 12px; border: 2px solid var(--light); border-radius: 10px;
            font-size: 16px; margin: 8px 0; min-height: 44px;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        
        .card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px; padding: 20px; margin: 15px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .monster-card {
            display: inline-block; width: 150px; margin: 10px; padding: 15px;
            border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .monster-card:active { transform: scale(0.95); }
        .monster-card.fire { background: linear-gradient(135deg, #ff6b35 0%, #ff8c61 100%); }
        .monster-card.water { background: linear-gradient(135deg, #4ecdc4 0%, #7ee0d7 100%); }
        .monster-card.plant { background: linear-gradient(135deg, #95e06c 0%, #b3eb93 100%); }
        .monster-card.electric { background: linear-gradient(135deg, #ffe66d 0%, #fff09c 100%); }
        
        .progress-bar {
            width: 100%; height: 30px; background: var(--light); border-radius: 15px;
            overflow: hidden; position: relative; margin: 10px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--success) 0%, #00b894 100%);
            transition: width 0.5s; display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px;
        }
        .progress-fill.hp { background: linear-gradient(90deg, #d63031 0%, #ff7675 100%); }
        .progress-fill.xp { background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%); }
        
        .badge {
            display: inline-block; padding: 5px 12px; border-radius: 20px;
            font-size: 12px; font-weight: bold; margin: 2px;
        }
        .badge-common { background: #95a5a6; color: white; }
        .badge-rare { background: #3498db; color: white; }
        .badge-epic { background: #9b59b6; color: white; }
        .badge-legendary { background: #f39c12; color: white; }
        .badge-fire { background: var(--fire-color); color: white; }
        .badge-water { background: var(--water-color); color: white; }
        .badge-plant { background: var(--plant-color); color: white; }
        .badge-electric { background: var(--electric-color); color: var(--dark); }
        
        .encounter-panel {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-radius: 20px; padding: 25px; margin: 20px 0;
        }
        
        .combat-log {
            background: white; border-radius: 15px; padding: 15px; max-height: 300px;
            overflow-y: auto; font-family: monospace; font-size: 14px;
        }
        .combat-log div { padding: 5px 0; border-bottom: 1px solid var(--light); }
        
        .therapist-panel {
            border: 3px dashed var(--warning); border-radius: 20px; padding: 20px;
            margin: 20px 0; background: #fffbea;
        }
        
        .objective-item {
            display: flex; align-items: center; gap: 10px; padding: 15px;
            background: white; border-radius: 10px; margin: 10px 0;
        }
        
        .medal { font-size: 48px; display: inline-block; margin: 10px; }
        .hidden { display: none !important; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex-center { display: flex; justify-content: center; align-items: center; gap: 15px; }
        
        .stat-box {
            display: inline-block; padding: 10px 20px; background: var(--light);
            border-radius: 10px; margin: 5px; font-weight: bold;
        }
        
        #mmToastHost{
          position:fixed;
          top:12px;
          right:12px;
          z-index:9999;
          display:flex;
          flex-direction:column;
          gap:8px;
        }
        .mm-toast{
          background:rgba(20,20,20,0.92);
          color:#fff;
          padding:10px 12px;
          border-radius:12px;
          font-size:14px;
          max-width:320px;
          box-shadow:0 8px 24px rgba(0,0,0,0.25);
        }
        
        /* ============================= */
        /* FEATURE 3.8 ‚Äî BATTLE POLISH */
        /* ============================= */
        
        /* Floating damage/heal text */
        .floating-text {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }
        
        .floating-text.damage {
            color: #d32f2f;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .floating-text.heal {
            color: #2e7d32;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .floating-text.crit {
            color: #ff6f00;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(255,193,7,0.8), 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            70% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-60px);
            }
        }
        
        /* Flash target effects */
        .flash-crit {
            animation: flashCrit 0.4s ease-out;
        }
        
        .flash-fail {
            animation: flashFail 0.4s ease-out;
        }
        
        .flash-hit {
            animation: flashHit 0.3s ease-out;
        }
        
        @keyframes flashCrit {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px 5px rgba(255,193,7,0.8); background-color: rgba(255,193,7,0.2); }
        }
        
        @keyframes flashFail {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px 5px rgba(211,47,47,0.8); background-color: rgba(211,47,47,0.2); }
        }
        
        @keyframes flashHit {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 15px 3px rgba(66,66,66,0.6); background-color: rgba(66,66,66,0.1); }
        }
        
        /* Last d20 roll badge */
        .d20-badge {
            display: inline-block;
            padding: 8px 15px;
            margin: 10px 0;
            border-radius: 8px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            font-size: 16px;
            font-weight: bold;
        }
        
        .d20-badge.crit {
            background: linear-gradient(135deg, #fff9c4 0%, #ffeb3b 100%);
            border-color: #fbc02d;
            color: #f57c00;
            box-shadow: 0 2px 8px rgba(251,192,45,0.4);
        }
        
        .d20-badge.fail {
            background: linear-gradient(135deg, #ffcdd2 0%, #ef5350 100%);
            border-color: #e53935;
            color: #b71c1c;
            box-shadow: 0 2px 8px rgba(229,57,53,0.4);
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8em; }
            .tab-button { padding: 12px 20px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div id="errorPanel" class="error-panel">
        <div id="errorMessage"></div>
        <button onclick="copyError()">üìã Copy Error</button>
        <button onclick="dismissError()">‚úñ Dismiss</button>
    </div>

    <div class="app-container">
        <div class="header">
            <h1>üéÆ Monstrinhomon üåü</h1>
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">üè† Home</button>
                <button class="tab-button" onclick="switchTab('session')">üìã Session</button>
                <button class="tab-button" onclick="switchTab('players')">üë• Players</button>
                <button class="tab-button" onclick="switchTab('encounter')">‚öîÔ∏è Encounter</button>
                <button class="tab-button" onclick="switchTab('therapy')">üéØ Therapy</button>
                <button class="tab-button" onclick="switchTab('report')">üìä Report</button>
                <button class="tab-button" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <div id="tabHome" class="tab-content active">
            <h2>Welcome to Monstrinhomon! üéâ</h2>
            <p style="font-size: 18px; margin: 20px 0;">A therapeutic game for young trainers.</p>
            
            <div class="card">
                <h3>Quick Stats</h3>
                <div id="homeStats">
                    <div class="stat-box">Active Players: <span id="statPlayers">0</span></div>
                    <div class="stat-box">Total Monsters: <span id="statMonsters">0</span></div>
                    <div class="stat-box">Session Active: <span id="statSession">No</span></div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div class="flex">
                    <button class="btn btn-large btn-success" onclick="switchTab('session')">Start New Session</button>
                    <button class="btn btn-large" onclick="switchTab('players')">Manage Players</button>
                    <button class="btn btn-large btn-secondary" onclick="switchTab('encounter')">Start Encounter</button>
                </div>
            </div>
        </div>

        <div id="tabSession" class="tab-content">
            <h2>Session Management üìã</h2>
            
            <div class="card">
                <h3>Create New Session</h3>
                <input type="text" id="sessionName" placeholder="Session Name (e.g., Therapy Session 2024-01-15)">
                <button class="btn btn-success" onclick="createSession()">Create Session</button>
            </div>

            <div id="activeSessionPanel" class="card hidden">
                <h3>Active Session: <span id="activeSessionName"></span></h3>
                <p>Created: <span id="sessionCreated"></span></p>
                
                <h4>Turn Order</h4>
                <div id="turnOrderList"></div>
                
                <button class="btn btn-warning" onclick="nextTurn()">Next Turn ‚ñ∂</button>
                <button class="btn btn-danger" onclick="endSession()">End Session</button>
            </div>
        </div>

        <div id="tabPlayers" class="tab-content">
            <h2>Player Management üë•</h2>
            
            <div class="card">
                <h3>Add New Player</h3>
                <input type="text" id="playerName" placeholder="Player Name">
                <select id="playerClass">
                    <option value="">Select Class</option>
                    <option value="Guerreiro">‚öîÔ∏è Guerreiro</option>
                    <option value="Mago">üîÆ Mago</option>
                    <option value="Curandeiro">üíö Curandeiro</option>
                    <option value="B√°rbaro">üí™ B√°rbaro</option>
                    <option value="Ladino">üó°Ô∏è Ladino</option>
                    <option value="Bardo">üéµ Bardo</option>
                    <option value="Ca√ßador">üèπ Ca√ßador</option>
                    <option value="Animalista">üêæ Animalista</option>
                </select>
                <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
            </div>

            <div id="playersList"></div>
        </div>

        <div id="tabEncounter" class="tab-content">
            <h2>Encounter ‚öîÔ∏è</h2>
            
            <div class="card">
                <h3>Start New Encounter</h3>
                <select id="encounterType" onchange="updateEncounterUI()">
                    <option value="wild">üåü Wild Monster (Individual Capture)</option>
                    <option value="trainer">üë§ Trainer Battle (Group)</option>
                    <option value="boss">üëπ Boss Battle (Group)</option>
                    <option value="event">üìñ Narrative Event</option>
                </select>
                
                <!-- Para encontros individuais (wild) -->
                <div id="playerSelectDiv" style="margin-top: 15px;">
                    <label><strong>Select Player for Individual Encounter:</strong></label>
                    <select id="encounterPlayer">
                        <option value="">-- Select Player --</option>
                    </select>
                </div>
                
                <!-- Para encontros em grupo (trainer/boss) -->
                <div id="groupSelectDiv" class="hidden" style="margin-top: 15px;">
                    <label><strong>Select Participants (1-6):</strong></label>
                    <div id="groupParticipantsList" style="margin-top: 10px;"></div>
                    <div style="margin-top: 10px;">
                        <label><strong>Enemy Level:</strong></label>
                        <select id="enemyLevel">
                            <option value="1">1</option>
                            <option value="3">3</option>
                            <option value="5" selected>5</option>
                            <option value="7">7</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="startEncounter()">Start Encounter</button>
            </div>

            <div id="encounterPanel" class="hidden"></div>
        </div>

        <div id="tabTherapy" class="tab-content">
            <h2>Therapeutic Objectives üéØ</h2>
            
            <div class="therapist-panel">
                <h3>‚öïÔ∏è Therapist Controls</h3>
                
                <div class="card">
                    <h4>Add Objective</h4>
                    <input type="text" id="newObjective" placeholder="Objective description">
                    <select id="objectiveWeight">
                        <option value="1">Low Weight (1)</option>
                        <option value="2">Medium Weight (2)</option>
                        <option value="3">High Weight (3)</option>
                    </select>
                    <button class="btn btn-success" onclick="addObjective()">Add Objective</button>
                </div>

                <div id="objectivesList"></div>
            </div>

            <div id="therapyPlayersList"></div>
        </div>

        <div id="tabReport" class="tab-content">
            <h2>Session Report üìä</h2>
            <div id="reportContent"></div>
        </div>

        <div id="tabSettings" class="tab-content">
            <h2>Settings ‚öôÔ∏è</h2>
            
            <div class="card">
                <h3>Game Configuration</h3>
                <label>
                    <input type="checkbox" id="therapistMode" onchange="toggleTherapistMode()">
                    Therapist Mode (Show advanced controls)
                </label>
            </div>

            <div class="card">
                <h3>Data Management</h3>
                <button class="btn btn-success" onclick="exportData()">üì• Export All Data</button>
                <button class="btn btn-warning" onclick="importData()">üì§ Import Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
            </div>

            <div id="configPanel" class="card hidden">
                <h3>Advanced Configuration</h3>
                <div id="configEditor"></div>
            </div>
        </div>
    </div>

    <script>
        // GLOBAL ERROR HANDLER
        window.addEventListener('error', function(event) {
            showError(event.error || event.message, event.error?.stack || '');
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise Rejection: ' + event.reason, event.reason?.stack || '');
        });

        function showError(message, stack) {
            const panel = document.getElementById('errorPanel');
            const messageDiv = document.getElementById('errorMessage');
            messageDiv.innerHTML = `<strong>Error:</strong> ${message}<br><pre>${stack}</pre>`;
            panel.classList.add('show');
            console.error('Error caught:', message, stack);
        }

        function dismissError() {
            document.getElementById('errorPanel').classList.remove('show');
        }

        function copyError() {
            const text = document.getElementById('errorMessage').innerText;
            navigator.clipboard.writeText(text).catch(e => alert('Copy failed: ' + e));
        }

        // STATE MANAGEMENT
        const GameState = {
            players: [],
            monsters: [],
            sessions: [],
            currentSession: null,
            currentEncounter: null,
            objectives: [],
            config: {
                maxTeamSize: 6,
                maxLevel: 100,
                levelExpo: 1.5,
                battleXpBase: 15,
                captureModel: 'threshold_no_dice',
                // Vantagens de Classe (conforme GAME_RULES.md)
                classAdvantages: {
                    'Guerreiro': { strong: 'Ladino', weak: 'Curandeiro' },
                    'Ladino': { strong: 'Mago', weak: 'Guerreiro' },
                    'Mago': { strong: 'B√°rbaro', weak: 'Ladino' },
                    'B√°rbaro': { strong: 'Ca√ßador', weak: 'Mago' },
                    'Ca√ßador': { strong: 'Bardo', weak: 'B√°rbaro' },
                    'Bardo': { strong: 'Curandeiro', weak: 'Ca√ßador' },
                    'Curandeiro': { strong: 'Guerreiro', weak: 'Bardo' },
                    'Animalista': { strong: null, weak: null } // Neutro
                },
                // Thresholds de captura por raridade (sem dado)
                captureThreshold: {
                    'Comum': 0.35,
                    'Incomum': 0.30,
                    'Raro': 0.22,
                    'M√≠stico': 0.15,
                    'Lend√°rio': 0.08
                },
                // Multiplicadores de raridade
                rarityPower: {
                    'Comum': 1.00,
                    'Incomum': 1.08,
                    'Raro': 1.18,
                    'M√≠stico': 1.32,
                    'Lend√°rio': 1.50
                },
                rarityXP: {
                    'Comum': 1.00,
                    'Incomum': 1.05,
                    'Raro': 1.10,
                    'M√≠stico': 1.15,
                    'Lend√°rio': 1.25
                },
                // Chance base de fuga por raridade
                fleeBase: {
                    'Comum': 10,
                    'Incomum': 12,
                    'Raro': 15,
                    'M√≠stico': 18,
                    'Lend√°rio': 25
                },
                medalTiers: { bronze: 5, silver: 12, gold: 25 }
            }
        };

        // MONSTER CATALOG (baseado em MONSTROS.csv)
        const MONSTER_CATALOG = [
            { id: 'MON_001', name: 'Cantapau', class: 'Bardo', rarity: 'Comum', baseHp: 28, baseAtk: 6, baseDef: 4, baseSpd: 6, emoji: 'üéµ' },
            { id: 'MON_002', name: 'Pedrino', class: 'Guerreiro', rarity: 'Comum', baseHp: 32, baseAtk: 7, baseDef: 6, baseSpd: 5, emoji: '‚öîÔ∏è', evolvesTo: 'MON_002B', evolvesAt: 12 },
            { id: 'MON_002B', name: 'Pedronar', class: 'Guerreiro', rarity: 'Incomum', baseHp: 42, baseAtk: 10, baseDef: 8, baseSpd: 6, emoji: '‚öîÔ∏è', evolvesTo: 'MON_002C', evolvesAt: 25 },
            { id: 'MON_002C', name: 'Pedragon', class: 'Guerreiro', rarity: 'Raro', baseHp: 56, baseAtk: 14, baseDef: 11, baseSpd: 8, emoji: 'üó°Ô∏è' },
            { id: 'MON_003', name: 'Fa√≠scari', class: 'Mago', rarity: 'Comum', baseHp: 26, baseAtk: 8, baseDef: 3, baseSpd: 7, emoji: 'üîÆ' },
            { id: 'MON_004', name: 'Ninfolha', class: 'Curandeiro', rarity: 'Comum', baseHp: 30, baseAtk: 4, baseDef: 4, baseSpd: 5, emoji: 'üíö' },
            { id: 'MON_005', name: 'Garruncho', class: 'Ca√ßador', rarity: 'Comum', baseHp: 29, baseAtk: 7, baseDef: 3, baseSpd: 8, emoji: 'üèπ' },
            { id: 'MON_100', name: 'Rato-de-Lama', class: 'Guerreiro', rarity: 'Comum', baseHp: 20, baseAtk: 5, baseDef: 3, baseSpd: 4, emoji: 'üêÄ' }
        ];

        // ENE REGEN CONSTANTS por classe (fallback)
        const ENE_REGEN_BY_CLASS = {
            'Mago': { pct: 0.18, min: 3 },
            'Curandeiro': { pct: 0.18, min: 3 },
            'Bardo': { pct: 0.14, min: 2 },
            'Ca√ßador': { pct: 0.14, min: 2 },
            'Ladino': { pct: 0.14, min: 2 },
            'Animalista': { pct: 0.12, min: 2 },
            'B√°rbaro': { pct: 0.12, min: 2 },
            'Guerreiro': { pct: 0.10, min: 1 }
        };

        // POWER B√ÅSICO por classe (ataque sem habilidade)
        const BASIC_ATTACK_POWER = {
            'Guerreiro': 12,
            'Mago': 11,
            'Curandeiro': 10,
            'B√°rbaro': 14,
            'Ladino': 12,
            'Bardo': 11,
            'Ca√ßador': 13,
            'Animalista': 12
        };

        // SKILL DEFINITIONS (inline - por classe e est√°gio)
        const SKILL_DEFS = {
            // GUERREIRO
            'Guerreiro': {
                'Golpe de Espada': [
                    { tier: 1, name: 'Golpe de Espada I', type: 'DAMAGE', cost: 4, power: 18, desc: 'Ataque com espada.' },
                    { tier: 2, name: 'Golpe de Espada II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque forte com espada.' },
                    { tier: 3, name: 'Golpe de Espada III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque devastador com espada.' }
                ],
                'Escudo': [
                    { tier: 1, name: 'Escudo I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF temporariamente.' },
                    { tier: 2, name: 'Escudo II', type: 'BUFF', cost: 6, power: 3, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta muito a DEF.' },
                    { tier: 3, name: 'Escudo III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'self', duration: 3, desc: 'Escudo poderoso.' }
                ],
                'Provocar': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Provocar I', type: 'TAUNT', cost: 4, power: 0, desc: 'Provoca o inimigo.' },
                    { tier: 3, name: 'Provocar II', type: 'TAUNT', cost: 6, power: 0, desc: 'Provoca intensamente.' }
                ]
            },
            // CURANDEIRO
            'Curandeiro': {
                'Cura': [
                    { tier: 1, name: 'Cura I', type: 'HEAL', cost: 5, power: 15, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Cura II', type: 'HEAL', cost: 7, power: 25, target: 'ally', desc: 'Cura moderada.' },
                    { tier: 3, name: 'Cura III', type: 'HEAL', cost: 10, power: 40, target: 'ally', desc: 'Cura poderosa.' }
                ],
                'B√™n√ß√£o': [
                    { tier: 1, name: 'B√™n√ß√£o I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK do aliado.' },
                    { tier: 2, name: 'B√™n√ß√£o II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'B√™n√ß√£o III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'ally', duration: 3, desc: 'B√™n√ß√£o poderosa (DEF).' }
                ]
            },
            // MAGO
            'Mago': {
                'Magia Elemental': [
                    { tier: 1, name: 'Magia Elemental I', type: 'DAMAGE', cost: 4, power: 20, desc: 'Magia elemental.' },
                    { tier: 2, name: 'Magia Elemental II', type: 'DAMAGE', cost: 6, power: 26, desc: 'Magia elemental forte.' },
                    { tier: 3, name: 'Magia Elemental III', type: 'DAMAGE', cost: 8, power: 32, desc: 'Magia elemental poderosa.' }
                ],
                'Explos√£o Elemental': [
                    { tier: 1, name: 'Explos√£o Elemental I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Explos√£o m√°gica.' },
                    { tier: 2, name: 'Explos√£o Elemental II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Explos√£o m√°gica forte.' },
                    { tier: 3, name: 'Explos√£o Elemental III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Explos√£o devastadora.' }
                ]
            },
            // B√ÅRBARO
            'B√°rbaro': {
                'F√∫ria': [
                    { tier: 1, name: 'F√∫ria I', type: 'BUFF', cost: 4, power: 3, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -1, desc: 'Aumenta ATK, reduz DEF.' },
                    { tier: 2, name: 'F√∫ria II', type: 'BUFF', cost: 6, power: 4, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -2, desc: 'F√∫ria intensa.' },
                    { tier: 3, name: 'F√∫ria III', type: 'BUFF', cost: 8, power: 6, buffType: 'ATK', target: 'self', duration: 3, debuffType: 'DEF', debuffPower: -2, desc: 'F√∫ria selvagem.' }
                ],
                'Golpe Brutal': [
                    { tier: 1, name: 'Golpe Brutal I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Golpe brutal.' },
                    { tier: 2, name: 'Golpe Brutal II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Golpe muito brutal.' },
                    { tier: 3, name: 'Golpe Brutal III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Golpe devastador.' }
                ]
            },
            // LADINO
            'Ladino': {
                'Ataque Preciso': [
                    { tier: 1, name: 'Ataque Preciso I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Ataque preciso.' },
                    { tier: 2, name: 'Ataque Preciso II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque muito preciso.' },
                    { tier: 3, name: 'Ataque Preciso III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque extremamente preciso.' }
                ],
                'Enfraquecer': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Enfraquecer I', type: 'BUFF', cost: 4, power: -2, buffType: 'ATK', target: 'enemy', duration: 1, desc: 'Reduz ATK do inimigo.' },
                    { tier: 3, name: 'Enfraquecer II', type: 'BUFF', cost: 6, power: -3, buffType: 'ATK', target: 'enemy', duration: 2, desc: 'Enfraquece muito o inimigo.' }
                ]
            },
            // BARDO
            'Bardo': {
                'Can√ß√£o de Coragem': [
                    { tier: 1, name: 'Can√ß√£o de Coragem I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK.' },
                    { tier: 2, name: 'Can√ß√£o de Coragem II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'Can√ß√£o de Coragem III', type: 'BUFF', cost: 8, power: 4, buffType: 'ATK', target: 'ally', duration: 3, desc: 'Can√ß√£o inspiradora.' }
                ],
                'Can√ß√£o Calmante': [
                    { tier: 1, name: 'Can√ß√£o Calmante I', type: 'HEAL', cost: 5, power: 12, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Can√ß√£o Calmante II', type: 'BUFF', cost: 6, power: 2, buffType: 'DEF', target: 'ally', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 3, name: 'Can√ß√£o Calmante III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'ally', duration: 3, desc: 'Can√ß√£o protetora.' }
                ]
            },
            // CA√áADOR
            'Ca√ßador': {
                'Flecha Poderosa': [
                    { tier: 1, name: 'Flecha Poderosa I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Flecha poderosa.' },
                    { tier: 2, name: 'Flecha Poderosa II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Flecha muito poderosa.' },
                    { tier: 3, name: 'Flecha Poderosa III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Flecha devastadora.' }
                ],
                'Armadilha': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Armadilha I', type: 'BUFF', cost: 4, power: -2, buffType: 'SPD', target: 'enemy', duration: 1, desc: 'Reduz SPD do inimigo.' },
                    { tier: 3, name: 'Armadilha II', type: 'BUFF', cost: 6, power: -3, buffType: 'SPD', target: 'enemy', duration: 2, desc: 'Armadilha poderosa.' }
                ]
            },
            // ANIMALISTA
            'Animalista': {
                'Investida Bestial': [
                    { tier: 1, name: 'Investida Bestial I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Investida feroz.' },
                    { tier: 2, name: 'Investida Bestial II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Investida muito feroz.' },
                    { tier: 3, name: 'Investida Bestial III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Investida selvagem.' }
                ],
                'Instinto Selvagem': [
                    { tier: 1, name: 'Instinto Selvagem I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 2, name: 'Instinto Selvagem II', type: 'BUFF', cost: 6, power: 2, buffType: 'SPD', target: 'self', duration: 2, desc: 'Aumenta SPD.' },
                    { tier: 3, name: 'Instinto Selvagem III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'self', duration: 3, desc: 'Instinto agu√ßado.' }
                ]
            }
        };

        // CLASTERORB TIERS (Sistema de captura em tiers)
        const CLASTERORBS = {
            'CLASTERORB_COMUM': { id: 'CLASTERORB_COMUM', name: 'ClasterOrb Comum', type: 'CAPTURE', capture_bonus_pp: 0, emoji: '‚ö™' },
            'CLASTERORB_INCOMUM': { id: 'CLASTERORB_INCOMUM', name: 'ClasterOrb Incomum', type: 'CAPTURE', capture_bonus_pp: 5, emoji: 'üîµ' },
            'CLASTERORB_RARA': { id: 'CLASTERORB_RARA', name: 'ClasterOrb Rara', type: 'CAPTURE', capture_bonus_pp: 10, emoji: 'üü£' }
        };

        // SKILLS CATALOG (baseado em HABILIDADES.csv)
        const SKILLS_CATALOG = [
            // Tier I skills (original)
            { id: 'SK_WAR_01', name: 'Golpe de Escudo', class: 'Guerreiro', category: 'Controle', power: 6, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: 'Atordoado', desc: 'Ataque curto com chance de atordoar.' },
            { id: 'SK_WAR_02', name: 'Corte Pesado', class: 'Guerreiro', category: 'Ataque', power: 9, accuracy: 0.8, energy_cost: 3, target: 'Inimigo', status: '', desc: 'Dano alto, menos preciso.' },
            { id: 'SK_MAG_01', name: 'Raio M√≠stico', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Dano m√°gico √† dist√¢ncia.' },
            { id: 'SK_MAG_02', name: 'N√©voa Lenta', class: 'Mago', category: 'Controle', power: 4, accuracy: 0.9, energy_cost: 3, target: '√Årea', status: 'Enraizado', desc: 'Reduz a√ß√£o/movimento por 1 turno.' },
            { id: 'SK_HEA_01', name: 'Sopro Calmante', class: 'Curandeiro', category: 'Cura', power: 0, accuracy: 1, energy_cost: 4, target: 'Aliado', status: '', desc: 'Cura moderada.' },
            { id: 'SK_HEA_02', name: 'Barreira Suave', class: 'Curandeiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Aliado', status: 'Protegido', desc: 'Aumenta defesa por 2 turnos.' },
            { id: 'SK_HUN_01', name: 'Flecha R√°pida', class: 'Ca√ßador', category: 'Ataque', power: 8, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: '', desc: 'Dano consistente √† dist√¢ncia.' },
            { id: 'SK_BRD_01', name: 'Can√ß√£o de Coragem', class: 'Bardo', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: '√Årea', status: 'Fortalecido', desc: 'Buff de ataque para aliados.' },
            
            // Feature 3.6: Tier I/II/III variants for testing
            { id: 'GOLPE_ESPADA_I', name: 'Golpe de Espada I', class: 'Guerreiro', category: 'Ataque', power: 8, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Ataque de espada b√°sico.' },
            { id: 'GOLPE_ESPADA_II', name: 'Golpe de Espada II', class: 'Guerreiro', category: 'Ataque', power: 12, accuracy: 0.85, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de espada aprimorado.' },
            { id: 'GOLPE_ESPADA_III', name: 'Golpe de Espada III', class: 'Guerreiro', category: 'Ataque', power: 18, accuracy: 0.85, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de espada mestre.' },
            
            { id: 'ESCUDO_I', name: 'Escudo I', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 4, target: 'Self', status: 'Protegido', desc: 'Defesa b√°sica.' },
            { id: 'ESCUDO_II', name: 'Escudo II', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 5, target: 'Self', status: 'Protegido', desc: 'Defesa aprimorada.' },
            { id: 'ESCUDO_III', name: 'Escudo III', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 6, target: 'Self', status: 'Protegido', desc: 'Defesa mestre.' },
            
            { id: 'BOLA_FOGO_I', name: 'Bola de Fogo I', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.9, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de fogo b√°sico.' },
            { id: 'BOLA_FOGO_II', name: 'Bola de Fogo II', class: 'Mago', category: 'Ataque', power: 15, accuracy: 0.9, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de fogo aprimorado.' },
            { id: 'BOLA_FOGO_III', name: 'Bola de Fogo III', class: 'Mago', category: 'Ataque', power: 22, accuracy: 0.9, energy_cost: 8, target: 'Inimigo', status: '', desc: 'Ataque de fogo mestre.' }
        ];

        // CLASS ENERGY REGEN (baseado em CLASSES.csv)
        const CLASS_ENERGY_REGEN = {
            'Guerreiro': { ene_regen_pct: 0.10, ene_regen_min: 2 },
            'Mago': { ene_regen_pct: 0.25, ene_regen_min: 1 },
            'Curandeiro': { ene_regen_pct: 0.20, ene_regen_min: 2 },
            'B√°rbaro': { ene_regen_pct: 0.10, ene_regen_min: 1 },
            'Ladino': { ene_regen_pct: 0.15, ene_regen_min: 1 },
            'Bardo': { ene_regen_pct: 0.18, ene_regen_min: 2 },
            'Ca√ßador': { ene_regen_pct: 0.12, ene_regen_min: 2 },
            'Animalista': { ene_regen_pct: 0.15, ene_regen_min: 2 }
        };

        // DEFAULT OBJECTIVES
        const DEFAULT_OBJECTIVES = [
            { id: 1, text: 'Followed group rules', weight: 2 },
            { id: 2, text: 'Waited for turn patiently', weight: 3 },
            { id: 3, text: 'Helped another player', weight: 3 },
            { id: 4, text: 'Used calm voice throughout', weight: 2 },
            { id: 5, text: 'Made good eye contact', weight: 1 },
            { id: 6, text: 'Shared materials/ideas', weight: 2 }
        ];

        // INITIALIZATION
        function init() {
            try {
                loadFromLocalStorage();
                if (!GameState.objectives || GameState.objectives.length === 0) {
                    GameState.objectives = [...DEFAULT_OBJECTIVES];
                }
                updateAllViews();
                console.log('Monstrinhomon initialized successfully');
            } catch (error) {
                showError('Initialization failed', error.stack);
            }
        }

        // LOCAL STORAGE
        function saveToLocalStorage() {
            try {
                const data = JSON.stringify(GameState);
                localStorage.setItem('monstrinhomon_state', data);
            } catch (error) {
                showError('Failed to save data', error.stack);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('monstrinhomon_state');
                if (data) {
                    const loaded = JSON.parse(data);
                    
                    // Valida√ß√£o b√°sica da estrutura
                    if (typeof loaded !== 'object' || loaded === null) {
                        console.warn('Invalid save data format, skipping load');
                        return;
                    }
                    
                    // Validar arrays essenciais
                    if (loaded.players && !Array.isArray(loaded.players)) {
                        console.warn('Invalid players array, resetting');
                        loaded.players = [];
                    }
                    if (loaded.monsters && !Array.isArray(loaded.monsters)) {
                        console.warn('Invalid monsters array, resetting');
                        loaded.monsters = [];
                    }
                    
                    Object.assign(GameState, loaded);
                    
                    // Migrar invent√°rios antigos
                    if (GameState.players) {
                        GameState.players.forEach(player => {
                            // Validar estrutura do jogador
                            if (!player.id || !player.name) {
                                console.warn('Invalid player detected:', player);
                                return;
                            }
                            
                            migrateInventory(player);
                            
                            // Garantir arrays
                            player.team = Array.isArray(player.team) ? player.team : [];
                            player.box = Array.isArray(player.box) ? player.box : [];
                            player.inventory = player.inventory || {};
                            
                            // Garantir que monstros tenham ENE e campos de progress√£o (Feature 3.3)
                            if (player.team) {
                                player.team.forEach(monster => {
                                    if (!monster) return;
                                    
                                    // ENE (Sistema ENE)
                                    if (!monster.eneMax) {
                                        monster.eneMax = 10 + (monster.level || 1);
                                        monster.ene = monster.eneMax;
                                    }
                                    if (monster.ene === undefined) {
                                        monster.ene = monster.eneMax;
                                    }
                                    
                                    // Progress√£o (Feature 3.3) - compatibilidade com saves antigos
                                    ensureMonsterProgressFields(monster);
                                });
                            }
                        });
                    }
                    
                    console.log('Save data loaded successfully');
                }
            } catch (error) {
                console.warn('Failed to load saved data:', error);
                // Resetar para estado seguro em caso de corrup√ß√£o severa
                if (error instanceof SyntaxError) {
                    console.error('Save data is corrupted (JSON parse failed). Starting fresh.');
                    localStorage.removeItem('monstrinhomon_state');
                }
            }
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            try {
                const tabs = document.querySelectorAll('.tab-content');
                const buttons = document.querySelectorAll('.tab-button');
                
                tabs.forEach(tab => tab.classList.remove('active'));
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeTab = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                const activeButton = Array.from(buttons).find(btn => 
                    btn.textContent.toLowerCase().includes(tabName.toLowerCase())
                );
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                
                updateAllViews();
            } catch (error) {
                showError('Tab switching failed', error.stack);
            }
        }

        // PLAYER MANAGEMENT
        function addPlayer() {
            try {
                const name = document.getElementById('playerName')?.value?.trim();
                const playerClass = document.getElementById('playerClass')?.value;
                
                if (!name) {
                    alert('Please enter a player name');
                    return;
                }
                
                if (!playerClass) {
                    alert('Please select a class');
                    return;
                }
                
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    class: playerClass, // Armazena a classe diretamente
                    playerClassId: playerClass,
                    money: 100,
                    afterlifeCurrency: 0,
                    team: [],
                    box: [],
                    inventory: {
                        'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                        'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                        'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                        'IT_HEAL_01': 3           // Petisco de Cura x3
                    }
                };
                
                GameState.players = GameState.players || [];
                GameState.players.push(player);
                
                giveStarterMonster(player);
                
                document.getElementById('playerName').value = '';
                document.getElementById('playerClass').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add player', error.stack);
            }
        }

        function giveStarterMonster(player) {
            try {
                // Busca monstrinho inicial da mesma classe do jogador
                const classMonsters = MONSTER_CATALOG.filter(m => 
                    m?.class === player?.class && m?.rarity === 'Comum'
                );
                
                // Se n√£o encontrar da mesma classe, pega qualquer starter comum
                const starterTemplate = classMonsters.length > 0 ? classMonsters[0] : 
                    MONSTER_CATALOG.find(m => m?.rarity === 'Comum');
                
                if (!starterTemplate) return;
                
                const monster = createMonsterInstance(starterTemplate, player.id, 5);
                
                if (monster) {
                    player.team = player.team || [];
                    player.team.push(monster);
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                }
            } catch (error) {
                console.error('Failed to give starter monster:', error);
            }
        }

        function createMonsterInstance(template, ownerId, level = 1) {
            try {
                if (!template) return null;
                
                // Calcular stats baseados no n√≠vel
                const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult); // SPD adicionado
                const poder = Math.floor(atk * 0.5); // PODER √© derivado de ATK
                
                // Calcular ENE (Sistema ENE)
                const baseEne = template.baseEne || 10; // Fallback se n√£o tiver no template
                const eneGrowth = 2; // growth_ene padr√£o
                const eneMax = Math.floor(baseEne + eneGrowth * (level - 1));
                
                // Determinar stage baseado no n√≠vel (simplificado)
                // S0: n√≠vel 1-9, S1: 10-24, S2: 25-44, S3: 45+
                let stage = 0;
                if (level >= 45) stage = 3;
                else if (level >= 25) stage = 2;
                else if (level >= 10) stage = 1;
                
                return {
                    id: Date.now() + Math.random(),
                    ownerId: ownerId,
                    monsterId: template.id,
                    name: template.name,
                    nickname: template.name, // Nickname padr√£o
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji,
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level), // Feature 3.3
                    hp: hpMax,
                    hpMax: hpMax,
                    atk: atk,
                    def: def,
                    spd: spd,           // SPD adicionado
                    poder: poder,
                    ene: eneMax,      // ENE atual (come√ßa cheio)
                    eneMax: eneMax,   // ENE m√°ximo
                    stage: stage,     // Est√°gio de evolu√ß√£o (0-3)
                    status: 'healthy',
                    buffs: []         // Array para buffs tempor√°rios
                };
            } catch (error) {
                console.error('Failed to create monster instance:', error);
                return null;
            }
        }

        // Fun√ß√£o para obter habilidade do monstrinho
        // Obter habilidades do monstrinho baseado em classe e est√°gio
        function getMonsterSkills(monster) {
            try {
                if (!monster || !monster.class) return [];
                
                const classSkills = SKILL_DEFS[monster.class];
                if (!classSkills) return [];
                
                const stage = monster.stage || 0;
                const skillList = [];
                
                // Pegar as duas primeiras skills sempre dispon√≠veis
                const skillNames = Object.keys(classSkills);
                for (let i = 0; i < Math.min(2, skillNames.length); i++) {
                    const skillTiers = classSkills[skillNames[i]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                // Terceira skill (se existir e stage >= 1)
                if (skillNames.length > 2 && stage >= 1) {
                    const skillTiers = classSkills[skillNames[2]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                return skillList;
            } catch (error) {
                console.error('Failed to get monster skills:', error);
                return [];
            }
        }

        // Aplicar regenera√ß√£o de ENE
        function applyEneRegen(monster, encounter) {
            try {
                if (!monster || !monster.class) return;
                
                const regenData = ENE_REGEN_BY_CLASS[monster.class] || { pct: 0.10, min: 1 };
                const eneGain = Math.max(regenData.min, Math.ceil(monster.eneMax * regenData.pct));
                
                monster.ene = Math.min(monster.eneMax, monster.ene + eneGain);
                
                if (encounter && encounter.log) {
                    encounter.log.push(`‚ö° ${monster.name} regenerou ${eneGain} ENE (${monster.ene}/${monster.eneMax})`);
                }
            } catch (error) {
                console.error('Failed to apply ENE regen:', error);
            }
        }

        // Usar habilidade
        function useSkill(attacker, skill, defender, encounter) {
            try {
                if (!attacker || !skill || !defender) return false;
                
                // Verificar se tem ENE suficiente
                if (attacker.ene < skill.cost) {
                    return false;
                }
                
                // Consumir ENE
                attacker.ene -= skill.cost;
                
                encounter.log = encounter.log || [];
                encounter.log.push(`‚ú® ${attacker.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                
                // Aplicar efeito baseado no tipo
                switch (skill.type) {
                    case 'DAMAGE':
                        // Calcular dano da habilidade com nova f√≥rmula
                        const atkMods = getBuffModifiers(attacker);
                        const effectiveAtk = Math.max(1, attacker.atk + atkMods.atk);
                        
                        const defMods = getBuffModifiers(defender);
                        const effectiveDef = Math.max(1, defender.def + defMods.def);
                        
                        // Vantagem de classe
                        const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                        let damageMult = 1.0;
                        if (classAdv?.strong === defender.class) {
                            damageMult = 1.10;
                        } else if (classAdv?.weak === defender.class) {
                            damageMult = 0.90;
                        }
                        
                        const skillDamage = calcDamage({
                            atk: effectiveAtk,
                            def: effectiveDef,
                            power: skill.power,
                            damageMult: damageMult
                        });
                        
                        defender.hp = Math.max(0, defender.hp - skillDamage);
                        encounter.log.push(`üí• ${defender.name} recebe ${skillDamage} de dano!`);
                        break;
                        
                    case 'HEAL':
                        // Curar (self ou ally)
                        const healAmount = skill.power;
                        const target = (skill.target === 'ally' || skill.target === 'self') ? attacker : defender;
                        target.hp = Math.min(target.hpMax, target.hp + healAmount);
                        encounter.log.push(`üíö ${target.name} recupera ${healAmount} HP!`);
                        break;
                        
                    case 'BUFF':
                        // Aplicar buff/debuff
                        const buffTarget = skill.target === 'enemy' ? defender : attacker;
                        buffTarget.buffs = buffTarget.buffs || [];
                        
                        const buff = {
                            type: skill.buffType,
                            power: skill.power,
                            duration: skill.duration || 1,
                            source: skill.name
                        };
                        buffTarget.buffs.push(buff);
                        
                        const buffDesc = skill.power > 0 ? `+${skill.power}` : skill.power;
                        encounter.log.push(`üîÆ ${buffTarget.name} recebe ${buff.type} ${buffDesc} por ${buff.duration} turnos!`);
                        
                        // Se for F√∫ria (B√°rbaro), aplicar tamb√©m o debuff
                        if (skill.debuffType && skill.debuffPower) {
                            const debuff = {
                                type: skill.debuffType,
                                power: skill.debuffPower,
                                duration: skill.duration || 1,
                                source: skill.name
                            };
                            attacker.buffs.push(debuff);
                            encounter.log.push(`‚ö†Ô∏è ${attacker.name} recebe ${debuff.type} ${debuff.power} por ${debuff.duration} turnos!`);
                        }
                        break;
                        
                    case 'TAUNT':
                        // Marcar alvo como provocado (flag simples)
                        defender.taunted = true;
                        encounter.log.push(`üò† ${defender.name} foi provocado!`);
                        break;
                }
                
                return true;
            } catch (error) {
                console.error('Failed to use skill:', error);
                return false;
            }
        }

        // Atualizar buffs (reduzir dura√ß√£o, remover expirados)
        function updateBuffs(monster) {
            try {
                if (!monster || !monster.buffs) return;
                
                monster.buffs = monster.buffs.filter(buff => {
                    buff.duration--;
                    return buff.duration > 0;
                });
            } catch (error) {
                console.error('Failed to update buffs:', error);
            }
        }

        // Calcular modificadores de buffs
        function getBuffModifiers(monster) {
            try {
                if (!monster || !monster.buffs) return { atk: 0, def: 0, spd: 0 };
                
                const mods = { atk: 0, def: 0, spd: 0 };
                
                monster.buffs.forEach(buff => {
                    const type = buff.type.toLowerCase();
                    if (type === 'atk') mods.atk += buff.power;
                    else if (type === 'def') mods.def += buff.power;
                    else if (type === 'spd') mods.spd += buff.power;
                });
                
                return mods;
            } catch (error) {
                console.error('Failed to get buff modifiers:', error);
                return { atk: 0, def: 0, spd: 0 };
            }
        }

        // Fun√ß√£o antiga removida - usar getMonsterSkills acima

        // Migrar invent√°rio antigo para novo sistema ClasterOrb
        function migrateInventory(player) {
            try {
                if (!player || !player.inventory) return;
                
                // Se tem IT_CAP_01 antigo, converter para CLASTERORB_COMUM
                if (player.inventory['IT_CAP_01']) {
                    const oldCount = player.inventory['IT_CAP_01'];
                    player.inventory['CLASTERORB_COMUM'] = (player.inventory['CLASTERORB_COMUM'] || 0) + oldCount;
                    delete player.inventory['IT_CAP_01'];
                }
                
                // Garantir que novos itens existam
                if (!player.inventory['CLASTERORB_COMUM']) player.inventory['CLASTERORB_COMUM'] = 0;
                if (!player.inventory['CLASTERORB_INCOMUM']) player.inventory['CLASTERORB_INCOMUM'] = 0;
                if (!player.inventory['CLASTERORB_RARA']) player.inventory['CLASTERORB_RARA'] = 0;
            } catch (error) {
                console.error('Failed to migrate inventory:', error);
            }
        }

        // SESSION MANAGEMENT
        function createSession() {
            try {
                const name = document.getElementById('sessionName')?.value?.trim();
                
                if (!name) {
                    alert('Please enter a session name');
                    return;
                }
                
                if (!GameState.players || GameState.players.length === 0) {
                    alert('Please add players first');
                    return;
                }
                
                const session = {
                    id: Date.now(),
                    name: name,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    players: GameState.players.map(p => p?.id).filter(id => id),
                    turnOrder: [...GameState.players.map(p => p?.id).filter(id => id)],
                    currentTurnIndex: 0,
                    encountersLog: [],
                    therapy: {
                        perPlayer: {}
                    }
                };
                
                GameState.players.forEach(player => {
                    if (player?.id) {
                        session.therapy.perPlayer[player.id] = {
                            pm: 0,
                            medals: [],
                            logs: [],
                            completedObjectives: []
                        };
                    }
                });
                
                GameState.sessions = GameState.sessions || [];
                GameState.sessions.push(session);
                GameState.currentSession = session;
                
                document.getElementById('sessionName').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to create session', error.stack);
            }
        }

        function nextTurn() {
            try {
                if (!GameState.currentSession) return;
                
                const session = GameState.currentSession;
                session.currentTurnIndex = ((session.currentTurnIndex || 0) + 1) % (session.turnOrder?.length || 1);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to advance turn', error.stack);
            }
        }

        function endSession() {
            try {
                if (!GameState.currentSession) return;
                
                if (confirm('End this session?')) {
                    GameState.currentSession.completedAt = new Date().toISOString();
                    GameState.currentSession = null;
                    
                    saveToLocalStorage();
                    updateAllViews();
                }
            } catch (error) {
                showError('Failed to end session', error.stack);
            }
        }

        // ENCOUNTER MANAGEMENT
        function startEncounter() {
            try {
                const type = document.getElementById('encounterType')?.value;
                
                if (!type) {
                    alert('Please select encounter type');
                    return;
                }
                
                if (!GameState.currentSession) {
                    alert('Please create a session first');
                    return;
                }
                
                // Para encontros em grupo (trainer/boss), usar sistema de grupo
                if (type === 'trainer' || type === 'boss') {
                    // Coletar participantes selecionados
                    const checkboxes = document.querySelectorAll('input[name="groupParticipant"]:checked');
                    const selectedPlayerIds = Array.from(checkboxes).map(cb => cb.value);
                    
                    if (selectedPlayerIds.length === 0) {
                        alert('Selecione pelo menos 1 jogador para a batalha em grupo');
                        return;
                    }
                    
                    if (selectedPlayerIds.length > 6) {
                        alert('M√°ximo de 6 jogadores por batalha');
                        return;
                    }
                    
                    const enemyLevel = parseInt(document.getElementById('enemyLevel')?.value || '5');
                    startGroupEncounter(selectedPlayerIds, type, enemyLevel);
                    return;
                }
                
                // Para encontros individuais (captura), precisa selecionar jogador
                if (type === 'wild') {
                    const selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                    if (!selectedPlayerId) {
                        alert('Please select a player for individual encounter');
                        return;
                    }
                    
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (!player || !player.team || player.team.length === 0) {
                        alert('Selected player has no monsters in team');
                        return;
                    }
                    
                    // GAME_RULES.md: Em batalha, s√≥ pode usar monstros da mesma classe do jogador
                    const validMonsters = player.team.filter(m => m.class === player.class && m.status !== 'fainted');
                    if (validMonsters.length === 0) {
                        alert(`‚ö†Ô∏è ${player.name} n√£o tem monstrinhos da classe ${player.class} dispon√≠veis!\n\nREGRA: Em batalha, voc√™ s√≥ pode usar monstrinhos da SUA classe.\nTroque com outros jogadores para conseguir monstrinhos da sua classe!`);
                        return;
                    }
                }
                
                const encounter = {
                    id: Date.now(),
                    type: type,
                    active: true,
                    log: [],
                    selectedPlayerId: type === 'wild' ? document.getElementById('encounterPlayer')?.value : null,
                    rewardsGranted: false  // Previne duplica√ß√£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                if (type === 'wild') {
                    // Limpar buffs do monstrinho do jogador antes da batalha
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (player && player.team) {
                        for (const mon of player.team) {
                            if (mon && mon.buffs) {
                                mon.buffs = [];
                            }
                        }
                    }
                    
                    const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                    const level = Math.floor(Math.random() * 10) + 1;
                    encounter.wildMonster = createMonsterInstance(randomMonster, null, level);
                    encounter.wildMonster.id = 'wild_' + Date.now();
                }
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start encounter', error.stack);
            }
        }

        // GROUP BATTLE FUNCTIONS (Feature 3.2)
        
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function startGroupEncounter(selectedPlayerIds, encounterType, enemyLevel) {
            try {
                // Limpar buffs dos monstrinhos dos jogadores participantes
                for (const pid of selectedPlayerIds) {
                    const player = GameState.players.find(p => p.id === pid);
                    if (player && player.team) {
                        for (const mon of player.team) {
                            if (mon && mon.buffs) {
                                mon.buffs = [];
                            }
                        }
                    }
                }
                
                // Criar inimigo
                const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                const enemy = createMonsterInstance(randomMonster, null, enemyLevel);
                enemy.id = 'enemy_1';
                
                // Criar encounter de grupo
                const encounter = {
                    id: Date.now(),
                    type: encounterType === 'boss' ? 'boss' : 'group_trainer',
                    active: true,
                    log: [],
                    participants: selectedPlayerIds,
                    enemies: [enemy],
                    turnOrder: [],
                    turnIndex: 0,
                    currentActor: null,
                    finished: false,
                    result: null,
                    rewardsGranted: false  // Previne duplica√ß√£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                // Calcular ordem de turnos
                encounter.turnOrder = calculateGroupTurnOrder(encounter);
                encounter.turnIndex = 0;
                encounter.currentActor = getCurrentActor(encounter);
                
                encounter.log.push('üé≤ Ordem de turnos calculada!');
                encounter.turnOrder.forEach((actor, idx) => {
                    const tieInfo = actor._tiebreak ? ` (d20: ${actor._tiebreak})` : '';
                    encounter.log.push(`   ${idx + 1}. ${actor.name} (${actor.side === 'player' ? 'Jogador' : 'Inimigo'}, SPD: ${actor.spd}${tieInfo})`);
                });
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start group encounter', error.stack);
            }
        }
        
        function calculateGroupTurnOrder(enc) {
            const order = [];
            
            // Adicionar jogadores participantes
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                if (!p) continue;
                
                const mon = p.team?.[0];
                if (!mon) continue;
                
                const hp = Number(mon.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "player",
                    id: pid,
                    name: p.name || p.nome || "Jogador",
                    spd: Number(mon.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Adicionar inimigos
            for (let i = 0; i < (enc.enemies || []).length; i++) {
                const e = enc.enemies[i];
                if (!e) continue;
                
                const hp = Number(e.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "enemy",
                    id: i,
                    name: e.name || e.nome || `Inimigo ${i + 1}`,
                    spd: Number(e.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Ordenar por SPD descendente
            order.sort((a, b) => (b.spd - a.spd));
            
            // Desempate por grupos de mesmo SPD
            let i = 0;
            while (i < order.length) {
                let j = i + 1;
                while (j < order.length && order[j].spd === order[i].spd) j++;
                
                // [i, j) √© o bloco empatado
                if (j - i > 1) {
                    for (let k = i; k < j; k++) {
                        order[k]._tiebreak = rollD20();
                    }
                    const sortedBlock = order.slice(i, j).sort((a, b) => (b._tiebreak - a._tiebreak));
                    for (let k = 0; k < sortedBlock.length; k++) {
                        order[i + k] = sortedBlock[k];
                    }
                }
                
                i = j;
            }
            
            return order;
        }
        
        function getCurrentActor(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return null;
            const idx = Number(enc.turnIndex) || 0;
            return enc.turnOrder[idx] || null;
        }
        
        function _hasAlivePlayers(enc) {
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                const mon = p?.team?.[0];
                if (mon && (Number(mon.hp) || 0) > 0) return true;
            }
            return false;
        }
        
        function _hasAliveEnemies(enc) {
            for (const e of (enc.enemies || [])) {
                if ((Number(e?.hp) || 0) > 0) return true;
            }
            return false;
        }
        
        function advanceTurn(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return;
            
            // Verificar condi√ß√µes de fim
            const alivePlayers = _hasAlivePlayers(enc);
            const aliveEnemies = _hasAliveEnemies(enc);
            
            if (!aliveEnemies) {
                enc.finished = true;
                enc.result = "victory";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("üèÅ Vit√≥ria! Todos os inimigos foram derrotados.");
                
                // Distribuir recompensas (XP) com idempot√™ncia
                handleVictoryRewards(enc);
                
                return;
            }
            
            if (!alivePlayers) {
                enc.finished = true;
                enc.result = "defeat";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("üíÄ Derrota... Todos os participantes foram derrotados.");
                return;
            }
            
            // Avan√ßar para pr√≥ximo ator v√°lido
            const maxLoops = enc.turnOrder.length + 2;
            let loops = 0;
            
            do {
                enc.turnIndex = ((Number(enc.turnIndex) || 0) + 1) % enc.turnOrder.length;
                loops++;
                
                const actor = getCurrentActor(enc);
                if (!actor) break;
                
                // Validar se ator ainda est√° vivo
                if (actor.side === "player") {
                    const p = GameState.players.find(x => x.id === actor.id);
                    const mon = p?.team?.[0];
                    if (mon && (Number(mon.hp) || 0) > 0) break;
                } else {
                    const e = enc.enemies?.[actor.id];
                    if (e && (Number(e.hp) || 0) > 0) break;
                }
                
            } while (loops < maxLoops);
            
            // Atualizar currentActor
            enc.currentActor = getCurrentActor(enc);
            
            // Auto-trigger turno do inimigo
            const actorNow = getCurrentActor(enc);
            if (actorNow && actorNow.side === "enemy" && !enc.finished) {
                processEnemyTurnGroup(enc);
            } else if (actorNow) {
                enc.log = enc.log || [];
                enc.log.push(`‚è∫Ô∏è Turno: ${actorNow.name}`);
            }
        }
        
        function groupPassTurn() {
            try {
                const enc = GameState.currentEncounter;
                if (!enc) return;
                
                const actor = getCurrentActor(enc);
                if (!actor) return;
                
                enc.log.push(`‚ñ∂Ô∏è ${actor.name} passou o turno`);
                
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to pass turn', error.stack);
            }
        }

        // ==================== FASE 3: Helper Functions ====================

        function _getGroupEncounter() {
            return GameState.currentEncounter;
        }

        function _getPlayerById(playerId) {
            return GameState.players.find(p => p.id === playerId) || null;
        }

        function _getActiveMonsterOfPlayer(player) {
            return player?.team?.[0] || null;
        }

        function _getEnemyByIndex(enc, idx) {
            return enc?.enemies?.[idx] || null;
        }

        function _clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }

        function _calcDamage(power, atk, def) {
            const A = Number(atk) || 0;
            const D = Number(def) || 0;
            const P = Number(power) || 0;
            const ratio = (A <= 0 && D <= 0) ? 0.5 : (A / (A + D));
            const base = Math.floor(P * ratio);
            return Math.max(1, base);
        }

        function _isAlive(entity) {
            return (Number(entity?.hp) || 0) > 0;
        }

        function _log(enc, msg) {
            enc.log = enc.log || [];
            enc.log.push(msg);
        }

        function _chooseTargetPlayerId(enc) {
            let best = null;
            for (const pid of (enc.participants || [])) {
                const p = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(p);
                if (!mon || !_isAlive(mon)) continue;

                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;
                const pct = hp / hpMax;

                if (!best || pct < best.pct) best = { pid, pct };
            }
            return best ? best.pid : null;
        }

        // ==================== FASE 3.A: Player Attack ====================

        function groupAttack() {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                if (!_isAlive(mon)) {
                    _log(enc, "‚ö†Ô∏è Seu monstrinho est√° desmaiado. N√£o pode atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Aplicar ENE REGEN no in√≠cio do turno do jogador
                applyEneRegen(mon, enc);

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;

                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) {
                    _log(enc, "‚ÑπÔ∏è N√£o h√° inimigos vivos para atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const d20 = rollD20();
                const atk = Number(mon.atk) || 0;
                const def = Number(enemy.def) || 0;

                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (d20 + atk >= def);

                const attackerName = player.name || player.nome || actor.name || "Jogador";
                const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                const enemyName = enemy.name || enemy.nome || "Inimigo";
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit ? 'crit' : alwaysMiss ? 'fail' : 'normal';
                recordD20Roll(enc, attackerName, d20, rollType);

                if (!hit) {
                    _log(enc, `üé≤ ${attackerName} (${monName}) rolou ${d20} e ERROU o ataque em ${enemyName}.`);
                    
                    // Feature 3.8: Flash fail on player
                    setTimeout(() => flashTarget(`grpP_${actor.id}`, 'fail'), 50);
                    
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER b√°sico
                const basicPower = Number(mon.basicPower) || Number(mon.powerBasic) || 10;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `üí• CRIT 20! ${monName} ativou Poder Duplo!`);
                }

                // Calcular vantagem de classe
                const classAdv = GameState.config?.classAdvantages?.[mon.class];
                let damageMult = 1.0;
                if (classAdv?.strong === enemy.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === enemy.class) {
                    damageMult = 0.90;
                }

                const dmg = calcDamage({
                    atk: atk,
                    def: def,
                    power: powerUsed,
                    damageMult: damageMult
                });
                enemy.hp = _clamp((Number(enemy.hp) || 0) - dmg, 0, Number(enemy.hpMax) || 999999);

                _log(enc, `üé≤ ${attackerName} (${monName}) rolou ${d20} e acertou ${enemyName} causando ${dmg} de dano!`);
                
                // Feature 3.8: Visual feedback
                saveToLocalStorage();
                renderEncounter();
                setTimeout(() => {
                    showFloatingText(`grpE_${enemyIndex}`, `-${dmg}`, isCrit ? 'crit' : 'damage');
                    flashTarget(`grpE_${enemyIndex}`, isCrit ? 'crit' : 'hit');
                }, 50);

                if (!_isAlive(enemy)) {
                    _log(enc, `üèÅ ${enemyName} foi derrotado!`);
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to attack', error.stack);
            }
        }

        // ==================== FASE 3.B: Enemy AI ====================

        function processEnemyTurnGroup(enc) {
            try {
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'enemy') return;

                const enemy = _getEnemyByIndex(enc, actor.id);
                if (!enemy || !_isAlive(enemy)) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Escolhe alvo (menor HP%)
                const targetPid = _chooseTargetPlayerId(enc);
                if (!targetPid) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const targetPlayer = _getPlayerById(targetPid);
                const targetMon = _getActiveMonsterOfPlayer(targetPlayer);

                const enemyName = enemy.name || actor.name || "Inimigo";
                const targetName = targetPlayer?.name || targetPlayer?.nome || "Jogador";
                const targetMonName = targetMon?.nickname || targetMon?.name || targetMon?.nome || "Monstrinho";

                const d20 = rollD20();
                const atk = Number(enemy.atk) || 0;
                const def = Number(targetMon?.def) || 0;

                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (d20 + atk >= def);
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit ? 'crit' : alwaysMiss ? 'fail' : 'normal';
                recordD20Roll(enc, enemyName, d20, rollType);

                if (!hit) {
                    _log(enc, `üé≤ ${enemyName} rolou ${d20} e ERROU o ataque em ${targetName} (${targetMonName}).`);
                    
                    // Feature 3.8: Flash fail on enemy
                    const enemyIndex = enc.enemies.indexOf(enemy);
                    setTimeout(() => flashTarget(`grpE_${enemyIndex}`, 'fail'), 50);
                    
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER b√°sico do inimigo
                const basicPower = Number(enemy.basicPower) || Number(enemy.powerBasic) || 10;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `üí• CRIT 20! ${enemyName} ativou Poder Duplo!`);
                }

                // Calcular vantagem de classe
                const classAdv = GameState.config?.classAdvantages?.[enemy.class];
                let damageMult = 1.0;
                if (classAdv?.strong === targetMon?.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === targetMon?.class) {
                    damageMult = 0.90;
                }

                const dmg = calcDamage({
                    atk: atk,
                    def: def,
                    power: powerUsed,
                    damageMult: damageMult
                });
                targetMon.hp = _clamp((Number(targetMon.hp) || 0) - dmg, 0, Number(targetMon.hpMax) || 999999);

                _log(enc, `üé≤ ${enemyName} rolou ${d20} e acertou ${targetName} (${targetMonName}) causando ${dmg} de dano!`);
                
                // Feature 3.8: Visual feedback
                saveToLocalStorage();
                renderEncounter();
                setTimeout(() => {
                    showFloatingText(`grpP_${targetPid}`, `-${dmg}`, isCrit ? 'crit' : 'damage');
                    flashTarget(`grpP_${targetPid}`, isCrit ? 'crit' : 'hit');
                }, 50);

                if (!_isAlive(targetMon)) {
                    _log(enc, `üíÄ ${targetName} (${targetMonName}) foi derrotado!`);
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to process enemy turn', error.stack);
            }
        }

        // ==================== FASE 3.C: Skills and Items ====================

        function groupUseSkill(skillIndex) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon || !_isAlive(mon)) return;

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;
                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) return;

                _log(enc, "‚ÑπÔ∏è (Ajuste) Sistema de habilidades ser√° integrado na Feature 3.3");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use skill', error.stack);
            }
        }

        function groupUseItem(itemId) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                // Reutiliza l√≥gica do 3.1
                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;

                if (hp <= 0) {
                    _log(enc, "‚ö†Ô∏è Monstrinho est√° desmaiado.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (hp >= hpMax) {
                    _log(enc, "‚ÑπÔ∏è HP j√° est√° cheio.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (!itemId || itemId === 'IT_HEAL_01') {
                    itemId = 'IT_HEAL_01';
                }

                const itemCount = Number(player.inventory?.[itemId]) || 0;
                if (itemCount <= 0) {
                    _log(enc, "‚ö†Ô∏è Voc√™ n√£o tem esse item.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Consumir item
                player.inventory[itemId] = Math.max(0, itemCount - 1);

                // Aplicar cura (mesmo do 3.1)
                const healAmount = Math.max(30, Math.floor(hpMax * 0.30));
                const newHp = Math.min(hpMax, hp + healAmount);
                const healed = newHp - hp;
                mon.hp = newHp;

                const playerName = player.name || "Jogador";
                const monName = mon.nickname || mon.name || "Monstrinho";

                _log(enc, `üíö ${playerName} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                _log(enc, `‚ú® ${monName} recuperou ${healed} HP! (${mon.hp}/${hpMax})`);

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use item', error.stack);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FEATURE 3.3 - SISTEMA DE XP E LEVEL UP (com idempot√™ncia)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Garante que um monstro tenha campos de progress√£o (compatibilidade com saves antigos)
         */
        function ensureMonsterProgressFields(mon) {
            if (!mon) return;
            mon.level = Math.max(1, Number(mon.level) || 1);
            mon.xp = Math.max(0, Number(mon.xp) || 0);
            mon.xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
            // Fallback hpMax/maxHp
            if (mon.hpMax == null && mon.maxHp != null) mon.hpMax = mon.maxHp;
            if (mon.hp == null && mon.hpMax != null) mon.hp = mon.hpMax;
        }
        
        /**
         * Calcula XP necess√°rio para pr√≥ximo n√≠vel (curva suave)
         */
        function calcXpNeeded(level) {
            const L = Math.max(1, Number(level) || 1);
            return Math.round(40 + 6 * L + 0.6 * (L * L));
        }
        
        // Alias para compatibilidade
        function calculateXPNeeded(level) {
            return calcXpNeeded(level);
        }
        
        /**
         * Garante que um monstro tenha campos de XP preenchidos
         */
        function ensureXpFields(mon) {
            if (!mon) return;
            if (mon.level == null) mon.level = 1;
            if (mon.xp == null) mon.xp = 0;
            if (mon.xpNeeded == null) mon.xpNeeded = calcXpNeeded(mon.level);
        }
        
        /**
         * Exibe um toast notification tempor√°rio
         */
        function showToast(text) {
            const host = document.getElementById("mmToastHost");
            if (!host) return;

            const el = document.createElement("div");
            el.className = "mm-toast";
            el.textContent = text;

            host.appendChild(el);

            setTimeout(() => {
                el.style.opacity = "0";
                el.style.transform = "translateY(-4px)";
                el.style.transition = "opacity .2s ease, transform .2s ease";
            }, 2600);

            setTimeout(() => el.remove(), 3100);
        }

        /**
         * Inicializa campos de toast para um encounter
         * Garante que cada encounter tenha IDs √∫nicos e cursor de toast resetado
         */
        function initializeEncounterToast(enc) {
            if (!enc) return;
            
            // Garantir ID √∫nico do encounter
            if (!enc.encounterId) {
                enc.encounterId = "enc_" + Date.now() + "_" + Math.random().toString(16).slice(2);
            }
            
            // Inicializar cursor de toast
            enc._toastCursor = 0;
            
            // Opcional: tracking de mensagens j√° vistas (para futuro uso)
            enc._toastSeen = {};
        }
        
        /**
         * Verifica novas entradas no log e exibe toasts para eventos importantes
         * Usa cursor para evitar repetir toasts em re-render
         * Detecta level up e evolu√ß√£o por emoji OU por texto
         */
        function maybeToastFromLog(enc) {
            if (!enc || !Array.isArray(enc.log)) return;

            // Garantir inicializa√ß√£o do cursor (seguran√ßa para encounters antigos)
            if (enc._toastCursor == null) enc._toastCursor = 0;

            const start = Number.isFinite(enc._toastCursor) ? enc._toastCursor : 0;
            for (let i = start; i < enc.log.length; i++) {
                const line = String(enc.log[i] || "");
                
                // Detectar level up: por emoji OU por texto
                const isLevelUp = line.includes("‚ú®") || /subiu para o n√≠vel/i.test(line);
                if (isLevelUp) showToast(line);
                
                // Detectar evolu√ß√£o: por emoji OU por texto
                const isEvo = line.includes("üåü") || /evoluiu para/i.test(line);
                if (isEvo) showToast(line);
            }
            enc._toastCursor = enc.log.length;
        }
        
        /**
         * Calcula XP ganho de uma batalha
         * @param {Object} defeatedEnemy - Inimigo derrotado
         * @param {string} encounterType - Tipo do encontro ('wild', 'group_trainer', 'boss')
         * @returns {number} - XP calculado
         */
        function calculateBattleXP(defeatedEnemy, encounterType) {
            const base = 15;
            const level = Math.max(1, Number(defeatedEnemy?.level) || 1);
            const rarity = defeatedEnemy?.rarity || defeatedEnemy?.raridade || null;
            
            // Multiplicador de raridade (com fallback)
            const rarityMult = Number(GameState.config.rarityXP?.[rarity]) || 1.0;
            
            let xp = Math.floor((base + level * 2) * rarityMult);
            
            // Boss bonus
            if (String(encounterType).toLowerCase() === 'boss') {
                xp = Math.floor(xp * 1.5);
            }
            
            return Math.max(1, xp);
        }
        
        /**
         * D√° XP para um monstro e processa level ups
         * @param {Object} mon - Monstro que receber√° XP
         * @param {number} amount - Quantidade de XP
         * @param {Array} logArr - Array de log (opcional, usa encounter.log se n√£o fornecido)
         */
        function giveXP(mon, amount, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            const xpGain = Math.max(0, Number(amount) || 0);
            if (xpGain <= 0) return;
            
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            mon.xp += xpGain;
            
            // Logar no array fornecido ou no encounter atual
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            if (Array.isArray(log)) {
                log.push(`üß™ ${name} ganhou +${xpGain} XP.`);
            }
            
            // Loop de level ups (pode subir m√∫ltiplos n√≠veis de uma vez)
            while (mon.xp >= mon.xpNeeded) {
                mon.xp -= mon.xpNeeded;
                levelUpMonster(mon, log);
            }
        }
        
        /**
         * Processa um level up para o monstro
         * @param {Object} mon - Monstro que vai subir de n√≠vel
         * @param {Array} logArr - Array de log (opcional)
         */
        function levelUpMonster(mon, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Capturar HP% ANTES do level up para preservar na evolu√ß√£o
            const hpPctBeforeLevelUp = Math.max(0, Number(mon.hp) || 0) / Math.max(1, Number(mon.hpMax) || 1);
            
            mon.level++;
            
            // Aumentar HP Max (f√≥rmula oficial: hpMax * 1.04 + 2)
            const hpMax = Number(mon.hpMax) || Number(mon.maxHp) || 1;
            mon.hpMax = Math.floor(hpMax * 1.04 + 2);
            
            // Curar completamente ao subir de n√≠vel
            mon.hp = mon.hpMax;
            
            // Recalcular stats baseado no novo n√≠vel
            recalculateStatsFromTemplate(mon);
            
            // Pr√≥ximo XP necess√°rio
            mon.xpNeeded = calcXpNeeded(mon.level);
            
            // Log com emoji especial
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            if (Array.isArray(log)) {
                log.push(`‚ú® ${name} subiu para o n√≠vel ${mon.level}!`);
            }
            
            // Verificar e aplicar evolu√ß√£o ap√≥s level up (passa o HP% original)
            maybeEvolveAfterLevelUp(mon, log, hpPctBeforeLevelUp);
            
            // Verificar e aplicar upgrade de skills (Feature 3.6)
            maybeUpgradeSkillsModelB(mon, log);
        }
        
        // Alias para compatibilidade
        function levelUp(mon) {
            return levelUpMonster(mon, GameState.currentEncounter?.log);
        }
        
        /**
         * Recalcula stats do monstro baseado no n√≠vel e raridade (com fallbacks)
         * @param {Object} mon - Monstro para recalcular
         */
        function recalculateStatsFromTemplate(mon) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Buscar template base do cat√°logo (com m√∫ltiplos fallbacks)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            if (!template) return; // N√£o quebra se n√£o encontrar
            
            // Obter raridade (com fallback)
            const rarity = template.rarity || template.raridade || mon.rarity || mon.raridade;
            
            // Multiplicadores
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (Math.max(1, mon.level) - 1) * 0.1;
            
            // Base stats (com m√∫ltiplos fallbacks)
            const baseAtk = Number(template.baseAtk ?? template.atkBase ?? template.atk) || 0;
            const baseDef = Number(template.baseDef ?? template.defBase ?? template.def) || 0;
            const baseSpd = Number(template.baseSpd ?? template.spdBase ?? template.spd) || 0;
            
            // Recalcular stats (HP √© tratado separadamente em levelUpMonster)
            mon.atk = Math.floor(baseAtk * levelMult * rarityMult);
            mon.def = Math.floor(baseDef * levelMult * rarityMult);
            mon.spd = Math.floor(baseSpd * levelMult * rarityMult);
        }
        
        // Alias para compatibilidade
        function recalculateStats(mon) {
            return recalculateStatsFromTemplate(mon);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FEATURE 3.4 ‚Äî EVOLUTION (MVP)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Busca template base de um monstro no cat√°logo
         * @param {Object} mon - Monstro
         * @returns {Object|null} - Template encontrado ou null
         */
        function getMonsterTemplate(mon) {
            if (!mon) return null;
            
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            return template || null;
        }
        
        /**
         * Extrai dados de evolu√ß√£o de um template (com fallbacks para m√∫ltiplos nomes)
         * @param {Object} template - Template do monstro
         * @returns {Object|null} - { toId, atLv } ou null se n√£o evoluir
         */
        function getEvolutionData(template) {
            if (!template) return null;

            const evolvesTo = template.evolvesTo ?? template.evolve_to ?? template.evoluiPara ?? template.evolutionTo ?? null;
            const evolvesAt = template.evolvesAt ?? template.evolve_at ?? template.evoluiNoNivel ?? template.evolutionAt ?? null;

            const toId = evolvesTo != null ? String(evolvesTo) : "";
            const atLv = evolvesAt != null ? Number(evolvesAt) : NaN;

            if (!toId || !Number.isFinite(atLv) || atLv <= 0) return null;
            return { toId, atLv };
        }

        /**
         * Busca template do monstro evolu√≠do
         * @param {Object} mon - Monstro atual
         * @returns {Object|null} - { nextTemplate, evolvesAt } ou null
         */
        function getEvolutionTargetTemplate(mon) {
            const currentTemplate = getMonsterTemplate(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return null;

            // Busca o template alvo no cat√°logo (usa MONSTER_CATALOG como fonte prim√°ria)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const nextTemplate = catalog.find(m => String(m.id) === String(evo.toId));
            
            if (nextTemplate) return { nextTemplate, evolvesAt: evo.atLv };
            return null;
        }

        /**
         * Aplica evolu√ß√£o no monstro (atualiza ID, nome, stats, preserva HP%)
         * @param {Object} mon - Monstro que vai evoluir
         * @param {Object} nextTemplate - Template da evolu√ß√£o
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional, se n√£o fornecido usa HP% atual)
         */
        function applyEvolution(mon, nextTemplate, logArr, hpPctOverride) {
            if (!mon || !nextTemplate) return;

            // preserva % de HP (usa override se fornecido, sen√£o usa o atual)
            let hpPct;
            if (hpPctOverride != null && Number.isFinite(hpPctOverride)) {
                hpPct = hpPctOverride;
            } else {
                const oldHp = Math.max(0, Number(mon.hp) || 0);
                const oldHpMax = Math.max(1, Number(mon.hpMax) || 1);
                hpPct = oldHp / oldHpMax;
            }

            const oldName = mon.nickname || mon.name || mon.nome || "Monstrinho";
            const newName = nextTemplate.name || nextTemplate.nome || oldName;

            // Atualiza o ID base do monstro (tenta manter compatibilidade)
            if (mon.monsterId != null) mon.monsterId = String(nextTemplate.id);
            else if (mon.templateId != null) mon.templateId = String(nextTemplate.id);
            else mon.monsterId = String(nextTemplate.id);

            // Atualiza campos visuais e de gameplay se existirem no template
            if (nextTemplate.name || nextTemplate.nome) mon.name = (nextTemplate.name || nextTemplate.nome);
            if (nextTemplate.emoji) mon.emoji = nextTemplate.emoji;
            if (nextTemplate.class || nextTemplate.classe) mon.class = (nextTemplate.class || nextTemplate.classe);
            if (nextTemplate.rarity || nextTemplate.raridade) mon.rarity = (nextTemplate.rarity || nextTemplate.raridade);

            // Recalcula stats com a nova forma
            recalculateStatsFromTemplate(mon);
            
            // Recalcula hpMax baseado no novo baseHp do template
            const baseHp = Number(nextTemplate.baseHp ?? nextTemplate.hpBase ?? nextTemplate.hp) || mon.hpMax || 1;
            const level = Math.max(1, mon.level);
            const rarity = nextTemplate.rarity || nextTemplate.raridade || mon.rarity;
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (level - 1) * 0.1;
            
            // Nova hpMax baseada no template da evolu√ß√£o
            mon.hpMax = Math.floor(baseHp * levelMult * rarityMult);

            // Ajuste final de HP mantendo percentual
            const newHpMax = Math.max(1, Number(mon.hpMax) || 1);
            mon.hp = Math.max(1, Math.floor(newHpMax * hpPct)); // m√≠nimo 1 para n√£o "morrer" ao evoluir

            if (Array.isArray(logArr)) {
                logArr.push(`üåü ${oldName} evoluiu para ${newName}!`);
            }
            
            // Verificar e aplicar upgrade de skills ap√≥s evolu√ß√£o (Feature 3.6)
            maybeUpgradeSkillsModelB(mon, logArr);
        }

        /**
         * Verifica e aplica evolu√ß√£o se o monstro atingiu o n√≠vel necess√°rio
         * @param {Object} mon - Monstro a verificar
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional)
         * @returns {boolean} - true se evoluiu, false caso contr√°rio
         */
        function checkEvolution(mon, logArr, hpPctOverride) {
            if (!mon) return false;
            ensureMonsterProgressFields(mon);

            const currentTemplate = getMonsterTemplate(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return false;

            if (mon.level < evo.atLv) return false;

            const target = getEvolutionTargetTemplate(mon);
            if (!target?.nextTemplate) return false;

            applyEvolution(mon, target.nextTemplate, logArr, hpPctOverride);
            return true;
        }

        /**
         * Tenta evoluir monstro ap√≥s level up (no m√°ximo 1 evolu√ß√£o por levelUp no MVP)
         * @param {Object} mon - Monstro que acabou de subir de n√≠vel
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% de antes do level up para preservar
         */
        function maybeEvolveAfterLevelUp(mon, logArr, hpPctOverride) {
            checkEvolution(mon, logArr, hpPctOverride);
        }
        
        // =============================
        // FEATURE 3.6 ‚Äî SKILLS (MODEL B) AUTO UPGRADE I->II->III
        // =============================

        /**
         * Determina o est√°gio do monstro baseado no n√≠vel
         * @param {number} level - N√≠vel do monstro
         * @returns {string} - Est√°gio (S0, S1, S2, S3)
         */
        function getMonsterStage(level) {
            const lv = Math.max(1, Number(level) || 1);
            if (lv <= 9) return "S0";
            if (lv <= 24) return "S1";
            if (lv <= 44) return "S2";
            return "S3";
        }

        /**
         * Determina o tier de skill desejado baseado no est√°gio
         * @param {string} stage - Est√°gio do monstro (S0, S1, S2, S3)
         * @returns {number} - Tier desejado (1, 2, ou 3)
         */
        function getDesiredSkillTier(stage) {
            // MVP mapping: S0/S1 => I, S2 => II, S3 => III
            if (stage === "S2") return 2;
            if (stage === "S3") return 3;
            return 1;
        }

        /**
         * Obt√©m array de skills do monstro (compat√≠vel com m√∫ltiplos formatos)
         * @param {Object} mon - Monstro
         * @returns {Array} - Array de skill IDs
         */
        function getSkillsArray(mon) {
            if (!mon) return [];
            // formatos comuns: mon.skills (array) ou mon.skillIds (array)
            if (Array.isArray(mon.skills)) return mon.skills.slice();
            if (Array.isArray(mon.skillIds)) return mon.skillIds.slice();
            return [];
        }

        /**
         * Define array de skills no monstro
         * @param {Object} mon - Monstro
         * @param {Array} arr - Array de skill IDs
         */
        function setSkillsArray(mon, arr) {
            if (!mon) return;
            // preferir mon.skills se j√° existe, sen√£o criar
            if (Array.isArray(mon.skills) || mon.skills == null) mon.skills = arr.slice();
            else mon.skillIds = arr.slice();
        }

        /**
         * Obt√©m cat√°logo de skills de m√∫ltiplas fontes poss√≠veis
         * @returns {Array} - Cat√°logo de skills
         */
        function getSkillCatalog() {
            const candidates = [];
            
            // Verificar SKILLS_CATALOG definido no escopo local
            if (typeof SKILLS_CATALOG !== 'undefined' && Array.isArray(SKILLS_CATALOG)) {
                candidates.push(SKILLS_CATALOG);
            }
            
            if (window.DB) {
                if (Array.isArray(DB.SKILLS)) candidates.push(DB.SKILLS);
                if (Array.isArray(DB.HABILIDADES)) candidates.push(DB.HABILIDADES);
                if (Array.isArray(DB.ABILITIES)) candidates.push(DB.ABILITIES);
            }
            if (Array.isArray(window.SKILLS)) candidates.push(window.SKILLS);
            if (Array.isArray(window.SKILLS_CATALOG)) candidates.push(window.SKILLS_CATALOG);
            if (Array.isArray(window.ABILITIES)) candidates.push(window.ABILITIES);
            return candidates.find(arr => Array.isArray(arr) && arr.length) || [];
        }

        /**
         * Busca skill por ID no cat√°logo
         * @param {string} id - ID da skill
         * @returns {Object|null} - Objeto da skill ou null
         */
        function getSkillById(id) {
            const sid = String(id || "");
            if (!sid) return null;
            const cat = getSkillCatalog();
            return cat.find(s => String(s.id) === sid) || null;
        }

        /**
         * Extrai a "fam√≠lia" de uma skill (remove sufixos de tier)
         * @param {Object|string} skillOrId - Skill object ou ID
         * @returns {string} - Chave da fam√≠lia
         */
        function getSkillFamilyKey(skillOrId) {
            const skill = typeof skillOrId === "object" ? skillOrId : getSkillById(skillOrId);
            const id = String(skill?.id ?? skillOrId ?? "");
            const name = String(skill?.name ?? skill?.nome ?? "");

            // 1) por ID (mais confi√°vel)
            if (id) {
                // exemplos: FIREBALL_I, FIREBALL_II, FIREBALL_III
                let base = id
                    .replace(/(_I|_II|_III)$/i, "")
                    .replace(/(-I|-II|-III)$/i, "");
                if (base !== id) return base;
            }

            // 2) por nome
            if (name) {
                const baseName = name.replace(/\s+(I|II|III)$/i, "").trim();
                if (baseName && baseName !== name) return baseName.toLowerCase();
            }

            // 3) fallback: o pr√≥prio id
            return id || name.toLowerCase() || "";
        }

        /**
         * Busca variante de skill pela fam√≠lia e tier desejado
         * @param {string} familyKey - Chave da fam√≠lia da skill
         * @param {number} tier - Tier desejado (1, 2, ou 3)
         * @returns {Object|null} - Skill encontrada ou null
         */
        function findSkillVariantByFamily(familyKey, tier) {
            const cat = getSkillCatalog();
            if (!familyKey || !cat.length) return null;

            const roman = tier === 3 ? "III" : tier === 2 ? "II" : "I";
            const fk = String(familyKey);

            // tentar padr√µes de ID
            const idCandidates = [
                `${fk}_${roman}`, `${fk}-${roman}`,
                `${fk.toUpperCase()}_${roman}`, `${fk.toUpperCase()}-${roman}`,
            ];

            for (const cand of idCandidates) {
                const hit = cat.find(s => String(s.id) === cand);
                if (hit) return hit;
            }

            // tentar por fam√≠lia via getSkillFamilyKey + nome com sufixo
            const romanNameSuffix = " " + roman;
            const fkLower = fk.toLowerCase();

            // primeira passada: fam√≠lia igual + nome termina com roman
            for (const s of cat) {
                const fam = getSkillFamilyKey(s);
                const nm = String(s.name ?? s.nome ?? "");
                if (fam && String(fam).toLowerCase() === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            // segunda passada: nome base igual + roman
            for (const s of cat) {
                const nm = String(s.name ?? s.nome ?? "");
                const base = nm.replace(/\s+(I|II|III)$/i, "").trim().toLowerCase();
                if (base && base === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            return null;
        }
        
        // =============================
        // FEATURE 3.8 ‚Äî BATTLE POLISH (VISUAL FEEDBACK)
        // =============================
        
        /**
         * Mostra texto flutuante (dano/cura) sobre um elemento
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} text - Texto a exibir (ex: "-12", "+8")
         * @param {string} kind - Tipo: "damage", "heal", "crit"
         */
        function showFloatingText(target, text, kind = 'damage') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const floater = document.createElement('div');
                floater.className = `floating-text ${kind}`;
                floater.textContent = text;
                
                // Posicionar no centro do elemento alvo
                const rect = element.getBoundingClientRect();
                floater.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floater.style.top = `${rect.top + rect.height / 2 - 20}px`;
                
                document.body.appendChild(floater);
                
                // Remover ap√≥s anima√ß√£o
                setTimeout(() => floater.remove(), 1000);
            } catch (error) {
                console.error('showFloatingText error:', error);
            }
        }
        
        /**
         * Aplica efeito de flash no alvo
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} type - Tipo: "crit", "fail", "hit"
         */
        function flashTarget(target, type = 'hit') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const className = `flash-${type}`;
                element.classList.add(className);
                
                setTimeout(() => element.classList.remove(className), 400);
            } catch (error) {
                console.error('flashTarget error:', error);
            }
        }
        
        /**
         * Armazena o √∫ltimo roll de d20 no encounter
         * @param {Object} enc - Encounter
         * @param {string} name - Nome de quem rolou
         * @param {number} roll - Valor do d20
         * @param {string} type - "crit", "fail", ou "normal"
         */
        function recordD20Roll(enc, name, roll, type = 'normal') {
            if (!enc) return;
            enc.lastRoll = { name, roll, type };
        }

        /**
         * Tenta fazer upgrade autom√°tico das skills quando monstro muda de est√°gio
         * @param {Object} mon - Monstro
         * @param {Array} logArr - Array de log (opcional)
         */
        function maybeUpgradeSkillsModelB(mon, logArr) {
            if (!mon) return;

            const stageNow = getMonsterStage(mon.level);
            const tierNow = getDesiredSkillTier(stageNow);

            // dedupe: s√≥ roda quando est√°gio muda
            if (mon._skillStage === stageNow) return;

            const skills = getSkillsArray(mon);
            if (!skills.length) {
                // MVP: se n√£o tem skills, n√£o inventa. Apenas marca est√°gio para n√£o spammar.
                mon._skillStage = stageNow;
                return;
            }

            let changed = false;
            const newSkills = skills.map(oldId => {
                const oldSkill = getSkillById(oldId);
                const family = getSkillFamilyKey(oldSkill || oldId);
                if (!family) return oldId;

                const variant = findSkillVariantByFamily(family, tierNow);
                if (!variant) return oldId;

                const newId = String(variant.id);
                if (newId && newId !== String(oldId)) {
                    changed = true;

                    const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                    const newName = variant.name || variant.nome || newId;

                    if (Array.isArray(logArr)) {
                        logArr.push(`üéì ${monName} aprendeu ${newName}!`);
                    }
                    return newId;
                }
                return oldId;
            });

            if (changed) setSkillsArray(mon, newSkills);

            mon._skillStage = stageNow;
        }
        
        // =============================
        // FEATURE 3.7 ‚Äî SKILLS HUD UI
        // =============================
        
        /**
         * Formata o label de um bot√£o de skill mostrando nome e custo ENE
         * @param {Object} skill - Skill do cat√°logo
         * @param {Object} mon - Monstro (para contexto futuro se necess√°rio)
         * @returns {string} - Label formatado
         */
        function formatSkillButtonLabel(skill, mon) {
            if (!skill) return "Habilidade";
            
            const name = skill.name || skill.nome || String(skill.id);
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const power = Number(skill.power ?? skill.POWER ?? skill.pwr ?? 0) || 0;
            
            // emoji opcional: se j√° tiver no dataset, usa
            const icon = skill.icon || "";
            
            // MVP: nome + ENE (sem poluir)
            const parts = [];
            if (icon) parts.push(icon);
            parts.push(name);
            if (cost > 0) parts.push(`(ENE ${cost})`);
            
            return parts.join(" ");
        }
        
        /**
         * Verifica se o monstro tem ENE suficiente para usar a skill
         * @param {Object} skill - Skill do cat√°logo
         * @param {Object} mon - Monstro
         * @returns {boolean} - true se pode usar
         */
        function canUseSkillNow(skill, mon) {
            if (!skill || !mon) return false;
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const ene = Number(mon.ene ?? mon.ENE ?? 0) || 0;
            return ene >= cost;
        }
        
        /**
         * Distribui XP para todos participantes vivos de uma batalha em grupo
         * @param {Object} enc - Encounter de grupo
         */
        function distributeGroupXP(enc) {
            if (!enc || !enc.rewards || !enc.rewards.xp) return;
            
            const xp = enc.rewards.xp;
            
            enc.participants.forEach(pid => {
                const player = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(player);
                
                // S√≥ ganha XP se estiver vivo
                if (!mon || mon.hp <= 0) return;
                
                giveXP(mon, xp);
            });
        }
        
        /**
         * Distribui XP para o jogador de uma batalha wild (1v1)
         * @param {Object} encounter - Encounter wild
         */
        function distributeWildXP(encounter) {
            if (!encounter || !encounter.rewards || !encounter.rewards.xp) return;
            
            const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
            const mon = player?.team?.[0];
            
            // S√≥ ganha XP se estiver vivo
            if (!mon || mon.hp <= 0) return;
            
            giveXP(mon, encounter.rewards.xp);
        }
        
        /**
         * Distribui recompensas de vit√≥ria de forma idempotente (XP + recompensas futuras)
         * Previne duplica√ß√£o via flag rewardsGranted
         * @param {Object} enc - Encounter (wild ou group)
         */
        function handleVictoryRewards(enc) {
            if (!enc || enc.rewardsGranted) return;
            enc.rewardsGranted = true;
            
            enc.log = enc.log || [];
            
            // Determinar inimigo derrotado principal (primeiro inimigo)
            const defeated = (enc.enemies && enc.enemies[0]) ? enc.enemies[0] : enc.wildMonster;
            if (!defeated) {
                enc.log.push("‚ÑπÔ∏è (XP) N√£o foi poss√≠vel identificar inimigo derrotado.");
                return;
            }
            
            // Calcular XP
            const xp = calculateBattleXP(defeated, enc.type);
            enc.rewards = enc.rewards || {};
            enc.rewards.xp = xp;
            enc.log.push(`üèÖ Recompensa: ${xp} XP.`);
            
            // Distribuir XP baseado no tipo de batalha
            const isGroup = String(enc.type || '').includes("group") || 
                           String(enc.type || '').toLowerCase() === "boss" ||
                           enc.participants?.length > 0;
            
            if (isGroup) {
                // Grupo: cada participante vivo recebe XP completo
                for (const pid of (enc.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    const mon = p?.team?.[0];
                    if (!mon || (Number(mon.hp) || 0) <= 0) continue;
                    giveXP(mon, xp, enc.log);
                }
            } else {
                // 1v1: jogador atual (ou primeiro se n√£o especificado)
                let player = null;
                if (enc.selectedPlayerId || enc.currentPlayerId) {
                    player = GameState.players.find(p => 
                        p.id === (enc.selectedPlayerId || enc.currentPlayerId)
                    );
                }
                if (!player) player = GameState.players?.[0] || null;
                
                const mon = player?.team?.[0];
                if (mon && (Number(mon.hp) || 0) > 0) {
                    giveXP(mon, xp, enc.log);
                }
            }
        }
        
        function renderGroupEncounter(panel, encounter) {
            try {
                if (!encounter) return;
                
                const actor = getCurrentActor(encounter);
                const isPlayerTurn = actor && actor.side === 'player';
                
                let html = '<div class="encounter-panel">';
                html += '<h3>‚öîÔ∏è Batalha em Grupo</h3>';
                
                // Last d20 roll badge
                if (encounter.lastRoll) {
                    const lr = encounter.lastRoll;
                    const badgeClass = lr.type === 'crit' ? 'crit' : lr.type === 'fail' ? 'fail' : '';
                    const emoji = lr.type === 'crit' ? 'üåü' : lr.type === 'fail' ? 'üí•' : 'üé≤';
                    html += `<div class="d20-badge ${badgeClass}">${emoji} ${lr.name}: ${lr.roll} ${lr.type === 'crit' ? '(CRIT!)' : lr.type === 'fail' ? '(FALHA!)' : ''}</div>`;
                }
                
                // Indicador de turno atual
                if (actor) {
                    const sideColor = actor.side === 'player' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${sideColor}; color: white; padding: 10px; margin: 10px 0; border-radius: 4px;">`;
                    html += `<strong>‚è∫Ô∏è Turno: ${actor.name}</strong> (${actor.side === 'player' ? 'Jogador' : 'Inimigo'})`;
                    html += `</div>`;
                }
                
                // Participantes (jogadores)
                html += '<div style="margin: 15px 0;">';
                html += '<h4>üë• Participantes:</h4>';
                for (const pid of (encounter.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    if (!p) continue;
                    
                    const mon = p.team?.[0];
                    if (!mon) continue;
                    
                    // Garantir campos de XP
                    ensureXpFields(mon);
                    
                    const hp = Number(mon.hp) || 0;
                    const hpMax = Number(mon.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    
                    const xp = Math.max(0, Number(mon.xp) || 0);
                    const xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
                    const xpPct = Math.max(0, Math.min(100, Math.floor((xp / xpNeeded) * 100)));
                    
                    const isCurrent = actor && actor.side === 'player' && actor.id === pid;
                    
                    const border = isCurrent ? '3px solid #4CAF50' : '1px solid #ddd';
                    html += `<div id="grpP_${pid}" style="background: #f5f5f5; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border}; position: relative;">`;
                    html += `<strong>${p.name || p.nome}</strong> (${p.class})`;
                    html += `<br>${mon.name || mon.nome} - Nv ${mon.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `<div class="progress-bar" style="margin-top:6px;">`;
                    html += `<div class="progress-fill xp" style="width:${xpPct}%"></div>`;
                    html += `</div>`;
                    html += `<div class="small" style="margin-top:4px;">XP: ${xp}/${xpNeeded} (${xpPct}%)</div>`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // Inimigos
                html += '<div style="margin: 15px 0;">';
                html += '<h4>üëπ Inimigos:</h4>';
                for (let i = 0; i < (encounter.enemies || []).length; i++) {
                    const e = encounter.enemies[i];
                    if (!e) continue;
                    
                    const hp = Number(e.hp) || 0;
                    const hpMax = Number(e.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    const isCurrent = actor && actor.side === 'enemy' && actor.id === i;
                    
                    const border = isCurrent ? '3px solid #f44336' : '1px solid #ddd';
                    html += `<div id="grpE_${i}" style="background: #ffebee; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border}; position: relative;">`;
                    html += `<strong>${e.name || e.nome}</strong> - Nv ${e.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `<br>SPD: ${e.spd} | ATK: ${e.atk} | DEF: ${e.def}`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // A√ß√µes (apenas para turno do jogador)
                if (isPlayerTurn && !encounter.finished) {
                    html += '<div style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 4px;">';
                    html += '<h4>A√ß√µes:</h4>';
                    html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">';
                    html += '<button class="btn btn-danger" onclick="groupAttack()">‚öîÔ∏è Atacar</button>';
                    html += '<button class="btn btn-primary" onclick="groupPassTurn()">‚è≠Ô∏è Passar</button>';
                    html += '</div>';
                    
                    // Feature 3.7: Skills buttons for current player
                    if (actor && actor.side === 'player') {
                        const player = GameState.players.find(p => p.id === actor.id);
                        const mon = player?.team?.[0];
                        if (mon) {
                            const skillIds = getSkillsArray(mon);
                            if (skillIds && skillIds.length > 0) {
                                html += '<div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 8px;">';
                                html += '<strong style="font-size: 16px;">‚ú® Habilidades</strong>';
                                html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">';
                                
                                skillIds.forEach((skillId, idx) => {
                                    const skill = getSkillById(skillId);
                                    if (!skill) return;
                                    
                                    const label = formatSkillButtonLabel(skill, mon);
                                    const canUse = canUseSkillNow(skill, mon) && mon.hp > 0;
                                    const tooltip = canUse ? (skill.desc || skill.descricao || '') : 'Sem ENE';
                                    
                                    html += `
                                    <button class="btn btn-info" 
                                            onclick="groupUseSkill(${idx})" 
                                            ${!canUse ? 'disabled style="opacity: 0.5;"' : ''}
                                            title="${tooltip}">
                                        ${label}
                                    </button>
                                    `;
                                });
                                
                                html += '</div>';
                                html += '</div>';
                            }
                        }
                    }
                    
                    html += '</div>';
                }
                
                // Mensagem de fim com recompensas
                if (encounter.finished) {
                    const resultColor = encounter.result === 'victory' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${resultColor}; color: white; padding: 15px; margin: 15px 0; border-radius: 4px;">`;
                    html += `<h3>${encounter.result === 'victory' ? 'üèÅ VIT√ìRIA!' : 'üíÄ DERROTA'}</h3>`;
                    
                    // Recompensas na vit√≥ria
                    if (encounter.result === 'victory') {
                        html += '<div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.2); border-radius: 4px;">';
                        html += '<strong>üí∞ Recompensas:</strong><br>';
                        
                        // Dinheiro dividido
                        const totalCoins = Math.floor(Math.random() * 31) + 30; // 30-60
                        const coinsPerPlayer = Math.floor(totalCoins / encounter.participants.length);
                        
                        for (const pid of encounter.participants) {
                            const p = GameState.players.find(pl => pl.id === pid);
                            if (p) {
                                p.coins = (p.coins || 0) + coinsPerPlayer;
                                html += `${p.name}: +${coinsPerPlayer} moedas<br>`;
                            }
                        }
                        
                        html += '<br><em>‚ÑπÔ∏è XP ser√° implementado na Feature 3.3</em>';
                        html += '</div>';
                        saveToLocalStorage();
                    }
                    
                    html += `</div>`;
                    html += '<button class="btn btn-secondary" onclick="GameState.currentEncounter = null; saveToLocalStorage(); renderEncounter();">Fechar</button>';
                }
                
                // Log de combate
                html += '<div style="margin-top: 20px;">';
                html += '<h4>üìú Log de Combate:</h4>';
                html += '<div style="background: #f9f9f9; padding: 10px; border-radius: 4px; max-height: 300px; overflow-y: auto;">';
                const logs = encounter.log || [];
                for (let i = Math.max(0, logs.length - 20); i < logs.length; i++) {
                    html += `<div>${logs[i]}</div>`;
                }
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                panel.innerHTML = html;
                
                // Exibir toasts para eventos importantes (level up, evolu√ß√£o)
                maybeToastFromLog(encounter);
            } catch (error) {
                showError('Failed to render group encounter', error.stack);
            }
        }

        function renderEncounter() {
            try {
                const panel = document.getElementById('encounterPanel');
                if (!panel) return;
                
                const encounter = GameState.currentEncounter;
                
                if (!encounter || !encounter.active) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                if (encounter.type === 'wild') {
                    renderWildEncounter(panel, encounter);
                } else if (encounter.type === 'group_trainer' || encounter.type === 'boss') {
                    renderGroupEncounter(panel, encounter);
                } else {
                    panel.innerHTML = '<div class="encounter-panel"><h3>Encounter type not yet implemented</h3></div>';
                }
            } catch (error) {
                showError('Failed to render encounter', error.stack);
            }
        }

        function renderWildEncounter(panel, encounter) {
            try {
                const monster = encounter.wildMonster;
                if (!monster) return;
                
                // Buscar jogador selecionado
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                const playerMonster = player?.team?.[0];
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const canCapture = hpPercent <= baseThreshold;
                
                const html = `
                    <div class="encounter-panel">
                        <h3>Wild ${monster.emoji} ${monster.name} appeared!</h3>
                        ${encounter.lastRoll ? (() => {
                            const lr = encounter.lastRoll;
                            const badgeClass = lr.type === 'crit' ? 'crit' : lr.type === 'fail' ? 'fail' : '';
                            const emoji = lr.type === 'crit' ? 'üåü' : lr.type === 'fail' ? 'üí•' : 'üé≤';
                            return `<div class="d20-badge ${badgeClass}">${emoji} ${lr.name}: ${lr.roll} ${lr.type === 'crit' ? '(CRIT!)' : lr.type === 'fail' ? '(FALHA!)' : ''}</div>`;
                        })() : ''}
                        ${player ? `<p><strong>Jogador:</strong> ${player.name} (${player.class})</p>` : ''}
                        ${playerMonster ? (() => {
                            const xpCurrent = playerMonster.xp || 0;
                            const xpNeeded = playerMonster.xpNeeded || calcXpNeeded(playerMonster.level);
                            const xpPercent = Math.max(0, Math.min(100, (xpCurrent / xpNeeded) * 100));
                            
                            return `
                        <div id="wildPlayerBox" style="margin: 10px 0; padding: 10px; background: #e8f5e9; border-radius: 8px; position: relative;">
                            <p><strong>Seu Monstrinho:</strong> ${playerMonster.emoji} ${playerMonster.name} (Nv ${playerMonster.level})</p>
                            <div><strong>HP:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                            <div><strong>‚ö° ENE:</strong> ${playerMonster.ene || 0}/${playerMonster.eneMax || 0}</div>
                            <div class="progress-bar" style="height: 15px; margin-top: 5px;">
                                <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                            </div>
                            <small><strong>XP:</strong> ${xpCurrent}/${xpNeeded} (${Math.floor(xpPercent)}%)</small>
                        </div>
                        `;
                        })() : ''}
                        
                        <div id="wildEnemyBox" class="monster-card ${monster.class}" style="display: inline-block; margin: 20px; position: relative;">
                            <div style="font-size: 48px;">${monster.emoji}</div>
                            <strong>${monster.name}</strong>
                            <div class="badge badge-${monster.rarity}">${monster.rarity}</div>
                            <div><strong>Classe:</strong> ${monster.class}</div>
                            <div><strong>Level:</strong> ${monster.level}</div>
                            <div style="margin-top: 8px;">
                                <div><strong>ATK:</strong> ${monster.atk} | <strong>DEF:</strong> ${monster.def}</div>
                                <div><strong>PODER:</strong> ${monster.poder}</div>
                                <div><strong>‚ö° ENE:</strong> ${monster.ene || 0}/${monster.eneMax || 0}</div>
                            </div>
                            <div class="progress-bar" style="margin-top: 10px;">
                                <div class="progress-fill hp" style="width: ${(monster.hp / monster.hpMax) * 100}%">
                                    ${monster.hp}/${monster.hpMax} HP (${Math.floor(hpPercent * 100)}%)
                                </div>
                            </div>
                            ${canCapture ? 
                                '<div style="color: green; margin-top: 5px;">‚úÖ HP baixo! Pode tentar captura!</div>' : 
                                `<div style="color: orange; margin-top: 5px;">‚ö†Ô∏è Abaixe HP para ${Math.floor(baseThreshold * 100)}% para capturar</div>`
                            }
                        </div>
                        
                        <h4>Choose Action:</h4>
                        <div class="flex-center" style="flex-direction: column;">
                            <div style="margin: 10px 0;">
                                <label style="font-weight: bold; font-size: 18px;">üé≤ Enter your d20 roll:</label>
                                <input type="number" id="diceRoll" min="1" max="20" placeholder="1-20" 
                                       style="width: 120px; text-align: center; font-size: 24px; font-weight: bold; height: 60px; margin: 10px;">
                            </div>
                            
                            ${player ? (() => {
                                const comum = player.inventory?.['CLASTERORB_COMUM'] || 0;
                                const incomum = player.inventory?.['CLASTERORB_INCOMUM'] || 0;
                                const rara = player.inventory?.['CLASTERORB_RARA'] || 0;
                                const hasAnyOrb = comum > 0 || incomum > 0 || rara > 0;
                                
                                return `
                                <div style="margin: 15px 0; background: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #1976d2;">
                                    <strong style="font-size: 16px;">üéØ Sistema de Captura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>HP% Selvagem:</strong> ${Math.floor(hpPercent * 100)}%</div>
                                        <div><strong>Base Threshold (${monster.rarity}):</strong> ${Math.floor(baseThreshold * 100)}%</div>
                                        <div><strong>B√¥nus HP Baixo (‚â§25%):</strong> ${hpPercent <= 0.25 ? '+10%' : '0%'}</div>
                                    </div>
                                    
                                    ${hasAnyOrb ? `
                                    <div style="margin-top: 10px;">
                                        <label style="font-weight: bold;">Escolha sua ClasterOrb:</label>
                                        <select id="captureOrbSelect" onchange="updateCaptureThreshold()" style="width: 100%; padding: 8px; margin: 5px 0; font-size: 14px;">
                                            ${comum > 0 ? `<option value="CLASTERORB_COMUM">‚ö™ Comum (${comum}x) - +0% bonus</option>` : ''}
                                            ${incomum > 0 ? `<option value="CLASTERORB_INCOMUM">üîµ Incomum (${incomum}x) - +5% bonus</option>` : ''}
                                            ${rara > 0 ? `<option value="CLASTERORB_RARA">üü£ Rara (${rara}x) - +10% bonus</option>` : ''}
                                        </select>
                                    </div>
                                    <div id="captureThresholdDisplay" style="margin-top: 10px; padding: 10px; background: #fff; border-radius: 5px;">
                                        <strong>Threshold Final:</strong> <span id="finalThresholdValue">Calculando...</span>
                                    </div>
                                    ` : `
                                    <div style="margin-top: 10px; padding: 10px; background: #ffebee; color: #c62828; border-radius: 5px;">
                                        <strong>‚ùå Sem ClasterOrbs!</strong><br>
                                        Voc√™ n√£o tem orbes de captura dispon√≠veis.
                                    </div>
                                    `}
                                    
                                    <div style="margin-top: 10px;">
                                        <strong>üì¶ Invent√°rio:</strong> 
                                        ‚ö™ ${comum} | üîµ ${incomum} | üü£ ${rara} | 
                                        üíö Cura: ${player.inventory?.['IT_HEAL_01'] || 0}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                            
                            <div class="flex-center">
                                ${player && (player.inventory?.['CLASTERORB_COMUM'] > 0 || player.inventory?.['CLASTERORB_INCOMUM'] > 0 || player.inventory?.['CLASTERORB_RARA'] > 0) ? 
                                    `<button class="btn btn-success btn-large" onclick="attemptCapture()">üéØ Tentar Capturar</button>` :
                                    `<button class="btn btn-success btn-large" disabled style="opacity: 0.5;">üéØ Sem Orbes</button>`
                                }
                                <button class="btn btn-danger btn-large" onclick="attackWild()">‚öîÔ∏è Attack</button>
                                <button class="btn btn-warning btn-large" onclick="fleeEncounter()">üèÉ Flee</button>
                            </div>
                            
                            ${playerMonster && player ? (() => {
                                const healItems = player.inventory?.['IT_HEAL_01'] || 0;
                                const canUseItem = healItems > 0 && playerMonster.hp > 0 && playerMonster.hp < playerMonster.hpMax;
                                
                                return `
                                <div style="margin: 15px 0; padding: 15px; background: #e8f5e9; border-radius: 8px; border: 2px solid #4caf50;">
                                    <strong style="font-size: 16px;">üíö Usar Item de Cura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>Petisco de Cura dispon√≠vel:</strong> ${healItems}x</div>
                                        <div><strong>HP atual:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                                        ${!canUseItem && healItems === 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">‚ùå Sem itens de cura dispon√≠veis</div>` : 
                                            !canUseItem && playerMonster.hp <= 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">‚ùå Monstrinho desmaiado, n√£o pode usar item</div>` :
                                            !canUseItem && playerMonster.hp >= playerMonster.hpMax ?
                                            `<div style="color: #f57c00; margin-top: 5px;">‚ö†Ô∏è HP j√° est√° cheio</div>` : ''
                                        }
                                    </div>
                                    <button class="btn btn-primary" 
                                            onclick="useItemInBattle('IT_HEAL_01')"
                                            ${!canUseItem ? 'disabled style="opacity: 0.5;"' : ''}
                                            style="margin-top: 10px; width: 100%;">
                                        üíö Usar Petisco de Cura
                                    </button>
                                </div>
                                `;
                            })() : ''}
                            
                            ${playerMonster ? (() => {
                                // Feature 3.7: Use skill catalog and getSkillsArray
                                const skillIds = getSkillsArray(playerMonster);
                                if (!skillIds || skillIds.length === 0) return '';
                                
                                return `
                                <div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 8px;">
                                    <strong style="font-size: 16px;">‚ú® Habilidades</strong>
                                    <div class="flex-center" style="margin-top: 10px; gap: 10px;">
                                        ${skillIds.map((skillId, idx) => {
                                            const skill = getSkillById(skillId);
                                            if (!skill) return '';
                                            
                                            const label = formatSkillButtonLabel(skill, playerMonster);
                                            const canUse = canUseSkillNow(skill, playerMonster) && playerMonster.hp > 0;
                                            const tooltip = canUse ? (skill.desc || skill.descricao || '') : 'Sem ENE';
                                            
                                            return `
                                            <button class="btn btn-primary" 
                                                    onclick="useSkillWild(${idx})" 
                                                    ${!canUse ? 'disabled style="opacity: 0.5;"' : ''}
                                                    title="${tooltip}">
                                                ${label}
                                            </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                        </div>
                        
                        <div class="combat-log" id="combatLog" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px; max-height: 300px; overflow-y: auto;">
                            ${(encounter.log || []).map(entry => `<div style="margin: 5px 0; padding: 5px; border-bottom: 1px solid #ddd;">${entry}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                panel.innerHTML = html;
                
                // Atualizar threshold inicial
                setTimeout(() => updateCaptureThreshold(), 100);
                
                // Exibir toasts para eventos importantes (level up, evolu√ß√£o)
                maybeToastFromLog(GameState.currentEncounter);
            } catch (error) {
                showError('Failed to render wild encounter', error.stack);
            }
        }

        // Atualizar c√°lculo de threshold de captura em tempo real
        function updateCaptureThreshold() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const select = document.getElementById('captureOrbSelect');
                const display = document.getElementById('finalThresholdValue');
                if (!select || !display) return;
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) return;
                
                // Calcular threshold
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const orbBonus = orbInfo.capture_bonus_pp / 100; // Converter pp para decimal
                const lowHpBonus = hpPercent <= 0.25 ? 0.10 : 0;
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                // Atualizar display
                display.innerHTML = `
                    <span style="font-size: 18px; color: ${hpPercent <= thresholdFinal ? '#2e7d32' : '#c62828'}; font-weight: bold;">
                        ${Math.floor(thresholdFinal * 100)}%
                    </span>
                    <br><small>
                        (Base ${Math.floor(baseThreshold * 100)}% + Orb ${orbInfo.capture_bonus_pp}% + HP ${Math.floor(lowHpBonus * 100)}%)
                        <br>${hpPercent <= thresholdFinal ? '‚úÖ Captura prov√°vel!' : '‚ùå HP muito alto'}
                    </small>
                `;
            } catch (error) {
                console.error('Failed to update capture threshold:', error);
            }
        }

        function attemptCapture() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                // Valida√ß√£o: HP > 0 obrigat√≥rio
                if (monster.hp <= 0) {
                    alert('‚ùå N√£o pode capturar um monstrinho desmaiado! HP deve ser > 0.');
                    return;
                }
                
                // Obter ClasterOrb selecionada
                const select = document.getElementById('captureOrbSelect');
                if (!select) {
                    alert('‚ùå Erro ao ler sele√ß√£o de ClasterOrb.');
                    return;
                }
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) {
                    alert('‚ùå ClasterOrb inv√°lida.');
                    return;
                }
                
                // Valida√ß√£o: precisa ter a orb selecionada
                player.inventory = player.inventory || {};
                const orbCount = player.inventory[selectedOrbId] || 0;
                
                if (orbCount <= 0) {
                    alert(`‚ùå Voc√™ n√£o tem ${orbInfo.name}!`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // SEMPRE CONSOME 1 item (mesmo se falhar)
                player.inventory[selectedOrbId]--;
                encounter.log.push(`${orbInfo.emoji} ${player.name} usou ${orbInfo.name}! (Restam: ${player.inventory[selectedOrbId]})`);
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                
                // B√¥nus se HP <= 25%
                let lowHpBonus = 0;
                if (hpPercent <= 0.25) {
                    lowHpBonus = 0.10;
                    encounter.log.push(`‚ú® HP cr√≠tico! B√¥nus de +10% na captura!`);
                }
                
                // B√¥nus da orb (em decimal: 0, 0.05, 0.10)
                const orbBonus = orbInfo.capture_bonus_pp / 100;
                
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                encounter.log.push(`HP: ${Math.floor(hpPercent * 100)}% | Base: ${Math.floor(baseThreshold * 100)}% | Orb: +${orbInfo.capture_bonus_pp}% | HP Bonus: +${Math.floor(lowHpBonus * 100)}%`);
                encounter.log.push(`üéØ Threshold Final: ${Math.floor(thresholdFinal * 100)}%`);
                
                // Captura determin√≠stica: sucesso se HP% <= Threshold_final
                if (hpPercent <= thresholdFinal) {
                    encounter.log.push(`‚úÖ SUCESSO! ${monster.name} foi capturado!`);
                    
                    monster.ownerId = player.id;
                    
                    player.team = player.team || [];
                    player.box = player.box || [];
                    
                    if (player.team.length < (GameState.config?.maxTeamSize || 6)) {
                        player.team.push(monster);
                        encounter.log.push(`${monster.name} foi adicionado ao time de ${player.name}!`);
                    } else {
                        player.box.push(monster);
                        encounter.log.push(`${monster.name} foi enviado para a caixa de ${player.name}!`);
                    }
                    
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                    
                    encounter.active = false;
                    GameState.currentEncounter = null;
                } else {
                    // FALHA: Monstrinho realiza 1 ataque b√°sico IMEDIATO
                    encounter.log.push(`‚ùå FALHA! ${monster.name} quebrou livre!`);
                    
                    const playerMonster = player.team?.[0];
                    if (playerMonster && playerMonster.hp > 0) {
                        encounter.log.push(`‚ö° ${monster.name} contra-ataca!`);
                        
                        // Monstrinho selvagem ataca imediatamente
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, monster, playerMonster);
                        encounter.log.push(`üé≤ ${monster.name} rola ${enemyRoll} (ATK: ${monster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(monster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${monster.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`‚ùå ${monster.name} erra o ataque!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Capture attempt failed', error.stack);
            }
        }

        // Feature 3.1: Usar Item em Batalha
        function useItemInBattle(itemId) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('Nenhum jogador selecionado para este encontro');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Jogador n√£o tem monstrinhos no time');
                    return;
                }
                
                // VALIDA√á√ïES (GAME_RULES.md)
                
                // 1. Validar HP > 0 (monstrinho n√£o desmaiado)
                if (playerMonster.hp <= 0) {
                    alert('‚ùå N√£o pode usar item! Monstrinho est√° desmaiado (HP = 0).');
                    return;
                }
                
                // 2. Validar HP < HPMax (n√£o usar se j√° est√° cheio)
                if (playerMonster.hp >= playerMonster.hpMax) {
                    alert('‚ö†Ô∏è HP j√° est√° no m√°ximo! N√£o √© necess√°rio usar item de cura.');
                    return;
                }
                
                // 3. Validar item dispon√≠vel no invent√°rio
                player.inventory = player.inventory || {};
                const itemCount = player.inventory[itemId] || 0;
                
                if (itemCount <= 0) {
                    alert('‚ùå Voc√™ n√£o tem Petisco de Cura dispon√≠vel!');
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // CONSUMIR 1 unidade do item
                player.inventory[itemId]--;
                encounter.log.push(`üíö ${player.name} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                
                // APLICAR CURA
                // Petisco de Cura: restaura 30 HP ou 30% do HP m√°ximo (o que for maior)
                const healAmount = Math.max(30, Math.floor(playerMonster.hpMax * 0.30));
                const hpBefore = playerMonster.hp;
                playerMonster.hp = Math.min(playerMonster.hpMax, playerMonster.hp + healAmount);
                const actualHeal = playerMonster.hp - hpBefore;
                
                encounter.log.push(`‚ú® ${playerMonster.name} recuperou ${actualHeal} HP! (${playerMonster.hp}/${playerMonster.hpMax})`);
                
                // SALVAR ESTADO
                saveToLocalStorage();
                renderEncounter();
                
                // Feature 3.8: Visual feedback for healing
                setTimeout(() => {
                    showFloatingText('wildPlayerBox', `+${actualHeal}`, 'heal');
                }, 50);
                
                // INIMIGO ATACA (contra-ataque autom√°tico ap√≥s usar item)
                if (encounter.wildMonster.hp > 0) {
                    encounter.log.push(`‚öîÔ∏è Vez do inimigo...`);
                    
                    const wildMonster = encounter.wildMonster;
                    
                    // Aplicar ENE regen do inimigo
                    applyEneRegen(wildMonster, encounter);
                    
                    // Atualizar buffs do inimigo
                    updateBuffs(wildMonster);
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const wildSkills = getMonsterSkills(wildMonster);
                    const canUseSkill = wildSkills && wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                    const shouldUseSkill = canUseSkill && Math.random() < 0.5;
                    
                    if (shouldUseSkill) {
                        const skill = wildSkills[0];
                        wildMonster.ene -= skill.cost;
                        encounter.log.push(`‚ú® ${wildMonster.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                        
                        // Usar habilidade
                        useSkill(wildMonster, skill, playerMonster, encounter);
                    } else {
                        // Ataque b√°sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        encounter.log.push(`üé≤ ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, wildMonster, playerMonster));
                        
                        if (enemyHit) {
                            const power = BASIC_ATTACK_POWER[wildMonster.class] || 12;
                            
                            const atkMods = getBuffModifiers(wildMonster);
                            const effectiveAtk = Math.max(1, wildMonster.atk + atkMods.atk);
                            
                            const defMods = getBuffModifiers(playerMonster);
                            const effectiveDef = Math.max(1, playerMonster.def + defMods.def);
                            
                            const classAdv = GameState.config?.classAdvantages?.[wildMonster.class];
                            let damageMult = 1.0;
                            if (classAdv?.strong === playerMonster.class) {
                                damageMult = 1.10;
                            } else if (classAdv?.weak === playerMonster.class) {
                                damageMult = 0.90;
                            }
                            
                            const damage = calcDamage({
                                atk: effectiveAtk,
                                def: effectiveDef,
                                power: power,
                                damageMult: damageMult
                            });
                            
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Verificar se jogador perdeu
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`üíÄ ${playerMonster.name} fainted! Defeat!`);
                                encounter.active = false;
                                GameState.currentEncounter = null;
                                saveToLocalStorage();
                                renderEncounter();
                                return;
                            }
                        } else {
                            if (enemyRoll === 1) {
                                encounter.log.push(`üíÄ FALHA CR√çTICA! ${wildMonster.name} erra!`);
                            } else {
                                encounter.log.push(`‚ùå ${wildMonster.name} misses!`);
                            }
                        }
                    }
                }
                
                // RENDER atualizado
                saveToLocalStorage();
                renderEncounter();
                
            } catch (error) {
                showError('Failed to use item in battle', error.stack);
            }
        }

        function attackWild() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Player has no monsters in team');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho √© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`‚ö†Ô∏è Voc√™ s√≥ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} √© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Get dice roll from input field
                const diceInput = document.getElementById('diceRoll');
                const playerRoll = parseInt(diceInput?.value || '0');
                
                if (playerRoll < 1 || playerRoll > 20) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                
                // Clear the input for next roll
                if (diceInput) diceInput.value = '';
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no in√≠cio do turno do jogador
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs (reduzir dura√ß√£o)
                updateBuffs(playerMonster);
                
                // CRIT 20 ou FALHA 1 (GAME_RULES.md)
                let isCrit20 = false;
                let isFail1 = false;
                let critBonus = null;
                
                if (playerRoll === 20) {
                    isCrit20 = true;
                    encounter.log.push(`‚≠ê CR√çTICO 20! ‚≠ê`);
                    // Escolher b√¥nus aleat√≥rio
                    const bonusRoll = Math.floor(Math.random() * 3);
                    if (bonusRoll === 0) {
                        critBonus = 'double_power';
                        encounter.log.push(`üí• Poder dobrado neste ataque!`);
                    } else if (bonusRoll === 1) {
                        critBonus = 'item';
                        player.inventory = player.inventory || {};
                        player.inventory['IT_HEAL_01'] = (player.inventory['IT_HEAL_01'] || 0) + 1;
                        encounter.log.push(`üéÅ Ganhou 1 Petisco de Cura!`);
                    } else {
                        critBonus = 'money';
                        const moneyGain = 20 + Math.floor(Math.random() * 31); // 20-50
                        player.money = (player.money || 0) + moneyGain;
                        encounter.log.push(`üí∞ Ganhou ${moneyGain} moedas!`);
                    }
                } else if (playerRoll === 1) {
                    isFail1 = true;
                }
                
                // Fase 1: Ataque do jogador
                encounter.log.push(`üé≤ ${player.name}'s ${playerMonster.name} rolls ${playerRoll} (ATK: ${playerMonster.atk})`);
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit20 ? 'crit' : isFail1 ? 'fail' : 'normal';
                recordD20Roll(encounter, player.name, playerRoll, rollType);
                
                // d20=1 sempre erra, d20=20 sempre acerta
                const playerHit = isFail1 ? false : (isCrit20 ? true : checkHit(playerRoll, playerMonster, encounter.wildMonster));
                
                if (playerHit) {
                    // Calcular dano com power modificado se CRIT 20
                    let power = BASIC_ATTACK_POWER[playerMonster.class] || 12;
                    if (isCrit20 && critBonus === 'double_power') {
                        power *= 2; // Dobrar POWER antes do c√°lculo
                    }
                    
                    // Calcular dano com nova f√≥rmula
                    const atkMods = getBuffModifiers(playerMonster);
                    const effectiveAtk = Math.max(1, playerMonster.atk + atkMods.atk);
                    
                    const defMods = getBuffModifiers(encounter.wildMonster);
                    const effectiveDef = Math.max(1, encounter.wildMonster.def + defMods.def);
                    
                    const classAdv = GameState.config?.classAdvantages?.[playerMonster.class];
                    let damageMult = 1.0;
                    if (classAdv?.strong === encounter.wildMonster.class) {
                        damageMult = 1.10;
                    } else if (classAdv?.weak === encounter.wildMonster.class) {
                        damageMult = 0.90;
                    }
                    
                    const damage = calcDamage({
                        atk: effectiveAtk,
                        def: effectiveDef,
                        power: power,
                        damageMult: damageMult
                    });
                    
                    encounter.wildMonster.hp = Math.max(0, encounter.wildMonster.hp - damage);
                    encounter.log.push(`üí• ${playerMonster.name} hits! Deals ${damage} damage!`);
                    
                    // Feature 3.8: Visual feedback
                    saveToLocalStorage();
                    renderEncounter();
                    setTimeout(() => {
                        showFloatingText('wildEnemyBox', `-${damage}`, isCrit20 ? 'crit' : 'damage');
                        flashTarget('wildEnemyBox', isCrit20 ? 'crit' : 'hit');
                    }, 50);
                    
                    if (encounter.wildMonster.hp <= 0) {
                        encounter.log.push(`üèÜ ${encounter.wildMonster.name} fainted! Victory!`);
                        
                        // Feature 3.3: Distribuir recompensas (XP) com idempot√™ncia
                        handleVictoryRewards(encounter);
                        
                        encounter.active = false;
                        GameState.currentEncounter = null;
                        saveToLocalStorage();
                        renderEncounter();
                        return;
                    }
                } else {
                    if (isFail1) {
                        encounter.log.push(`üíÄ FALHA CR√çTICA! Ataque erra automaticamente!`);
                    } else {
                        encounter.log.push(`‚ùå ${playerMonster.name} misses!`);
                    }
                    
                    // Feature 3.8: Flash fail on player
                    saveToLocalStorage();
                    renderEncounter();
                    setTimeout(() => flashTarget('wildPlayerBox', 'fail'), 50);
                }
                
                // Fase 2: Contra-ataque do monstrinho selvagem (se ainda vivo)
                if (encounter.wildMonster.hp > 0) {
                    const wildMonster = encounter.wildMonster;
                    const wildSkill = wildMonster.skill;
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const useSkill = wildSkill && (wildMonster.ene || 0) >= wildSkill.energy_cost && Math.random() < 0.5;
                    
                    if (useSkill) {
                        wildMonster.ene -= wildSkill.energy_cost;
                        encounter.log.push(`‚ú® ${wildMonster.name} usa ${wildSkill.name}! (-${wildSkill.energy_cost} ENE)`);
                        
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`üé≤ ${wildMonster.name} rolls ${enemyRoll}`);
                        
                        // Feature 3.8: Record enemy d20 roll
                        const enemyRollType = enemyRoll === 20 ? 'crit' : enemyRoll === 1 ? 'fail' : 'normal';
                        recordD20Roll(encounter, wildMonster.name, enemyRoll, enemyRollType);
                        
                        if (enemyHit) {
                            const baseDamage = wildMonster.atk + wildSkill.power - playerMonster.def;
                            const damage = Math.max(1, baseDamage);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${wildSkill.name} acerta! Causa ${damage} de dano!`);
                            
                            // Feature 3.8: Visual feedback
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => {
                                showFloatingText('wildPlayerBox', `-${damage}`, enemyRoll === 20 ? 'crit' : 'damage');
                                flashTarget('wildPlayerBox', enemyRoll === 20 ? 'crit' : 'hit');
                            }, 50);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                            return;
                        } else {
                            encounter.log.push(`‚ùå ${wildSkill.name} erra!`);
                            
                            // Feature 3.8: Flash fail on enemy
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => flashTarget('wildEnemyBox', 'fail'), 50);
                        }
                    } else {
                        // Ataque b√°sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`üé≤ Wild ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        // Feature 3.8: Record enemy d20 roll
                        const enemyRollType = enemyRoll === 20 ? 'crit' : enemyRoll === 1 ? 'fail' : 'normal';
                        recordD20Roll(encounter, wildMonster.name, enemyRoll, enemyRollType);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(wildMonster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Feature 3.8: Visual feedback
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => {
                                showFloatingText('wildPlayerBox', `-${damage}`, enemyRoll === 20 ? 'crit' : 'damage');
                                flashTarget('wildPlayerBox', enemyRoll === 20 ? 'crit' : 'hit');
                            }, 50);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                            return;
                        } else {
                            encounter.log.push(`‚ùå ${wildMonster.name} misses!`);
                            
                            // Feature 3.8: Flash fail on enemy
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => flashTarget('wildEnemyBox', 'fail'), 50);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Attack failed', error.stack);
            }
        }

        // Usar habilidade contra o selvagem (por √≠ndice 0, 1, 2)
        function useSkillWild(skillIndex) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('No monster available');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho √© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`‚ö†Ô∏è Voc√™ s√≥ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} √© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Obter habilidades dispon√≠veis
                const skills = getMonsterSkills(playerMonster);
                if (!skills || skillIndex >= skills.length || !skills[skillIndex]) {
                    alert('Skill not available');
                    return;
                }
                
                const skill = skills[skillIndex];
                
                // Validar ENE suficiente
                if ((playerMonster.ene || 0) < skill.cost) {
                    alert(`‚ùå ENE insuficiente! Precisa de ${skill.cost} ENE.`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no in√≠cio do turno
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs
                updateBuffs(playerMonster);
                
                // Usar habilidade
                const success = useSkill(playerMonster, skill, encounter.wildMonster, encounter);
                
                if (!success) {
                    alert('Failed to use skill');
                    return;
                }
                
                // Verificar se o selvagem foi derrotado
                if (encounter.wildMonster.hp <= 0) {
                    encounter.log.push(`üèÜ ${encounter.wildMonster.name} foi derrotado!`);
                    const xpGained = calculateBattleXP(encounter.wildMonster);
                    giveXp(playerMonster, xpGained);
                    encounter.log.push(`‚ú® ${playerMonster.name} ganhou ${xpGained} XP!`);
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }
                
                // Fase 2: Contra-ataque do selvagem
                const wildMonster = encounter.wildMonster;
                
                // Atualizar buffs do selvagem
                updateBuffs(wildMonster);
                
                // IA: 50% chance de usar habilidade se tiver ENE
                const wildSkills = getMonsterSkills(wildMonster);
                const canUseSkill = wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                const useWildSkill = canUseSkill && Math.random() < 0.5;
                
                if (useWildSkill) {
                    // Selvagem usa habilidade
                    useSkill(wildMonster, wildSkills[0], playerMonster, encounter);
                    
                    if (playerMonster.hp <= 0) {
                        encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                        playerMonster.status = 'fainted';
                        encounter.active = false;
                        GameState.currentEncounter = null;
                    }
                } else {
                    // Ataque b√°sico do selvagem
                    const enemyRoll = Math.floor(Math.random() * 20) + 1;
                    const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                    encounter.log.push(`üé≤ ${wildMonster.name} rola ${enemyRoll} (ATK: ${wildMonster.atk})`);
                    
                    if (enemyHit) {
                        const mods = getBuffModifiers(wildMonster);
                        const effectiveAtk = wildMonster.atk + mods.atk;
                        const damage = calculateDamage(wildMonster, playerMonster);
                        playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                        encounter.log.push(`üí• ${wildMonster.name} acerta! Causa ${damage} de dano!`);
                        
                        if (playerMonster.hp <= 0) {
                            encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                            playerMonster.status = 'fainted';
                            encounter.active = false;
                            GameState.currentEncounter = null;
                        }
                    } else {
                        encounter.log.push(`‚ùå ${wildMonster.name} erra!`);
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Skill use failed', error.stack);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SISTEMA DE DANO - F√≥rmulas Oficiais (GAME_RULES.md)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Verifica se um ataque acerta o alvo
         * F√ìRMULA: d20 + ATK + ClassBonus >= DEF
         * 
         * @param {number} d20Roll - Resultado do dado d20 (1-20)
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {boolean} true se acertou, false se errou
         * 
         * VANTAGEM DE CLASSE (Acerto):
         * - Vantagem: +2 ATK
         * - Desvantagem: -2 ATK
         * 
         * REGRAS ESPECIAIS:
         * - d20 = 1: sempre erra (falha cr√≠tica)
         * - d20 = 20: sempre acerta (acerto cr√≠tico)
         */
        function checkHit(d20Roll, attacker, defender) {
            try {
                if (!attacker || !defender) return false;
                
                const atkMod = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +2 ATK se forte, -2 ATK se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let atkBonus = 0;
                if (classAdv?.strong === defender.class) {
                    atkBonus = 2;
                } else if (classAdv?.weak === defender.class) {
                    atkBonus = -2;
                }
                
                const totalAtk = d20Roll + atkMod + atkBonus;
                return totalAtk >= defValue;
            } catch (error) {
                console.error('Hit check failed:', error);
                return false;
            }
        }

        /**
         * Calcula dano de um ataque
         * F√ìRMULA BASE: floor(POWER * (ATK / (ATK + DEF))) * damageMult
         * DANO M√çNIMO: sempre 1
         * 
         * @param {object} params - Par√¢metros de dano
         * @param {number} params.atk - Ataque efetivo (com buffs)
         * @param {number} params.def - Defesa efetiva (com buffs)
         * @param {number} params.power - Poder da habilidade/ataque
         * @param {number} params.damageMult - Multiplicador (1.0 padr√£o, 1.10 vantagem, 0.90 desvantagem)
         * @returns {number} Dano final (m√≠nimo 1)
         * 
         * VANTAGEM DE CLASSE (Dano):
         * - Vantagem: 1.10 (110% do dano base)
         * - Desvantagem: 0.90 (90% do dano base)
         * - Neutro: 1.0 (100% do dano base)
         * 
         * EXEMPLO:
         * ATK=10, DEF=5, POWER=15
         * ratio = 10/(10+5) = 0.666
         * baseD = floor(15 * 0.666) = floor(9.99) = 9
         * finalD = floor(9 * 1.0) = 9
         */
        function calcDamage({ atk, def, power, damageMult = 1.0 }) {
            try {
                // ratio = ATK / (ATK + DEF)
                const ratio = atk / (atk + def);
                
                // danoBase = floor(POWER * ratio)
                const baseD = Math.floor(power * ratio);
                
                // Aplicar multiplicador de classe
                const finalD = Math.floor(baseD * damageMult);
                
                // Dano m√≠nimo sempre 1
                return Math.max(1, finalD);
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        /**
         * Wrapper de compatibilidade - calcula dano com ataque b√°sico
         * Aplica automaticamente buffs e vantagens de classe
         * 
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {number} Dano final
         * 
         * FLUXO:
         * 1. Obt√©m stats base (atk, def)
         * 2. Aplica modificadores de buffs
         * 3. Obt√©m POWER b√°sico da classe
         * 4. Calcula multiplicador de classe
         * 5. Chama calcDamage() com todos os par√¢metros
         */
        function calculateDamage(attacker, defender) {
            try {
                if (!attacker || !defender) return 1;
                
                const atkValue = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // POWER b√°sico por classe
                const basicPower = BASIC_ATTACK_POWER[attacker.class] || 12;
                
                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(attacker);
                const effectiveAtk = Math.max(1, atkValue + atkMods.atk);
                
                const defMods = getBuffModifiers(defender);
                const effectiveDef = Math.max(1, defValue + defMods.def);
                
                // Vantagem de classe: +10% dano se forte, -10% dano se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let damageMult = 1.0;
                if (classAdv?.strong === defender.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === defender.class) {
                    damageMult = 0.90;
                }
                
                return calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: basicPower,
                    damageMult: damageMult
                });
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        // Calcula XP de batalha
        function calculateBattleXP(defeatedMonster) {
            try {
                const baseXP = GameState.config?.battleXpBase || 15;
                const levelMod = (defeatedMonster.level || 1) * 2;
                const rarityMod = GameState.config?.rarityXP?.[defeatedMonster.rarity] || 1.0;
                
                return Math.floor((baseXP + levelMod) * rarityMod);
            } catch (error) {
                console.error('XP calculation failed:', error);
                return 15;
            }
        }

        function giveXp(monster, amount) {
            try {
                if (!monster) return;
                
                monster.xp = (monster.xp || 0) + amount;
                
                // F√≥rmula de XP por n√≠vel conforme AGENTS.md: Math.round(40 + 6*L + 0.6*(L*L))
                const xpNeeded = Math.round(40 + 6 * monster.level + 0.6 * (monster.level * monster.level));
                
                while (monster.xp >= xpNeeded && monster.level < (GameState.config?.maxLevel || 100)) {
                    monster.xp -= xpNeeded;
                    monster.level++;
                    
                    // Recalcula stats baseado no novo n√≠vel
                    const template = MONSTER_CATALOG.find(m => m?.id === monster.monsterId);
                    if (template) {
                        const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                        const levelMult = (1 + (monster.level - 1) * 0.1);
                        
                        // HP aumenta: hpMax * 1.04 + 2 conforme AGENTS.md
                        const oldHpMax = monster.hpMax;
                        monster.hpMax = Math.floor(monster.hpMax * 1.04 + 2);
                        // HP atual aumenta proporcionalmente
                        const hpRatio = monster.hp / oldHpMax;
                        monster.hp = Math.floor(monster.hpMax * hpRatio);
                        
                        // Recalcula ATK, DEF, PODER
                        monster.atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                        monster.def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                        monster.poder = Math.floor(monster.atk * 0.5);
                    }
                }
                
                saveToLocalStorage();
            } catch (error) {
                console.error('Failed to give XP:', error);
            }
        }

        function fleeEncounter() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter) return;
                
                if (confirm('Flee from this encounter?')) {
                    encounter.log = encounter.log || [];
                    encounter.log.push('üèÉ Fled from encounter');
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    
                    saveToLocalStorage();
                    renderEncounter();
                }
            } catch (error) {
                showError('Flee failed', error.stack);
            }
        }

        function getCurrentPlayer() {
            try {
                if (!GameState.currentSession) return null;
                
                const turnIndex = GameState.currentSession.currentTurnIndex || 0;
                const playerId = GameState.currentSession.turnOrder?.[turnIndex];
                
                return GameState.players?.find(p => p?.id === playerId) || null;
            } catch (error) {
                console.error('Failed to get current player:', error);
                return null;
            }
        }

        // THERAPY MANAGEMENT
        function addObjective() {
            try {
                const text = document.getElementById('newObjective')?.value?.trim();
                const weight = parseInt(document.getElementById('objectiveWeight')?.value || '1');
                
                if (!text) {
                    alert('Please enter objective description');
                    return;
                }
                
                const objective = {
                    id: Date.now(),
                    text: text,
                    weight: weight
                };
                
                GameState.objectives = GameState.objectives || [];
                GameState.objectives.push(objective);
                
                document.getElementById('newObjective').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add objective', error.stack);
            }
        }

        function toggleObjectiveForPlayer(playerId, objectiveId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                therapy.completedObjectives = therapy.completedObjectives || [];
                
                const index = therapy.completedObjectives.indexOf(objectiveId);
                if (index > -1) {
                    therapy.completedObjectives.splice(index, 1);
                } else {
                    therapy.completedObjectives.push(objectiveId);
                }
                
                therapy.pm = 0;
                therapy.completedObjectives.forEach(objId => {
                    const obj = GameState.objectives?.find(o => o?.id === objId);
                    if (obj) {
                        therapy.pm += obj.weight || 0;
                    }
                });
                
                updateMedals(playerId);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to toggle objective', error.stack);
            }
        }

        function updateMedals(playerId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                const pm = therapy.pm || 0;
                const tiers = GameState.config?.medalTiers || { bronze: 10, silver: 25, gold: 50 };
                
                therapy.medals = therapy.medals || [];
                
                if (pm >= tiers.gold && !therapy.medals.includes('gold')) {
                    therapy.medals.push('gold');
                } else if (pm >= tiers.silver && !therapy.medals.includes('silver')) {
                    therapy.medals.push('silver');
                } else if (pm >= tiers.bronze && !therapy.medals.includes('bronze')) {
                    therapy.medals.push('bronze');
                }
            } catch (error) {
                console.error('Failed to update medals:', error);
            }
        }

        // UI UPDATE FUNCTIONS
        function updateAllViews() {
            try {
                updateHomeStats();
                updatePlayersList();
                updateSessionView();
                updateTherapyView();
                updateReportView();
                updateEncounterPlayerDropdown();
                updateEncounterUI();
                renderEncounter();
            } catch (error) {
                console.error('Failed to update views:', error);
            }
        }

        function updateEncounterPlayerDropdown() {
            try {
                const select = document.getElementById('encounterPlayer');
                if (!select) return;
                
                select.innerHTML = '<option value="">-- Select Player --</option>';
                
                if (GameState.players && GameState.players.length > 0) {
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.name} (${player.class || 'No class'})`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to update encounter player dropdown:', error);
            }
        }
        
        function updateEncounterUI() {
            try {
                const type = document.getElementById('encounterType')?.value;
                const playerSelectDiv = document.getElementById('playerSelectDiv');
                const groupSelectDiv = document.getElementById('groupSelectDiv');
                
                if (!playerSelectDiv || !groupSelectDiv) return;
                
                if (type === 'wild') {
                    playerSelectDiv.classList.remove('hidden');
                    groupSelectDiv.classList.add('hidden');
                } else if (type === 'trainer' || type === 'boss') {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.remove('hidden');
                    updateGroupParticipantsList();
                } else {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.add('hidden');
                }
            } catch (error) {
                console.error('Failed to update encounter UI:', error);
            }
        }
        
        function updateGroupParticipantsList() {
            try {
                const container = document.getElementById('groupParticipantsList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p style="color: #666;">No players available. Add players first.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const mon = player.team?.[0];
                    const monName = mon ? (mon.name || mon.nome || 'No monster') : 'No monster';
                    const hasValidMonster = mon && mon.hp > 0;
                    
                    html += `<div style="padding: 5px;">`;
                    html += `<label style="cursor: pointer; display: flex; align-items: center;">`;
                    html += `<input type="checkbox" name="groupParticipant" value="${player.id}" ${!hasValidMonster ? 'disabled' : ''}>`;
                    html += `<span style="margin-left: 8px;">${player.name} (${player.class})`;
                    if (hasValidMonster) {
                        html += ` - ${monName} Nv${mon.level}`;
                    } else {
                        html += ` - <span style="color: #999;">No valid monster</span>`;
                    }
                    html += `</span>`;
                    html += `</label>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update group participants list:', error);
            }
        }

        function updateHomeStats() {
            try {
                const statPlayers = document.getElementById('statPlayers');
                const statMonsters = document.getElementById('statMonsters');
                const statSession = document.getElementById('statSession');
                
                if (statPlayers) statPlayers.textContent = GameState.players?.length || 0;
                if (statMonsters) statMonsters.textContent = GameState.monsters?.length || 0;
                if (statSession) statSession.textContent = GameState.currentSession ? 'Yes' : 'No';
            } catch (error) {
                console.error('Failed to update home stats:', error);
            }
        }

        function updatePlayersList() {
            try {
                const container = document.getElementById('playersList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<div class="card"><p>No players yet. Add one above!</p></div>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const teamCount = player.team?.length || 0;
                    const boxCount = player.box?.length || 0;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <div class="badge badge-${player.playerClassId}">${player.playerClassId}</div>
                            <p>üí∞ Money: ${player.money || 0} | ‚≠ê Afterlife: ${player.afterlifeCurrency || 0}</p>
                            <p>üë• Team: ${teamCount}/${GameState.config?.maxTeamSize || 6} | üì¶ Box: ${boxCount}</p>
                            
                            <h4>Team:</h4>
                            <div class="flex">
                                ${(player.team || []).map(m => renderMonsterCard(m)).join('')}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update players list:', error);
            }
        }

        function renderMonsterCard(monster) {
            try {
                if (!monster) return '';
                
                const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                const xpNeeded = (monster.level || 1) * 100;
                const xpPercent = ((monster.xp || 0) / xpNeeded) * 100;
                
                return `
                    <div class="monster-card ${monster.class || 'common'}">
                        <div style="font-size: 36px;">${monster.emoji || 'üîÆ'}</div>
                        <strong>${monster.name || 'Unknown'}</strong>
                        <div class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'common'}</div>
                        <div>Lv ${monster.level || 1}</div>
                        <div class="progress-bar" style="height: 20px;">
                            <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                        </div>
                        <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                        <div class="progress-bar" style="height: 15px;">
                            <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                        </div>
                        <small>${monster.xp || 0}/${xpNeeded} XP</small>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to render monster card:', error);
                return '<div class="monster-card">Error</div>';
            }
        }

        function updateSessionView() {
            try {
                const panel = document.getElementById('activeSessionPanel');
                if (!panel) return;
                
                if (!GameState.currentSession) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                const session = GameState.currentSession;
                document.getElementById('activeSessionName').textContent = session.name || 'Unnamed';
                document.getElementById('sessionCreated').textContent = new Date(session.createdAt).toLocaleString();
                
                const turnList = document.getElementById('turnOrderList');
                if (turnList) {
                    let html = '<div class="flex">';
                    (session.turnOrder || []).forEach((playerId, index) => {
                        const player = GameState.players?.find(p => p?.id === playerId);
                        if (player) {
                            const isCurrent = index === (session.currentTurnIndex || 0);
                            html += `
                                <div class="stat-box" style="${isCurrent ? 'background: var(--success); color: white;' : ''}">
                                    ${isCurrent ? '‚ñ∂ ' : ''}${player.name}
                                </div>
                            `;
                        }
                    });
                    html += '</div>';
                    turnList.innerHTML = html;
                }
            } catch (error) {
                console.error('Failed to update session view:', error);
            }
        }

        function updateTherapyView() {
            try {
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    let html = '<h4>Current Objectives:</h4>';
                    (GameState.objectives || []).forEach(obj => {
                        if (!obj) return;
                        html += `
                            <div class="objective-item">
                                <strong>Weight ${obj.weight}:</strong> ${obj.text}
                            </div>
                        `;
                    });
                    objectivesList.innerHTML = html;
                }
                
                const therapyPlayersList = document.getElementById('therapyPlayersList');
                if (!therapyPlayersList) return;
                
                if (!GameState.currentSession) {
                    therapyPlayersList.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                let html = '';
                (GameState.players || []).forEach(player => {
                    if (!player) return;
                    
                    const therapy = GameState.currentSession.therapy?.perPlayer?.[player.id];
                    if (!therapy) return;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <p><strong>PM (Merit Points):</strong> ${therapy.pm || 0}</p>
                            <p><strong>Medals:</strong> 
                                ${(therapy.medals || []).map(m => {
                                    const emoji = { bronze: 'ü•â', silver: 'ü•à', gold: 'ü•á' }[m] || 'üèÖ';
                                    return `<span class="medal">${emoji}</span>`;
                                }).join('')}
                            </p>
                            
                            <h4>Objectives:</h4>
                            ${(GameState.objectives || []).map(obj => {
                                if (!obj) return '';
                                const completed = therapy.completedObjectives?.includes(obj.id);
                                return `
                                    <div class="objective-item">
                                        <input type="checkbox" 
                                               ${completed ? 'checked' : ''}
                                               onchange="toggleObjectiveForPlayer(${player.id}, ${obj.id})"
                                               style="width: 30px; height: 30px; cursor: pointer;">
                                        <span>${obj.text} (${obj.weight} PM)</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                });
                
                therapyPlayersList.innerHTML = html;
            } catch (error) {
                console.error('Failed to update therapy view:', error);
            }
        }

        function updateReportView() {
            try {
                const container = document.getElementById('reportContent');
                if (!container) return;
                
                if (!GameState.currentSession) {
                    container.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                const session = GameState.currentSession;
                
                let html = `
                    <div class="card">
                        <h3>Session: ${session.name}</h3>
                        <p>Started: ${new Date(session.createdAt).toLocaleString()}</p>
                        ${session.completedAt ? `<p>Ended: ${new Date(session.completedAt).toLocaleString()}</p>` : '<p>Status: Active</p>'}
                    </div>
                    
                    <div class="card">
                        <h3>Player Summary</h3>
                        ${(GameState.players || []).map(player => {
                            if (!player) return '';
                            const therapy = session.therapy?.perPlayer?.[player.id];
                            if (!therapy) return '';
                            
                            return `
                                <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 10px;">
                                    <h4>${player.name}</h4>
                                    <p>PM Earned: ${therapy.pm || 0}</p>
                                    <p>Medals: ${(therapy.medals || []).join(', ') || 'None yet'}</p>
                                    <p>Objectives Completed: ${therapy.completedObjectives?.length || 0}/${GameState.objectives?.length || 0}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update report view:', error);
            }
        }

        // DATA MANAGEMENT
        function exportData() {
            try {
                const data = JSON.stringify(GameState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                showError('Export failed', error.stack);
            }
        }

        function importData() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target?.files?.[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target?.result || '{}');
                            Object.assign(GameState, data);
                            saveToLocalStorage();
                            updateAllViews();
                            alert('Data imported successfully!');
                        } catch (error) {
                            showError('Import failed', error.stack);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError('Import failed', error.stack);
            }
        }

        function clearAllData() {
            try {
                if (confirm('Are you sure? This will delete ALL data!')) {
                    if (confirm('Really sure? This cannot be undone!')) {
                        localStorage.removeItem('monstrinhomon_state');
                        location.reload();
                    }
                }
            } catch (error) {
                showError('Clear data failed', error.stack);
            }
        }

        function toggleTherapistMode() {
            try {
                const checked = document.getElementById('therapistMode')?.checked;
                const configPanel = document.getElementById('configPanel');
                if (configPanel) {
                    if (checked) {
                        configPanel.classList.remove('hidden');
                    } else {
                        configPanel.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle therapist mode:', error);
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
    <div id="mmToastHost"></div>
</body>
</html>
