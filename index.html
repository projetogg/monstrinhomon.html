<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Monstrinhomon - Therapeutic Game</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="js/storage.js"></script>
</head>
<body>
    <div id="errorPanel" class="error-panel">
        <div id="errorMessage"></div>
        <button onclick="copyError()">üìã Copy Error</button>
        <button onclick="dismissError()">‚úñ Dismiss</button>
    </div>

    <div class="app-container">
        <div class="header">
            <h1>üéÆ Monstrinhomon üåü</h1>
            <div class="tabs">
                <button class="tab-button" onclick="mmShowMainMenu()">üì± Menu</button>
                <button class="tab-button active" onclick="switchTab('home')">üè† Home</button>
                <button class="tab-button" onclick="switchTab('session')">üìã Session</button>
                <button class="tab-button" onclick="switchTab('players')">üë• Players</button>
                <button class="tab-button" onclick="switchTab('encounter')">‚öîÔ∏è Encounter</button>
                <button class="tab-button" onclick="switchTab('therapy')">üéØ Therapy</button>
                <button class="tab-button" onclick="switchTab('box')">üì¶ Box</button>
                <button class="tab-button" onclick="switchTab('partyDex')">üìò Monstrodex</button>
                <button class="tab-button" onclick="switchTab('shop')">üõí Loja</button>
                <button class="tab-button" onclick="switchTab('report')">üìä Report</button>
                <button class="tab-button" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <div id="tabHome" class="tab-content active">
            <h2>Welcome to Monstrinhomon! üéâ</h2>
            <p class="intro-text">A therapeutic game for young trainers.</p>
            
            <div class="card">
                <h3>Quick Stats</h3>
                <div id="homeStats">
                    <div class="stat-box">Active Players: <span id="statPlayers">0</span></div>
                    <div class="stat-box">Total Monsters: <span id="statMonsters">0</span></div>
                    <div class="stat-box">Session Active: <span id="statSession">No</span></div>
                </div>
            </div>

            <!-- FASE 1 POKEMON: Monstr√≥dex -->
            <div class="card">
                <h3>üìñ Monstr√≥dex</h3>
                <div id="monstrodexStats"></div>
            </div>

            <!-- FASE 1 POKEMON: Livro de Conquistas -->
            <div class="card">
                <h3>üèÜ Livro de Conquistas</h3>
                <div id="achievementsStats"></div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div class="flex">
                    <button class="btn btn-large btn-success" onclick="switchTab('session')">Start New Session</button>
                    <button class="btn btn-large" onclick="switchTab('players')">Manage Players</button>
                    <button class="btn btn-large btn-secondary" onclick="switchTab('encounter')">Start Encounter</button>
                </div>
            </div>
        </div>

        <div id="tabSession" class="tab-content">
            <h2>Session Management üìã</h2>
            
            <div class="card">
                <h3>Create New Session</h3>
                <input type="text" id="sessionName" placeholder="Session Name (e.g., Therapy Session 2024-01-15)">
                <button class="btn btn-success" onclick="createSession()">Create Session</button>
            </div>

            <div id="activeSessionPanel" class="card is-hidden">
                <h3>Active Session: <span id="activeSessionName"></span></h3>
                <p>Created: <span id="sessionCreated"></span></p>
                
                <h4>Turn Order</h4>
                <div id="turnOrderList"></div>
                
                <button class="btn btn-warning" onclick="nextTurn()">Next Turn ‚ñ∂</button>
                <button class="btn btn-danger" onclick="endSession()">End Session</button>
            </div>
        </div>

        <div id="tabPlayers" class="tab-content">
            <h2>Player Management üë•</h2>
            
            <div class="card">
                <h3>Add New Player</h3>
                <input type="text" id="playerName" placeholder="Player Name">
                <select id="playerClass">
                    <option value="">Select Class</option>
                    <option value="Guerreiro">‚öîÔ∏è Guerreiro</option>
                    <option value="Mago">üîÆ Mago</option>
                    <option value="Curandeiro">üíö Curandeiro</option>
                    <option value="B√°rbaro">üí™ B√°rbaro</option>
                    <option value="Ladino">üó°Ô∏è Ladino</option>
                    <option value="Bardo">üéµ Bardo</option>
                    <option value="Ca√ßador">üèπ Ca√ßador</option>
                    <option value="Animalista">üêæ Animalista</option>
                </select>
                <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
            </div>

            <div id="playersList"></div>
        </div>

        <div id="tabEncounter" class="tab-content">
            <h2>Encounter ‚öîÔ∏è</h2>
            
            <div class="card">
                <h3>Start New Encounter</h3>
                <select id="encounterType" onchange="updateEncounterUI()">
                    <option value="wild">üåü Wild Monster (Individual Capture)</option>
                    <option value="trainer">üë§ Trainer Battle (Group)</option>
                    <option value="boss">üëπ Boss Battle (Group)</option>
                    <option value="event">üìñ Narrative Event</option>
                </select>
                
                <!-- Para encontros individuais (wild) -->
                <div id="playerSelectDiv" class="mt-15">
                    <label><strong>Select Player for Individual Encounter:</strong></label>
                    <select id="encounterPlayer">
                        <option value="">-- Select Player --</option>
                    </select>
                </div>
                
                <!-- Para encontros em grupo (trainer/boss) -->
                <div id="groupSelectDiv" class="is-hidden mt-15">
                    <label><strong>Select Participants (1-6):</strong></label>
                    <div id="groupParticipantsList" class="mt-10"></div>
                    <div class="mt-10">
                        <label><strong>Enemy Level:</strong></label>
                        <select id="enemyLevel">
                            <option value="1">1</option>
                            <option value="3">3</option>
                            <option value="5" selected>5</option>
                            <option value="7">7</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                    
                    <!-- Team Reorder UI -->
                    <div class="team-reorder-section">
                        <h4 class="m-0">‚öîÔ∏è Organize Equipes</h4>
                        <p class="text-small text-muted">Reordene o time de cada jogador. O primeiro monstrinho vivo ser√° usado na batalha.</p>
                        <div id="teamReorderContainer"></div>
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="startEncounter()">Start Encounter</button>
            </div>

            <div id="encounterPanel" class="is-hidden"></div>
        </div>

        <div id="tabTherapy" class="tab-content">
            <h2>Therapeutic Objectives üéØ</h2>
            
            <div class="therapist-panel">
                <h3>‚öïÔ∏è Therapist Controls</h3>
                
                <div class="card">
                    <h4>Add Objective</h4>
                    <input type="text" id="newObjective" placeholder="Objective description">
                    <select id="objectiveWeight">
                        <option value="1">Low Weight (1)</option>
                        <option value="2">Medium Weight (2)</option>
                        <option value="3">High Weight (3)</option>
                    </select>
                    <button class="btn btn-success" onclick="addObjective()">Add Objective</button>
                </div>

                <div id="objectivesList"></div>
            </div>

            <div id="therapyPlayersList"></div>
        </div>

        <div id="tabReport" class="tab-content">
            <h2>Session Report üìä</h2>
            <div id="reportContent"></div>
        </div>

        <div id="tabShop" class="tab-content">
            <h2>Loja de Itens üõí</h2>
            
            <div class="card">
                <h3>Jogador Selecionado</h3>
                <div id="shopPlayerInfo">
                    <p>Selecione um jogador para comprar itens.</p>
                </div>
            </div>

            <div class="card">
                <h3>üíº Seu Invent√°rio</h3>
                <div id="shopPlayerInventory">
                    <p>Seu invent√°rio est√° vazio.</p>
                </div>
            </div>

            <div class="card">
                <h3>üõí Itens Dispon√≠veis para Compra</h3>
                <div id="shopItemsList">
                    <p>Carregando itens...</p>
                </div>
            </div>
        </div>

        <div id="tabBox" class="tab-content">
            <h2>Box (PC) üì¶</h2>
            
            <div class="card">
                <h3>üìç Status</h3>
                <div id="boxStatus">
                    <p><strong>Jogador Ativo:</strong> <span id="boxActivePlayer">-</span></p>
                    <p><strong>Equipe:</strong> <span id="boxTeamCount">0/6</span></p>
                    <p><strong>Box Total:</strong> <span id="boxTotalCount">0/100</span></p>
                </div>
            </div>

            <div class="card">
                <h3>üìñ P√°gina da Box</h3>
                <div class="mb-10">
                    <label><strong>Visualizar p√°gina de:</strong></label>
                    <select id="boxPageSelect" onchange="onBoxPageChange()">
                        <option value="">-- Selecione --</option>
                    </select>
                </div>
            </div>

            <div class="card">
                <h3>üéí Sua Equipe</h3>
                <div id="boxTeamList" class="box-grid">
                    <p class="text-center">Carregando...</p>
                </div>
            </div>

            <div class="card">
                <h3>üì¶ Monstrinhos na Box</h3>
                <div id="boxMonstersList" class="box-grid">
                    <p class="text-center">Carregando...</p>
                </div>
            </div>
        </div>

        <!-- PR16B: PartyDex Tab -->
        <div id="tabPartyDex" class="tab-content">
            <div id="partyDexRoot">
                <p class="text-center">Carregando Monstrodex...</p>
            </div>
        </div>

        <div id="tabSettings" class="tab-content">
            <h2>Settings ‚öôÔ∏è</h2>
            
            <div class="card">
                <h3>Game Configuration</h3>
                <label>
                    <input type="checkbox" id="therapistMode" onchange="toggleTherapistMode()">
                    Therapist Mode (Show advanced controls)
                </label>
            </div>

            <!-- Therapist Mode Panel - Commit 1 -->
            <div id="therapistPanel" class="card therapist-header is-hidden">
                <h3>üî¨ Therapist Mode Tools</h3>
                <p class="therapist-header-text">Advanced debugging and testing controls</p>
                <div id="therapistPanelContent">
                    <!-- Commit 9: Therapist Log -->
                    <div class="therapist-log-box">
                        <div class="d-flex" style="justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h4 style="margin: 0;">üìú Action Log</h4>
                            <button class="btn btn-sm" onclick="clearTherapistLog()">üóëÔ∏è Clear</button>
                        </div>
                        <div id="therapistLog" class="therapist-log"></div>
                    </div>
                    
                    <!-- Commit 2: Export/Import Save Tools -->
                    <div class="save-management-box">
                        <h4 class="save-management-title">üíæ Save Management</h4>
                        <div class="d-flex flex-gap-10 flex-wrap">
                            <button class="btn btn-success flex-1 min-w-120" onclick="therapistExportSave()">üì§ Export Save (JSON)</button>
                            <button class="btn btn-warning flex-1 min-w-120" onclick="therapistImportSave()">üì• Import Save (JSON)</button>
                        </div>
                        <textarea id="therapistJsonArea" placeholder="Paste JSON here to import..." 
                            class="json-textarea is-hidden"></textarea>
                        <div class="d-flex flex-gap-10 mt-10 d-none" id="therapistJsonButtons">
                            <button class="btn btn-success flex-1" onclick="therapistLoadJson()">‚úÖ Load JSON</button>
                            <button class="btn btn-danger flex-1" onclick="therapistCancelImport()">‚ùå Cancel</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üéµ Audio Configuration</h3>
                <div class="d-grid grid-gap-12">
                    <div>
                        <div class="mb-6">üéß Volume SFX</div>
                        <input id="mmSfxVol" type="range" min="0" max="100" value="70"
                            oninput="Audio.setSfxVolume(Number(this.value)/100)">
                    </div>

                    <div>
                        <div class="mb-6">üéµ Volume M√∫sica (preparado)</div>
                        <input id="mmMusicVol" type="range" min="0" max="100" value="40"
                            oninput="Audio.setMusicVolume(Number(this.value)/100)">
                    </div>

                    <div class="d-flex flex-gap-10 flex-wrap">
                        <button id="mmMuteBtn" class="btn w-auto" onclick="Audio.toggleMute()">üîä Som</button>
                        <button class="btn w-auto" onclick="Audio.playSfx('ui_click')">‚úÖ Testar som</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Data Management</h3>
                <button class="btn btn-success" onclick="exportData()">üì• Export All Data</button>
                <button class="btn btn-warning" onclick="importData()">üì§ Import Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
            </div>

            <div id="configPanel" class="card is-hidden">
                <h3>Advanced Configuration</h3>
                <div id="configEditor"></div>
            </div>
        </div>
    </div>

    <!-- ===== Feature 4.0 Overlays ===== -->
    <div id="mmIntro" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">üéÆ Monstrinhomon</div>
            <p class="mm-sub">RPG terap√™utico infantil (Pok√©mon + RPG).<br/>Clique para come√ßar.</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">‚ú® Iniciar</button>
            <p class="mm-hint">Dica: o jogo salva automaticamente em seu navegador.</p>
        </div>
    </div>

    <div id="mmMenu" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Menu Principal</div>
            <button id="mmBtnContinue" class="mm-btn" onclick="mmContinue()">üìñ Continuar</button>
            <button class="mm-btn" onclick="mmOpenSaves()">üìÇ Gerenciar Saves</button>
            <button class="mm-btn" onclick="mmOpenSlotPickerForNewGame()">üéÆ Novo Jogo</button>
            <button class="mm-btn" onclick="mmStartTutorial()">üéì Tutorial</button>
            <button class="mm-btn" onclick="mmShowConfig()">‚öôÔ∏è Configura√ß√µes</button>
            <button id="mmTherapistBtn" class="mm-btn is-hidden" onclick="mmOpenTherapistPanel()">üßë‚Äçüè´ Mestre</button>
            <div class="mm-row">
                <button class="mm-btn" onclick="mmCloseAllOverlays()">Fechar</button>
                <button class="mm-btn" onclick="mmResetSaveConfirm()">üóëÔ∏è Apagar Save</button>
            </div>
        </div>
    </div>

    <div id="mmNewGame" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Novo Jogo</div>

            <div id="mmNewGameStep"></div>

            <div class="mm-row">
                <button class="mm-btn" onclick="mmNewGameBack()">‚¨ÖÔ∏è Voltar</button>
                <button class="mm-btn" onclick="mmNewGameNext()">‚û°Ô∏è Pr√≥ximo</button>
            </div>
        </div>
    </div>

    <div id="mmSlotPicker" class="mm-overlay is-hidden">
        <div class="mm-card max-w-640">
            <div class="mm-title">üíæ Escolher Slot</div>
            <div class="opacity-90 mb-12">
                Selecione onde salvar este <b>Novo Jogo</b>. (Voc√™ pode exportar/importar depois.)
            </div>

            <div id="mmSlotPickerList" class="d-grid grid-gap-10"></div>

            <div class="d-flex flex-gap-10 flex-wrap mt-14">
                <button class="mm-btn w-auto" onclick="mmCancelSlotPicker()">‚Ü©Ô∏è Voltar</button>
            </div>
        </div>
    </div>

    <div id="mmConfig" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Configura√ß√µes</div>
            <p class="mm-sub">MVP: placeholder. (Depois entra volume, modo terapeuta, etc.)</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">Voltar</button>
        </div>
    </div>

    <!-- Feature 4.6: Therapist Mode Panel -->
    <div id="mmTherapist" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">üßë‚Äçüè´ Therapist Mode</div>
            <div id="mmTherapistBody"></div>

            <div class="mm-row mt-12">
                <button class="mm-btn" onclick="mmCloseAllOverlays()">Fechar</button>
            </div>
        </div>
    </div>

    <!-- Feature 4.3: Save Slots Screen -->
    <div id="mmSavesScreen" class="mm-overlay is-hidden">
        <div class="mm-card max-w-820">
            <div class="mm-title">üìÇ Gerenciar Saves</div>
            <div id="mmSavesSlots" class="d-grid grid-gap-12 mt-12 grid-cols-1"></div>

            <div class="d-flex flex-gap-10 flex-wrap mt-15">
                <label class="mm-btn w-auto d-inline-flex align-center flex-gap-8 cursor-pointer">
                    ‚¨ÜÔ∏è Importar JSON
                    <input id="mmImportFile" type="file" accept="application/json" class="d-none">
                </label>

                <select id="mmImportSlotPick" class="mm-input min-w-160">
                    <option value="1">Importar para Slot 1</option>
                    <option value="2">Importar para Slot 2</option>
                    <option value="3">Importar para Slot 3</option>
                </select>

                <button class="mm-btn w-auto" onclick="mmCloseSaves()">‚Ü©Ô∏è Voltar</button>
            </div>

            <div class="opacity-75 font-size-12 mt-10">
                Dica: Exportar/Importar √© ideal para backup e trocar de dispositivo (iPad).
            </div>
        </div>
    </div>

    <!-- Feature 4.1.1: Start Choice Modal -->
    <div id="mmStartChoice" class="mm-overlay is-hidden">
        <div class="mm-card">
            <h2 class="intro-title">üéÆ Come√ßar</h2>
            <p class="intro-subtitle">Quer fazer o <b>Tutorial</b> agora?</p>

            <label class="tutorial-choice-label">
                <input type="checkbox" id="mmRememberTutorialChoice">
                Lembrar minha escolha
            </label>

            <div class="d-flex flex-gap-12 justify-center flex-wrap">
                <button class="mm-btn" onclick="mmStartTutorialFromChoice()">üéì Fazer Tutorial</button>
                <button class="mm-btn opacity-90" onclick="mmSkipTutorialFromChoice()">üöÄ Pular</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import combat modules
        import Combat from './js/combat/index.js';
        
        // Import progression modules (PR8A)
        import Progression from './js/progression/index.js';
        
        // Import data modules (PR9B)
        import * as Data from './js/data/index.js';
        
        // Import UI modules (PR14B)
        import { showEggHatchModal, initEggHatchModal } from './js/ui/eggHatchModal.js';
        
        // PR16A: Import PartyDex module
        import * as PartyDex from './js/data/partyDex.js';
        
        // PR16B: Import PartyDex UI module
        import * as PartyDexUI from './js/ui/partyDexUI.js';
        
        // Make Combat available globally for the wrapper
        window.Combat = Combat;
        
        // Make Progression available globally (PR8A)
        window.Progression = Progression;
        
        // Make Data available globally (PR9B)
        window.Data = Data;
        
        // Make egg hatch modal available globally (PR14B)
        window.showEggHatchModal = showEggHatchModal;
        
        // PR16A: Make PartyDex available globally
        window.PartyDex = PartyDex;
        
        // Destructure groupCore for easier access
        const GroupCore = Combat.Group.Core;
        
        // GLOBAL ERROR HANDLER
        window.addEventListener('error', function(event) {
            showError(event.error || event.message, event.error?.stack || '');
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise Rejection: ' + event.reason, event.reason?.stack || '');
        });

        function showError(message, stack) {
            const panel = document.getElementById('errorPanel');
            const messageDiv = document.getElementById('errorMessage');
            messageDiv.innerHTML = `<strong>Error:</strong> ${message}<br><pre>${stack}</pre>`;
            panel.classList.add('show');
            console.error('Error caught:', message, stack);
        }

        function dismissError() {
            document.getElementById('errorPanel').classList.remove('show');
        }

        function copyError() {
            const text = document.getElementById('errorMessage').innerText;
            navigator.clipboard.writeText(text).catch(e => alert('Copy failed: ' + e));
        }

        // ===== Feature 4.4: Audio (MVP without audio files) =====
        const Audio = (() => {
            let ctx = null;
            let unlocked = false;

            // PR3: Load audio prefs via StorageManager
            let sfxVol = StorageManager.getAudioSfxVolume();
            let musVol = StorageManager.getAudioMusicVolume();
            let muted = StorageManager.getAudioMuted();

            function clamp01(v){ return isFinite(v) ? Math.max(0, Math.min(1, v)) : 0; }

            function init() {
                // Initialize UI with saved settings
                syncUI();
            }

            function ensureCtx() {
                // Lazy AudioContext creation - delays until first audio interaction
                if (!ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return null;
                    ctx = new AC();
                }
                return ctx;
            }

            async function unlock() {
                try {
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") await c.resume();
                    // iOS unlock: play a silent buffer
                    const o = c.createOscillator();
                    const g = c.createGain();
                    g.gain.value = 0.0001;
                    o.connect(g).connect(c.destination);
                    o.start();
                    o.stop(c.currentTime + 0.01);
                    unlocked = true;
                } catch {}
            }

            function setSfxVolume(v) {
                sfxVol = clamp01(v);
                StorageManager.setAudioSfxVolume(sfxVol); // PR3
                syncUI();
            }
            function setMusicVolume(v) {
                musVol = clamp01(v);
                StorageManager.setAudioMusicVolume(musVol); // PR3
                syncUI();
            }
            function toggleMute() {
                muted = !muted;
                StorageManager.setAudioMuted(muted); // PR3
                syncUI();
            }

            function playTone(freq, durMs, vol, type="sine") {
                try {
                    if (muted) return;
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") return; // not unlocked yet
                    const o = c.createOscillator();
                    const g = c.createGain();
                    o.type = type;
                    o.frequency.value = freq;
                    
                    // Clamp vol parameter to valid range
                    const clampedVol = Math.max(0, Math.min(1, vol));
                    g.gain.value = clampedVol * sfxVol;

                    o.connect(g).connect(c.destination);

                    const now = c.currentTime;
                    const dur = durMs / 1000;

                    // Envelope to avoid clicks
                    const safeGain = Math.max(0.0001, g.gain.value);
                    g.gain.setValueAtTime(0.0001, now);
                    g.gain.exponentialRampToValueAtTime(safeGain, now + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

                    o.start(now);
                    o.stop(now + dur + 0.02);
                } catch {}
            }

            // Helper to schedule multi-tone sounds using AudioContext timeline
            function playMultiTone(tones) {
                try {
                    if (muted) return;
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") return;
                    
                    const now = c.currentTime;
                    
                    for (const tone of tones) {
                        const startTime = now + (tone.delay || 0) / 1000;
                        const o = c.createOscillator();
                        const g = c.createGain();
                        o.type = tone.type || "sine";
                        o.frequency.value = tone.freq;
                        
                        const clampedVol = Math.max(0, Math.min(1, tone.vol));
                        const targetGain = clampedVol * sfxVol;
                        const safeGain = Math.max(0.0001, targetGain);
                        
                        o.connect(g).connect(c.destination);
                        
                        const dur = tone.durMs / 1000;
                        g.gain.setValueAtTime(0.0001, startTime);
                        g.gain.exponentialRampToValueAtTime(safeGain, startTime + 0.01);
                        g.gain.exponentialRampToValueAtTime(0.0001, startTime + dur);
                        
                        o.start(startTime);
                        o.stop(startTime + dur + 0.02);
                    }
                } catch {}
            }

            // Sound palette using synthesized tones (can be replaced with audio files in the future)
            function playSfx(name) {
                try {
                    if (muted) return;
                    // Each event uses distinct frequency/waveform combinations for audio differentiation
                    switch (name) {
                        case "ui_click":   
                            playTone(660, 60, 0.6, "square"); 
                            break;
                        case "hit":        
                            playTone(220, 80, 0.7, "sawtooth"); 
                            break;
                        case "miss":       
                            playTone(140, 120, 0.5, "triangle"); 
                            break;
                        case "crit":       
                            playMultiTone([
                                { freq: 880, durMs: 80, vol: 0.8, type: "square", delay: 0 },
                                { freq: 990, durMs: 80, vol: 0.7, type: "square", delay: 70 }
                            ]);
                            break;
                        case "heal":       
                            playMultiTone([
                                { freq: 523, durMs: 80, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 659, durMs: 80, vol: 0.5, type: "sine", delay: 90 }
                            ]);
                            break;
                        case "capture_ok": 
                            playMultiTone([
                                { freq: 784, durMs: 70, vol: 0.7, type: "sine", delay: 0 },
                                { freq: 988, durMs: 90, vol: 0.7, type: "sine", delay: 80 }
                            ]);
                            break;
                        case "capture_fail": 
                            playMultiTone([
                                { freq: 196, durMs: 90, vol: 0.7, type: "sawtooth", delay: 0 },
                                { freq: 164, durMs: 110, vol: 0.6, type: "sawtooth", delay: 90 }
                            ]);
                            break;
                        case "win":        
                            playMultiTone([
                                { freq: 659, durMs: 80, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 784, durMs: 90, vol: 0.6, type: "sine", delay: 90 },
                                { freq: 988, durMs: 120, vol: 0.6, type: "sine", delay: 190 }
                            ]);
                            break;
                        case "lose":       
                            playMultiTone([
                                { freq: 220, durMs: 120, vol: 0.7, type: "triangle", delay: 0 },
                                { freq: 196, durMs: 140, vol: 0.6, type: "triangle", delay: 120 }
                            ]);
                            break;
                        case "levelup":    
                            playMultiTone([
                                { freq: 740, durMs: 70, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 880, durMs: 90, vol: 0.7, type: "sine", delay: 80 }
                            ]);
                            break;
                        case "evolve":     
                            playMultiTone([
                                { freq: 523, durMs: 80, vol: 0.5, type: "sine", delay: 0 },
                                { freq: 659, durMs: 90, vol: 0.6, type: "sine", delay: 90 },
                                { freq: 784, durMs: 120, vol: 0.7, type: "sine", delay: 190 }
                            ]);
                            break;
                        default:           
                            playTone(440, 60, 0.4, "sine");
                    }
                } catch {}
            }

            function syncUI() {
                // Optional: only runs if elements exist
                const sfx = document.getElementById("mmSfxVol");
                const mus = document.getElementById("mmMusicVol");
                const mute = document.getElementById("mmMuteBtn");
                if (sfx) sfx.value = String(Math.round(sfxVol * 100));
                if (mus) mus.value = String(Math.round(musVol * 100));
                if (mute) mute.textContent = muted ? "üîá Mudo" : "üîä Som";
            }

            return { init, unlock, playSfx, setSfxVolume, setMusicVolume, toggleMute, syncUI };
        })();

        // Call once on boot
        Audio.init();

        // iOS unlock: first user gesture
        window.addEventListener("pointerdown", () => Audio.unlock(), { once: true });
        window.addEventListener("keydown", () => Audio.unlock(), { once: true });

        // STATE MANAGEMENT
        const GameState = {
            players: [],
            monsters: [],
            sessions: [],
            currentSession: null,
            currentEncounter: null,
            objectives: [],
            therapistMode: false, // Feature 4.6: Therapist Mode
            // PR15A: Shared Box (PC) System
            sharedBox: [],  // Array of { slotId, ownerPlayerId, monster }
            ui: {
                activePlayerId: null,      // Fallback active player for UI
                boxViewedPlayerId: null,   // Which player's page we're viewing
                boxPageIndex: 0            // Current page index
            },
            // COMMIT 4: Save versioning
            meta: {
                saveVersion: 1  // Current save format version
            },
            // FASE 1 POKEMON: Monstr√≥dex (Cat√°logo de Progresso)
            monstrodex: {
                seen: [],      // IDs de monstrinhos vistos
                captured: []   // IDs de monstrinhos capturados
            },
            // PR16A: PartyDex - Shared Dex for the entire party
            partyDex: {
                entries: {},   // { [templateId]: { seen: boolean, captured: boolean } }
                meta: {
                    lastMilestoneAwarded: 0  // Last milestone that was awarded (10, 20, 30, etc.)
                }
            },
            // PR16A: Party Money - Shared money pool for milestone rewards
            partyMoney: 0,
            // FASE 1 POKEMON: Livro de Conquistas (Estat√≠sticas)
            stats: {
                battlesWon: 0,
                battlesLost: 0,
                captureAttempts: 0,
                capturesSuccessful: 0,
                totalXpGained: 0,
                totalMoneyEarned: 0,
                currentWinStreak: 0,
                highestWinStreak: 0
            },
            config: {
                maxTeamSize: 6,
                maxLevel: 100,
                levelExpo: 1.5,
                battleXpBase: 15,
                captureModel: 'threshold_no_dice',
                // Vantagens de Classe (conforme GAME_RULES.md)
                classAdvantages: {
                    'Guerreiro': { strong: 'Ladino', weak: 'Curandeiro' },
                    'Ladino': { strong: 'Mago', weak: 'Guerreiro' },
                    'Mago': { strong: 'B√°rbaro', weak: 'Ladino' },
                    'B√°rbaro': { strong: 'Ca√ßador', weak: 'Mago' },
                    'Ca√ßador': { strong: 'Bardo', weak: 'B√°rbaro' },
                    'Bardo': { strong: 'Curandeiro', weak: 'Ca√ßador' },
                    'Curandeiro': { strong: 'Guerreiro', weak: 'Bardo' },
                    'Animalista': { strong: null, weak: null } // Neutro
                },
                // Thresholds de captura por raridade (sem dado)
                captureThreshold: {
                    'Comum': 0.35,
                    'Incomum': 0.30,
                    'Raro': 0.22,
                    'M√≠stico': 0.15,
                    'Lend√°rio': 0.08
                },
                // Multiplicadores de raridade
                rarityPower: {
                    'Comum': 1.00,
                    'Incomum': 1.08,
                    'Raro': 1.18,
                    'M√≠stico': 1.32,
                    'Lend√°rio': 1.50
                },
                rarityXP: {
                    'Comum': 1.00,
                    'Incomum': 1.05,
                    'Raro': 1.10,
                    'M√≠stico': 1.15,
                    'Lend√°rio': 1.25
                },
                // Chance base de fuga por raridade
                fleeBase: {
                    'Comum': 10,
                    'Incomum': 12,
                    'Raro': 15,
                    'M√≠stico': 18,
                    'Lend√°rio': 25
                },
                medalTiers: { bronze: 5, silver: 12, gold: 25 },
                // Sistema de Amizade (Friendship)
                // Valores balanceados para progress√£o saud√°vel:
                // - Vit√≥rias modestas (+2) para incentivar jogo ativo
                // - Derrotas penalizantes (-5) para criar stakes
                // - Cura generosa (+5) para recompensar cuidado
                // - Level up moderado (+3) para progress√£o natural
                // - Faint punitivo (-3) para ensinar cautela
                friendshipConfig: {
                    battleWin: 2,       // Ganhar batalha (moderado)
                    battleLoss: -5,     // Perder batalha (alto para ensinar cautela)
                    useHealItem: 5,     // Usar item de cura (alto para recompensar cuidado)
                    levelUp: 3,         // Subir de n√≠vel (moderado, progress√£o natural)
                    faint: -3           // Desmaiar (punitivo)
                }
            }
        };

        // ============================================================================
        // CONSTANTES DO SISTEMA DE AMIZADE
        // ============================================================================
        // Valor padr√£o de amizade (neutro) - Declarado aqui para estar dispon√≠vel
        // para todas as fun√ß√µes que o utilizam
        const DEFAULT_FRIENDSHIP = 50;

        // MONSTER CATALOG (baseado em MONSTROS.csv)
        const MONSTER_CATALOG = [
            { id: 'MON_001', name: 'Cantapau', class: 'Bardo', rarity: 'Comum', baseHp: 28, baseAtk: 6, baseDef: 4, baseSpd: 6, baseEne: 8, emoji: 'üéµ' },
            { id: 'MON_002', name: 'Pedrino', class: 'Guerreiro', rarity: 'Comum', baseHp: 32, baseAtk: 7, baseDef: 6, baseSpd: 5, baseEne: 6, emoji: '‚öîÔ∏è', evolvesTo: 'MON_002B', evolvesAt: 12 },
            { id: 'MON_002B', name: 'Pedronar', class: 'Guerreiro', rarity: 'Incomum', baseHp: 42, baseAtk: 10, baseDef: 8, baseSpd: 6, baseEne: 6, emoji: '‚öîÔ∏è', evolvesTo: 'MON_002C', evolvesAt: 25 },
            { id: 'MON_002C', name: 'Pedragon', class: 'Guerreiro', rarity: 'Raro', baseHp: 56, baseAtk: 14, baseDef: 11, baseSpd: 8, baseEne: 6, emoji: 'üó°Ô∏è' },
            { id: 'MON_003', name: 'Fa√≠scari', class: 'Mago', rarity: 'Comum', baseHp: 26, baseAtk: 8, baseDef: 3, baseSpd: 7, baseEne: 10, emoji: 'üîÆ' },
            { id: 'MON_004', name: 'Ninfolha', class: 'Curandeiro', rarity: 'Comum', baseHp: 30, baseAtk: 4, baseDef: 4, baseSpd: 5, baseEne: 12, emoji: 'üíö' },
            { id: 'MON_005', name: 'Garruncho', class: 'Ca√ßador', rarity: 'Comum', baseHp: 29, baseAtk: 7, baseDef: 3, baseSpd: 8, baseEne: 8, emoji: 'üèπ' },
            { id: 'MON_006', name: 'Lobinho', class: 'Animalista', rarity: 'Comum', baseHp: 31, baseAtk: 6, baseDef: 5, baseSpd: 5, baseEne: 7, emoji: 'üê∫' },
            { id: 'MON_007', name: 'Trov√£o', class: 'B√°rbaro', rarity: 'Comum', baseHp: 33, baseAtk: 8, baseDef: 4, baseSpd: 4, baseEne: 6, emoji: '‚ö°' },
            { id: 'MON_008', name: 'Sombrio', class: 'Ladino', rarity: 'Comum', baseHp: 27, baseAtk: 7, baseDef: 4, baseSpd: 8, baseEne: 6, emoji: 'üåë' },
            { id: 'MON_100', name: 'Rato-de-Lama', class: 'Guerreiro', rarity: 'Comum', baseHp: 20, baseAtk: 5, baseDef: 3, baseSpd: 4, baseEne: 4, emoji: 'üêÄ' }
        ];

        // ENE REGEN CONSTANTS por classe (fallback)
        const ENE_REGEN_BY_CLASS = {
            'Mago': { pct: 0.18, min: 3 },
            'Curandeiro': { pct: 0.18, min: 3 },
            'Bardo': { pct: 0.14, min: 2 },
            'Ca√ßador': { pct: 0.14, min: 2 },
            'Ladino': { pct: 0.14, min: 2 },
            'Animalista': { pct: 0.12, min: 2 },
            'B√°rbaro': { pct: 0.12, min: 2 },
            'Guerreiro': { pct: 0.10, min: 1 }
        };

        // POWER B√ÅSICO por classe (ataque sem habilidade)
        const BASIC_ATTACK_POWER = {
            'Guerreiro': 12,
            'Mago': 11,
            'Curandeiro': 10,
            'B√°rbaro': 14,
            'Ladino': 12,
            'Bardo': 11,
            'Ca√ßador': 13,
            'Animalista': 12
        };

        // SKILL DEFINITIONS (inline - por classe e est√°gio)
        const SKILL_DEFS = {
            // GUERREIRO
            'Guerreiro': {
                'Golpe de Espada': [
                    { tier: 1, name: 'Golpe de Espada I', type: 'DAMAGE', cost: 4, power: 18, desc: 'Ataque com espada.' },
                    { tier: 2, name: 'Golpe de Espada II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque forte com espada.' },
                    { tier: 3, name: 'Golpe de Espada III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque devastador com espada.' }
                ],
                'Escudo': [
                    { tier: 1, name: 'Escudo I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF temporariamente.' },
                    { tier: 2, name: 'Escudo II', type: 'BUFF', cost: 6, power: 3, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta muito a DEF.' },
                    { tier: 3, name: 'Escudo III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'self', duration: 3, desc: 'Escudo poderoso.' }
                ],
                'Provocar': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Provocar I', type: 'TAUNT', cost: 4, power: 0, desc: 'Provoca o inimigo.' },
                    { tier: 3, name: 'Provocar II', type: 'TAUNT', cost: 6, power: 0, desc: 'Provoca intensamente.' }
                ]
            },
            // CURANDEIRO
            'Curandeiro': {
                'Cura': [
                    { tier: 1, name: 'Cura I', type: 'HEAL', cost: 5, power: 15, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Cura II', type: 'HEAL', cost: 7, power: 25, target: 'ally', desc: 'Cura moderada.' },
                    { tier: 3, name: 'Cura III', type: 'HEAL', cost: 10, power: 40, target: 'ally', desc: 'Cura poderosa.' }
                ],
                'B√™n√ß√£o': [
                    { tier: 1, name: 'B√™n√ß√£o I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK do aliado.' },
                    { tier: 2, name: 'B√™n√ß√£o II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'B√™n√ß√£o III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'ally', duration: 3, desc: 'B√™n√ß√£o poderosa (DEF).' }
                ]
            },
            // MAGO
            'Mago': {
                'Magia Elemental': [
                    { tier: 1, name: 'Magia Elemental I', type: 'DAMAGE', cost: 4, power: 20, desc: 'Magia elemental.' },
                    { tier: 2, name: 'Magia Elemental II', type: 'DAMAGE', cost: 6, power: 26, desc: 'Magia elemental forte.' },
                    { tier: 3, name: 'Magia Elemental III', type: 'DAMAGE', cost: 8, power: 32, desc: 'Magia elemental poderosa.' }
                ],
                'Explos√£o Elemental': [
                    { tier: 1, name: 'Explos√£o Elemental I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Explos√£o m√°gica.' },
                    { tier: 2, name: 'Explos√£o Elemental II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Explos√£o m√°gica forte.' },
                    { tier: 3, name: 'Explos√£o Elemental III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Explos√£o devastadora.' }
                ]
            },
            // B√ÅRBARO
            'B√°rbaro': {
                'F√∫ria': [
                    { tier: 1, name: 'F√∫ria I', type: 'BUFF', cost: 4, power: 3, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -1, desc: 'Aumenta ATK, reduz DEF.' },
                    { tier: 2, name: 'F√∫ria II', type: 'BUFF', cost: 6, power: 4, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -2, desc: 'F√∫ria intensa.' },
                    { tier: 3, name: 'F√∫ria III', type: 'BUFF', cost: 8, power: 6, buffType: 'ATK', target: 'self', duration: 3, debuffType: 'DEF', debuffPower: -2, desc: 'F√∫ria selvagem.' }
                ],
                'Golpe Brutal': [
                    { tier: 1, name: 'Golpe Brutal I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Golpe brutal.' },
                    { tier: 2, name: 'Golpe Brutal II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Golpe muito brutal.' },
                    { tier: 3, name: 'Golpe Brutal III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Golpe devastador.' }
                ]
            },
            // LADINO
            'Ladino': {
                'Ataque Preciso': [
                    { tier: 1, name: 'Ataque Preciso I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Ataque preciso.' },
                    { tier: 2, name: 'Ataque Preciso II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque muito preciso.' },
                    { tier: 3, name: 'Ataque Preciso III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque extremamente preciso.' }
                ],
                'Enfraquecer': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Enfraquecer I', type: 'BUFF', cost: 4, power: -2, buffType: 'ATK', target: 'enemy', duration: 1, desc: 'Reduz ATK do inimigo.' },
                    { tier: 3, name: 'Enfraquecer II', type: 'BUFF', cost: 6, power: -3, buffType: 'ATK', target: 'enemy', duration: 2, desc: 'Enfraquece muito o inimigo.' }
                ]
            },
            // BARDO
            'Bardo': {
                'Can√ß√£o de Coragem': [
                    { tier: 1, name: 'Can√ß√£o de Coragem I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK.' },
                    { tier: 2, name: 'Can√ß√£o de Coragem II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'Can√ß√£o de Coragem III', type: 'BUFF', cost: 8, power: 4, buffType: 'ATK', target: 'ally', duration: 3, desc: 'Can√ß√£o inspiradora.' }
                ],
                'Can√ß√£o Calmante': [
                    { tier: 1, name: 'Can√ß√£o Calmante I', type: 'HEAL', cost: 5, power: 12, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Can√ß√£o Calmante II', type: 'BUFF', cost: 6, power: 2, buffType: 'DEF', target: 'ally', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 3, name: 'Can√ß√£o Calmante III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'ally', duration: 3, desc: 'Can√ß√£o protetora.' }
                ]
            },
            // CA√áADOR
            'Ca√ßador': {
                'Flecha Poderosa': [
                    { tier: 1, name: 'Flecha Poderosa I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Flecha poderosa.' },
                    { tier: 2, name: 'Flecha Poderosa II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Flecha muito poderosa.' },
                    { tier: 3, name: 'Flecha Poderosa III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Flecha devastadora.' }
                ],
                'Armadilha': [
                    null, // S0 n√£o tem
                    { tier: 2, name: 'Armadilha I', type: 'BUFF', cost: 4, power: -2, buffType: 'SPD', target: 'enemy', duration: 1, desc: 'Reduz SPD do inimigo.' },
                    { tier: 3, name: 'Armadilha II', type: 'BUFF', cost: 6, power: -3, buffType: 'SPD', target: 'enemy', duration: 2, desc: 'Armadilha poderosa.' }
                ]
            },
            // ANIMALISTA
            'Animalista': {
                'Investida Bestial': [
                    { tier: 1, name: 'Investida Bestial I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Investida feroz.' },
                    { tier: 2, name: 'Investida Bestial II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Investida muito feroz.' },
                    { tier: 3, name: 'Investida Bestial III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Investida selvagem.' }
                ],
                'Instinto Selvagem': [
                    { tier: 1, name: 'Instinto Selvagem I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 2, name: 'Instinto Selvagem II', type: 'BUFF', cost: 6, power: 2, buffType: 'SPD', target: 'self', duration: 2, desc: 'Aumenta SPD.' },
                    { tier: 3, name: 'Instinto Selvagem III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'self', duration: 3, desc: 'Instinto agu√ßado.' }
                ]
            }
        };

        // CLASTERORB TIERS (Sistema de captura em tiers)
        const CLASTERORBS = {
            'CLASTERORB_COMUM': { id: 'CLASTERORB_COMUM', name: 'ClasterOrb Comum', type: 'CAPTURE', capture_bonus_pp: 0, emoji: '‚ö™' },
            'CLASTERORB_INCOMUM': { id: 'CLASTERORB_INCOMUM', name: 'ClasterOrb Incomum', type: 'CAPTURE', capture_bonus_pp: 5, emoji: 'üîµ' },
            'CLASTERORB_RARA': { id: 'CLASTERORB_RARA', name: 'ClasterOrb Rara', type: 'CAPTURE', capture_bonus_pp: 10, emoji: 'üü£' }
        };

        // ============================================================================
        // Commit 12 (Wave C12.3): Centralized Auxiliary Tables - Single Source of Truth
        // ============================================================================

        /**
         * MM_TABLES - Central repository for all enums, constants, and lookup helpers
         * 
         * Purpose:
         * - Eliminate hardcoded arrays/values scattered throughout code
         * - Provide single source of truth for UI labels, enums, and lookups
         * - Enable easy validation and consistent behavior
         * 
         * Structure:
         * - ENUMS: Arrays of valid values (classes, rarities, states)
         * - UI_MAPS: Visual representations (emojis, colors, labels)
         * - LOOKUPS: Helper functions referencing GameState.config
         * - VALIDATORS: Validation functions for enums
         */
        const MM_TABLES = {
            // ========================================================================
            // ENUMS - Definitive lists of valid values
            // ========================================================================
            
            CLASSES: [
                'Guerreiro',
                'Mago', 
                'Curandeiro',
                'B√°rbaro',
                'Ladino',
                'Bardo',
                'Ca√ßador',
                'Animalista'
            ],
            
            RARITIES: [
                'Comum',
                'Incomum',
                'Raro',
                'M√≠stico',
                'Lend√°rio'
            ],
            
            MONSTER_STATES: [
                'healthy',
                'fainted',
                'poisoned',
                'paralyzed',
                'asleep',
                'confused'
            ],
            
            // ========================================================================
            // UI MAPS - Visual representations and labels
            // ========================================================================
            
            CLASS_EMOJI: {
                'Guerreiro': '‚öîÔ∏è',
                'Mago': 'üîÆ',
                'Curandeiro': 'üíö',
                'B√°rbaro': '‚ö°',
                'Ladino': 'üåë',
                'Bardo': 'üéµ',
                'Ca√ßador': 'üèπ',
                'Animalista': 'üê∫'
            },
            
            RARITY_EMOJI: {
                'Comum': '‚ö™',
                'Incomum': 'üîµ',
                'Raro': 'üü£',
                'M√≠stico': '‚ú®',
                'Lend√°rio': 'üëë'
            },
            
            RARITY_COLOR: {
                'Comum': '#808080',      // Gray
                'Incomum': '#1E90FF',    // Blue
                'Raro': '#9370DB',       // Purple
                'M√≠stico': '#FFD700',    // Gold
                'Lend√°rio': '#FF4500'    // Red-Orange
            },
            
            // ========================================================================
            // COMBAT CONSTANTS - Moved from scattered locations
            // ========================================================================
            
            BASIC_ATTACK_POWER: {
                'Guerreiro': 12,
                'Mago': 11,
                'Curandeiro': 10,
                'B√°rbaro': 14,
                'Ladino': 12,
                'Bardo': 11,
                'Ca√ßador': 13,
                'Animalista': 12
            },
            
            ENERGY_REGEN: {
                'Mago': { pct: 0.18, min: 3 },
                'Curandeiro': { pct: 0.18, min: 3 },
                'Bardo': { pct: 0.14, min: 2 },
                'Ca√ßador': { pct: 0.14, min: 2 },
                'Ladino': { pct: 0.14, min: 2 },
                'Animalista': { pct: 0.12, min: 2 },
                'B√°rbaro': { pct: 0.12, min: 2 },
                'Guerreiro': { pct: 0.10, min: 1 }
            },
            
            // ========================================================================
            // LOOKUP HELPERS - Access GameState.config with fallbacks
            // ========================================================================
            
            /**
             * Get class advantage info (strong/weak matchups)
             */
            getClassAdvantage: function(attackerClass) {
                if (!attackerClass) return null;
                return GameState.config?.classAdvantages?.[attackerClass] || null;
            },
            
            /**
             * Get rarity multiplier (power, XP, etc.)
             */
            getRarityMultiplier: function(rarity, type = 'power') {
                if (!rarity) return 1.0;
                
                const config = GameState.config;
                if (type === 'power') {
                    return config?.rarityPower?.[rarity] || 1.0;
                } else if (type === 'xp') {
                    return config?.rarityXP?.[rarity] || 1.0;
                }
                return 1.0;
            },
            
            /**
             * Get basic attack power for a class
             */
            getBasicAttackPower: function(monsterClass) {
                if (!monsterClass) return 12; // Default fallback
                return this.BASIC_ATTACK_POWER[monsterClass] || 12;
            },
            
            /**
             * Get energy regeneration config for a class
             */
            getEnergyRegen: function(monsterClass) {
                if (!monsterClass) return { pct: 0.10, min: 1 };
                return this.ENERGY_REGEN[monsterClass] || { pct: 0.10, min: 1 };
            },
            
            /**
             * Get capture threshold for a rarity
             */
            getCaptureThreshold: function(rarity) {
                if (!rarity) return 0.35; // Default to Comum
                return GameState.config?.captureThreshold?.[rarity] || 0.35;
            },
            
            /**
             * Get flee chance base for a rarity
             */
            getFleeBase: function(rarity) {
                if (!rarity) return 10; // Default to Comum
                return GameState.config?.fleeBase?.[rarity] || 10;
            },
            
            // ========================================================================
            // VALIDATORS - Check if values are valid
            // ========================================================================
            
            /**
             * Validate class name
             */
            validateClass: function(className) {
                if (!className) return false;
                return this.CLASSES.includes(className);
            },
            
            /**
             * Validate rarity name
             */
            validateRarity: function(rarityName) {
                if (!rarityName) return false;
                return this.RARITIES.includes(rarityName);
            },
            
            /**
             * Validate monster state
             */
            validateState: function(stateName) {
                if (!stateName) return false;
                return this.MONSTER_STATES.includes(stateName);
            },
            
            /**
             * Get class emoji with fallback
             */
            getClassEmoji: function(className) {
                return this.CLASS_EMOJI[className] || 'üëæ';
            },
            
            /**
             * Get rarity emoji with fallback
             */
            getRarityEmoji: function(rarityName) {
                return this.RARITY_EMOJI[rarityName] || '‚ö™';
            },
            
            /**
             * Get rarity color with fallback
             */
            getRarityColor: function(rarityName) {
                return this.RARITY_COLOR[rarityName] || '#808080';
            }
        };

        // ============================================================================
        // End of Commit 12 (Wave C12.3)
        // ============================================================================

        // SKILLS CATALOG (baseado em HABILIDADES.csv)
        const SKILLS_CATALOG = [
            // Tier I skills (original)
            { id: 'SK_WAR_01', name: 'Golpe de Escudo', class: 'Guerreiro', category: 'Controle', power: 6, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: 'Atordoado', desc: 'Ataque curto com chance de atordoar.' },
            { id: 'SK_WAR_02', name: 'Corte Pesado', class: 'Guerreiro', category: 'Ataque', power: 9, accuracy: 0.8, energy_cost: 3, target: 'Inimigo', status: '', desc: 'Dano alto, menos preciso.' },
            { id: 'SK_MAG_01', name: 'Raio M√≠stico', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Dano m√°gico √† dist√¢ncia.' },
            { id: 'SK_MAG_02', name: 'N√©voa Lenta', class: 'Mago', category: 'Controle', power: 4, accuracy: 0.9, energy_cost: 3, target: '√Årea', status: 'Enraizado', desc: 'Reduz a√ß√£o/movimento por 1 turno.' },
            { id: 'SK_HEA_01', name: 'Sopro Calmante', class: 'Curandeiro', category: 'Cura', power: 0, accuracy: 1, energy_cost: 4, target: 'Aliado', status: '', desc: 'Cura moderada.' },
            { id: 'SK_HEA_02', name: 'Barreira Suave', class: 'Curandeiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Aliado', status: 'Protegido', desc: 'Aumenta defesa por 2 turnos.' },
            { id: 'SK_HUN_01', name: 'Flecha R√°pida', class: 'Ca√ßador', category: 'Ataque', power: 8, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: '', desc: 'Dano consistente √† dist√¢ncia.' },
            { id: 'SK_BRD_01', name: 'Can√ß√£o de Coragem', class: 'Bardo', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: '√Årea', status: 'Fortalecido', desc: 'Buff de ataque para aliados.' },
            
            // Feature 3.6: Tier I/II/III variants for testing
            { id: 'GOLPE_ESPADA_I', name: 'Golpe de Espada I', class: 'Guerreiro', category: 'Ataque', power: 8, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Ataque de espada b√°sico.' },
            { id: 'GOLPE_ESPADA_II', name: 'Golpe de Espada II', class: 'Guerreiro', category: 'Ataque', power: 12, accuracy: 0.85, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de espada aprimorado.' },
            { id: 'GOLPE_ESPADA_III', name: 'Golpe de Espada III', class: 'Guerreiro', category: 'Ataque', power: 18, accuracy: 0.85, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de espada mestre.' },
            
            { id: 'ESCUDO_I', name: 'Escudo I', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 4, target: 'Self', status: 'Protegido', desc: 'Defesa b√°sica.' },
            { id: 'ESCUDO_II', name: 'Escudo II', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 5, target: 'Self', status: 'Protegido', desc: 'Defesa aprimorada.' },
            { id: 'ESCUDO_III', name: 'Escudo III', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 6, target: 'Self', status: 'Protegido', desc: 'Defesa mestre.' },
            
            { id: 'BOLA_FOGO_I', name: 'Bola de Fogo I', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.9, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de fogo b√°sico.' },
            { id: 'BOLA_FOGO_II', name: 'Bola de Fogo II', class: 'Mago', category: 'Ataque', power: 15, accuracy: 0.9, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de fogo aprimorado.' },
            { id: 'BOLA_FOGO_III', name: 'Bola de Fogo III', class: 'Mago', category: 'Ataque', power: 22, accuracy: 0.9, energy_cost: 8, target: 'Inimigo', status: '', desc: 'Ataque de fogo mestre.' }
        ];

        // CLASS ENERGY REGEN (baseado em CLASSES.csv)
        const CLASS_ENERGY_REGEN = {
            'Guerreiro': { ene_regen_pct: 0.10, ene_regen_min: 2 },
            'Mago': { ene_regen_pct: 0.25, ene_regen_min: 1 },
            'Curandeiro': { ene_regen_pct: 0.20, ene_regen_min: 2 },
            'B√°rbaro': { ene_regen_pct: 0.10, ene_regen_min: 1 },
            'Ladino': { ene_regen_pct: 0.15, ene_regen_min: 1 },
            'Bardo': { ene_regen_pct: 0.18, ene_regen_min: 2 },
            'Ca√ßador': { ene_regen_pct: 0.12, ene_regen_min: 2 },
            'Animalista': { ene_regen_pct: 0.15, ene_regen_min: 2 }
        };

        // DEFAULT OBJECTIVES
        const DEFAULT_OBJECTIVES = [
            { id: 1, text: 'Followed group rules', weight: 2 },
            { id: 2, text: 'Waited for turn patiently', weight: 3 },
            { id: 3, text: 'Helped another player', weight: 3 },
            { id: 4, text: 'Used calm voice throughout', weight: 2 },
            { id: 5, text: 'Made good eye contact', weight: 1 },
            { id: 6, text: 'Shared materials/ideas', weight: 2 }
        ];

        // ============================================================================
        // Commit 12 (Wave C12.1): Catalog Lookup Helpers - Single Source of Truth
        // ============================================================================

        /**
         * Get monster template from JSON (if available) or MONSTER_CATALOG (fallback)
         * PR9B: Tries JSON first (sync lookup), falls back to hardcoded if not found
         * @param {string} templateId - Monster template ID (e.g., 'MON_001')
         * @returns {Object|null} Monster template or null if not found
         */
        function getMonsterTemplate(templateId) {
            if (!templateId) return null;
            
            // PR9B: Try JSON first (synchronous lookup, no blocking)
            if (window.Data && window.Data.getMonstersMapSync) {
                const monstersMap = window.Data.getMonstersMapSync();
                if (monstersMap && monstersMap.has(templateId)) {
                    // Deep clone to prevent cache mutation
                    const template = monstersMap.get(templateId);
                    return JSON.parse(JSON.stringify(template));
                }
            }
            
            // Fallback: hardcoded MONSTER_CATALOG
            return MONSTER_CATALOG.find(m => m.id === templateId) || null;
        }

        /**
         * Require monster template from catalog with validation and logging
         * @param {string} templateId - Monster template ID
         * @param {string} context - Context string for logging (e.g., 'awardMonster', 'encounterSpawn')
         * @returns {Object|null} Monster template or null if not found (logs warning)
         */
        function requireMonsterTemplate(templateId, context = 'unknown') {
            const template = getMonsterTemplate(templateId);
            
            if (!template) {
                // Commit 13 (Wave 13.2): Use mmDebugLog for standardized logging
                mmDebugLog("CATALOG_ID_INVALID", {
                    context,
                    templateId,
                    catalogType: 'MONSTER_CATALOG'
                }, "warn");
            }
            
            return template;
        }

        /**
         * Get item definition from catalogs (CLASTERORBS, healing items, etc.)
         * @param {string} itemId - Item ID (e.g., 'CLASTERORB_COMUM', 'IT_HEAL_01')
         * @returns {Object|null} Item definition or null if not found
         */
        function getItemDef(itemId) {
            if (!itemId) return null;
            
            // Check CLASTERORBS first
            if (CLASTERORBS[itemId]) {
                return CLASTERORBS[itemId];
            }
            
            // Fallback for legacy healing items
            if (itemId === 'IT_HEAL_01') {
                return {
                    id: 'IT_HEAL_01',
                    name: 'Petisco de Cura',
                    type: 'HEAL',
                    heal_pct: 0.30,
                    emoji: 'üíö'
                };
            }
            
            return null;
        }

        /**
         * Require item definition from catalog with validation and logging
         * @param {string} itemId - Item ID
         * @param {string} context - Context string for logging
         * @returns {Object|null} Item definition or null if not found (logs warning)
         */
        function requireItemDef(itemId, context = 'unknown') {
            const itemDef = getItemDef(itemId);
            
            if (!itemDef) {
                // Commit 13 (Wave 13.2): Use mmDebugLog for standardized logging
                mmDebugLog("ITEM_INVALID", {
                    context,
                    itemId,
                    catalogType: 'ITEMS'
                }, "warn");
            }
            
            return itemDef;
        }

        // ============================================================================
        // INITIALIZATION
        function init() {
            try {
                loadFromLocalStorage();
                
                // PR3: Restore therapist mode state via StorageManager
                if (typeof GameState.therapistMode !== "boolean") {
                    GameState.therapistMode = StorageManager.getTherapistMode();
                }
                
                if (!GameState.objectives || GameState.objectives.length === 0) {
                    GameState.objectives = [...DEFAULT_OBJECTIVES];
                }
                
                // PR9B: Preload monsters from JSON in background (non-blocking)
                if (window.Data && window.Data.loadMonsters) {
                    window.Data.loadMonsters().catch(() => {
                        // Errors already logged by DataLoader, silently continue with hardcoded fallback
                    });
                }
                
                // PR10B: Preload skills from JSON in background (non-blocking)
                if (window.Data && window.Data.loadSkills) {
                    window.Data.loadSkills().catch(() => {
                        // Errors already logged by SkillsLoader, silently continue with hardcoded fallback
                    });
                }
                
                // PR12A: Preload items from JSON in background (non-blocking)
                if (window.Data && window.Data.loadItems) {
                    window.Data.loadItems().then(items => {
                        window.itemsData = items;
                        console.log(`[Shop] Loaded ${items.length} items for shop`);
                    }).catch(() => {
                        // Errors already logged by ItemsLoader, silently continue
                        window.itemsData = [];
                    });
                }
                
                // PR14B: Initialize egg hatch modal
                if (window.showEggHatchModal) {
                    console.log('[Init] Egg hatch modal loaded successfully');
                }
                
                updateAllViews();
                mmUpdateTherapistUI(); // Update therapist mode UI
                
                console.log('Monstrinhomon initialized successfully');
            } catch (error) {
                showError('Initialization failed', error.stack);
            }
        }

        // LOCAL STORAGE
        // COMMIT 4: Save Migration System
        // Version ladder: migrate old saves to current format
        /**
         * Aplica migra√ß√µes sequenciais sem perder dados extras.
         * HARDENED: Preserva campos existentes em meta (n√£o sobrescreve).
         */
        function migrateSaveIfNeeded(saveObj) {
            if (!saveObj || typeof saveObj !== 'object') {
                return saveObj;
            }
            
            // Garantir que meta exista sem apagar dados existentes
            saveObj.meta = saveObj.meta || {};
            
            // Determine current version (default to 0 for old saves)
            const currentVersion = saveObj.meta.saveVersion || 0;
            const targetVersion = 1;  // Current version
            
            if (currentVersion >= targetVersion) {
                // Already at current version
                return saveObj;
            }
            
            console.log(`[Migration] Migrating save from version ${currentVersion} to ${targetVersion}`);
            
            // Migration ladder
            let migratedSave = saveObj;
            
            // Migrate from version 0 to 1
            if (currentVersion < 1) {
                // Version 0 -> 1: Update saveVersion (preserving other meta fields)
                migratedSave.meta.saveVersion = 1;
                
                // Add timestamp if not present
                if (!migratedSave.meta.lastSaveDate) {
                    migratedSave.meta.lastSaveDate = new Date().toISOString();
                }
                
                // Ensure therapistMode exists
                if (migratedSave.therapistMode === undefined) {
                    migratedSave.therapistMode = false;
                }
                
                // Garantir arrays essenciais
                migratedSave.players = Array.isArray(migratedSave.players) ? migratedSave.players : [];
                migratedSave.monsters = Array.isArray(migratedSave.monsters) ? migratedSave.monsters : [];
                migratedSave.sessions = Array.isArray(migratedSave.sessions) ? migratedSave.sessions : [];
                
                // PR16A: Ensure PartyDex and partyMoney exist
                if (window.PartyDex) {
                    window.PartyDex.ensurePartyDex(migratedSave);
                    window.PartyDex.ensurePartyMoney(migratedSave);
                    console.log('[Migration] PR16A: PartyDex and partyMoney initialized');
                }
                
                console.log('[Migration] Applied v0->v1: Added meta.saveVersion (preserved existing meta fields)');
            }
            
            // Future migrations would go here:
            // if (currentVersion < 2) { ... }
            // if (currentVersion < 3) { ... }
            
            return migratedSave;
        }

        // COMMIT 5: Canonical Monster Schema + Normalization
        /**
         * Canonical monster fields (the ONE source of truth):
         * - hp: current HP
         * - hpMax: maximum HP
         * - ene: current ENE
         * - eneMax: maximum ENE
         * - level: current level
         * - xp: current XP
         * - buffs: array of active buffs
         * - templateId: ID from catalog (formerly monsterId)
         * - instanceId: unique instance ID (formerly id)
         * - class: monster class
         * - rarity: monster rarity
         * 
         * HARDENED (Bug-proof):
         * - Uses ?? (nullish coalescing) to accept 0 as valid value
         * - Prefers fields with valid values
         * - Clamps hp/ene to max (prevents over-heal bugs)
         * - Deletes legacy fields after migration
         * - Idempotent: safe to run multiple times
         */
        function normalizeMonster(mon) {
            if (!mon || typeof mon !== 'object') return null;
            
            // --- 1. Identificadores ---
            // Prioridade: templateId > monsterId > baseId > idBase
            mon.templateId = mon.templateId ?? mon.monsterId ?? mon.baseId ?? mon.idBase ?? 'unknown';
            // Remove campos legados para evitar confus√£o futura
            delete mon.monsterId;
            delete mon.baseId;
            delete mon.idBase;
            
            // instanceId (formerly just 'id')
            if (mon.id !== undefined && mon.instanceId === undefined) {
                mon.instanceId = mon.id;
            }
            
            // --- 2. Stats M√°ximos (A √¢ncora da verdade) ---
            // Prioridade: hpMax > maxHp > c√°lculo fallback
            if (mon.hpMax === undefined) {
                mon.hpMax = mon.maxHp ?? calculateMaxHpFallback(mon.level);
            }
            // Remove legado
            delete mon.maxHp;
            
            // --- 3. Stats Atuais (Com clamping) ---
            // Prioridade: hp > currentHp > hpCurrent > hpMax (full heal se perdido)
            // Usa ?? para aceitar 0 como valor v√°lido
            let rawHp = mon.hp ?? mon.currentHp ?? mon.hpCurrent ?? mon.hpMax;
            
            // Regra de Ouro: HP nunca pode ser > hpMax nem < 0
            const safeHpMax = Number(mon.hpMax) || 30;
            mon.hp = Math.min(Math.max(0, Number(rawHp) || 0), safeHpMax);
            
            // Limpeza legado
            delete mon.currentHp;
            delete mon.hpCurrent;
            
            // --- 4. ENE (Energia) ---
            // Calcular eneMax baseado em n√≠vel (se n√£o existir)
            if (mon.eneMax === undefined) {
                const baseEne = 10;
                const eneGrowth = 2;
                const lvl = mon.level || 1;
                mon.eneMax = Math.floor(baseEne + eneGrowth * (lvl - 1));
            }
            
            // Prioridade: ene > currentEne > eneMax
            let rawEne = mon.ene ?? mon.currentEne ?? mon.eneMax;
            const safeEneMax = Number(mon.eneMax) || 10;
            mon.ene = Math.min(Math.max(0, Number(rawEne) || 0), safeEneMax);
            
            // Limpeza legado
            delete mon.currentEne;
            
            // --- 5. Garantias Estruturais ---
            // Ensure required fields exist
            if (mon.level === undefined) mon.level = 1;
            if (mon.xp === undefined) mon.xp = 0;
            
            // Ensure arrays exist
            if (!Array.isArray(mon.buffs)) {
                mon.buffs = [];
            }
            if (!Array.isArray(mon.statusEffects)) {
                mon.statusEffects = [];
            }
            
            // Ensure class and rarity exist
            if (!mon.class) mon.class = 'Neutro';
            if (!mon.rarity) mon.rarity = 'Comum';
            
            // --- 6. Sistema de Amizade ---
            // Inicializar friendship se n√£o existir (padr√£o: neutro)
            if (typeof mon.friendship !== 'number') {
                mon.friendship = DEFAULT_FRIENDSHIP;
            }
            // Garantir que est√° no range v√°lido (0-100)
            mon.friendship = Math.max(0, Math.min(100, mon.friendship));
            
            return mon;
        }
        
        /**
         * Helper: Calcula HP m√°ximo fallback baseado em n√≠vel
         * (usado quando n√£o temos acesso ao catalog)
         */
        function calculateMaxHpFallback(level) {
            const baseHp = 30;
            const growthPerLevel = 5;
            const lvl = level || 1;
            return baseHp + (growthPerLevel * (lvl - 1));
        }

        // ============================================================================
        // SISTEMA DE AMIZADE (FRIENDSHIP) - Fun√ß√µes
        // ============================================================================

        /**
         * Atualiza o n√≠vel de amizade de um monstrinho
         * @param {Object} monster - Inst√¢ncia do monstrinho
         * @param {string} event - Evento que dispara mudan√ßa de amizade
         * @param {boolean} autoSave - Se deve salvar automaticamente (default: true)
         */
        function updateFriendship(monster, event, autoSave = true) {
            if (!monster || typeof monster !== 'object') return;
            
            // Inicializar friendship se n√£o existir
            if (typeof monster.friendship !== 'number') {
                monster.friendship = DEFAULT_FRIENDSHIP;
            }
            
            const config = GameState.config?.friendshipConfig;
            if (!config) {
                console.warn('[Friendship] Config n√£o encontrado');
                return;
            }
            
            const change = config[event] || 0;
            const oldFriendship = monster.friendship;
            
            // Aplicar mudan√ßa (clamped entre 0-100)
            monster.friendship = Math.max(0, Math.min(100, monster.friendship + change));
            
            // Log de mensagens especiais ao atingir marcos importantes
            const encounter = GameState.currentEncounter;
            const log = encounter?.log || [];
            
            if (monster.friendship === 100 && oldFriendship < 100) {
                if (Array.isArray(log)) {
                    log.push(`üíñ ${monster.nickname || monster.name} atingiu amizade m√°xima!`);
                }
            } else if (monster.friendship >= 75 && oldFriendship < 75) {
                if (Array.isArray(log)) {
                    log.push(`üíö ${monster.nickname || monster.name} est√° muito feliz!`);
                }
            } else if (monster.friendship >= 50 && oldFriendship < 50) {
                if (Array.isArray(log)) {
                    log.push(`üíõ ${monster.nickname || monster.name} est√° se aproximando de voc√™!`);
                }
            }
            
            if (autoSave) {
                saveToLocalStorage();
            }
        }

        /**
         * Atualiza m√∫ltiplos eventos de amizade de uma vez (batch)
         * √ötil para evitar m√∫ltiplas chamadas de save quando v√°rios eventos ocorrem juntos
         * @param {Object} monster - Inst√¢ncia do monstrinho
         * @param {Array<string>} events - Array de eventos (ex: ['faint', 'battleLoss'])
         */
        function updateMultipleFriendshipEvents(monster, events) {
            if (!monster || !Array.isArray(events)) return;
            
            // Aplicar todos os eventos sem salvar
            events.forEach(event => updateFriendship(monster, event, false));
            
            // Salvar apenas uma vez no final
            saveToLocalStorage();
        }

        /**
         * Retorna o n√≠vel de amizade (1-5)
         * @param {number} friendship - Valor de amizade (0-100)
         * @returns {number} - N√≠vel de 1 a 5
         */
        function getFriendshipLevel(friendship) {
            if (friendship >= 100) return 5;
            if (friendship >= 75) return 4;
            if (friendship >= 50) return 3;
            if (friendship >= 25) return 2;
            return 1;
        }

        /**
         * Retorna emoji representando n√≠vel de amizade
         * @param {number} friendship - Valor de amizade (0-100)
         * @returns {string} - Emoji de cora√ß√£o
         */
        function getFriendshipIcon(friendship) {
            const level = getFriendshipLevel(friendship);
            const icons = ['üñ§', 'ü§ç', 'üíõ', 'üíö', '‚ù§Ô∏è'];
            return icons[level - 1];
        }

        /**
         * Calcula b√¥nus baseados no n√≠vel de amizade
         * @param {number} friendship - Valor de amizade (0-100)
         * @returns {Object} - Objeto com b√¥nus aplic√°veis
         */
        function getFriendshipBonuses(friendship) {
            const level = getFriendshipLevel(friendship);
            const bonuses = {
                xpMultiplier: 1.0,
                critChance: 0,
                statBonus: 0,
                surviveChance: 0
            };
            
            // Progress√£o gradual de b√¥nus por n√≠vel
            if (level >= 2) {
                bonuses.xpMultiplier = 1.05; // +5% XP
            }
            if (level >= 3) {
                bonuses.critChance = 0.05;   // +5% cr√≠tico
            }
            if (level >= 4) {
                bonuses.xpMultiplier = 1.10; // +10% XP (upgrade do n√≠vel 2)
                bonuses.statBonus = 1;       // +1 stats
            }
            if (level >= 5) {
                // Nota: Mec√¢nica de sobreviv√™ncia n√£o implementada ainda.
                // Quando implementar, verificar surviveChance no momento do faint
                // e dar 10% de chance de sobreviver com 1 HP.
                bonuses.surviveChance = 0; // Desabilitado at√© implementa√ß√£o
            }
            
            return bonuses;
        }

        /**
         * Helper: Formata percentual de b√¥nus de amizade para exibi√ß√£o
         * @param {number} multiplier - Multiplicador de XP (ex: 1.05)
         * @returns {number} - Percentual arredondado (ex: 5)
         */
        function formatFriendshipBonusPercent(multiplier) {
            return Math.round((multiplier - 1) * 100);
        }

        // COMMIT 6: normalizeGameState()
        /**
         * Garante estrutura e tipos do save carregado.
         * 
         * O QUE FAZ:
         * - Valida que state √© objeto
         * - Garante meta, players, party, storage, inventory, flags existem com tipos corretos
         * - Chama normalizeMonster() em todos os monstros
         * 
         * O QUE N√ÉO FAZ:
         * - N√£o recalcula level, XP, stats, economia
         * - N√£o sobrescreve meta existente (apenas garante tipo)
         * - N√£o faz over-correction (normalizeMonster j√° faz)
         * - N√£o √© respons√°vel por migra√ß√£o (migrateSaveIfNeeded j√° faz)
         */
        function normalizeGameState(state) {
            // Se state n√£o √© objeto v√°lido, retorna estado default seguro
            if (!state || typeof state !== 'object' || Array.isArray(state)) {
                console.warn('[System] Invalid state structure, using default');
                return {
                    players: [],
                    monsters: [],
                    sessions: [],
                    currentSession: null,
                    currentEncounter: null,
                    objectives: [],
                    therapistMode: false,
                    meta: {
                        saveVersion: 1
                    },
                    config: {} // Config will be merged from GameState defaults
                };
            }
            
            // Garantir meta √© objeto (preservando keys existentes)
            if (!state.meta || typeof state.meta !== 'object' || Array.isArray(state.meta)) {
                console.warn('[System] Invalid meta, resetting to default');
                state.meta = { saveVersion: 1 };
            } else if (state.meta.saveVersion === undefined) {
                // Only set version if missing (don't overwrite existing version)
                state.meta.saveVersion = 1;
            }
            
            // Garantir players √© array
            if (!Array.isArray(state.players)) {
                console.warn('[System] Invalid players structure, resetting to []');
                state.players = [];
            }
            
            // Garantir monsters √© array (global list)
            if (!Array.isArray(state.monsters)) {
                console.warn('[System] Invalid monsters structure, resetting to []');
                state.monsters = [];
            }
            
            // Garantir sessions √© array
            if (!Array.isArray(state.sessions)) {
                state.sessions = [];
            }
            
            // Garantir objectives √© array
            if (!Array.isArray(state.objectives)) {
                state.objectives = [];
            }
            
            // PR15A: Garantir sharedBox √© array
            if (!Array.isArray(state.sharedBox)) {
                state.sharedBox = [];
            }
            
            // PR15A: Garantir ui √© objeto
            if (!state.ui || typeof state.ui !== 'object' || Array.isArray(state.ui)) {
                state.ui = {
                    activePlayerId: null,
                    boxViewedPlayerId: null,
                    boxPageIndex: 0
                };
            }
            
            // Normalizar cada jogador
            if (state.players) {
                state.players.forEach(player => {
                    if (!player || typeof player !== 'object') return;
                    
                    // Garantir team √© array
                    if (!Array.isArray(player.team)) {
                        player.team = [];
                    }
                    
                    // Garantir box √© array
                    if (!Array.isArray(player.box)) {
                        player.box = [];
                    }
                    
                    // Garantir inventory √© objeto
                    if (!player.inventory || typeof player.inventory !== 'object' || Array.isArray(player.inventory)) {
                        player.inventory = {};
                    }
                    
                    // Normalizar monstros no team
                    if (player.team) {
                        player.team.forEach(monster => {
                            if (!monster) return;
                            normalizeMonster(monster);
                        });
                    }
                    
                    // Normalizar monstros no box (old per-player box)
                    if (player.box) {
                        player.box.forEach(monster => {
                            if (!monster) return;
                            normalizeMonster(monster);
                        });
                    }
                });
            }
            
            // PR15A: Normalizar monstros na sharedBox
            if (state.sharedBox) {
                state.sharedBox.forEach(slot => {
                    if (slot && slot.monster) {
                        normalizeMonster(slot.monster);
                    }
                });
            }
            
            return state;
        }

        // COMMIT 3: Centralized Persistence Layer
        // PR3: All localStorage access now goes through StorageManager
        
        function saveGame() {
            try {
                const success = StorageManager.saveState(GameState);
                if (!success) {
                    showError('Failed to save data', 'StorageManager returned false');
                }
            } catch (error) {
                showError('Failed to save data', error.stack);
            }
        }
        
        /**
         * Carrega o jogo de forma segura e transacional.
         * Retorna verdadeiro se carregou com sucesso, falso se usou o estado padr√£o.
         * 
         * HARDENED (Bug-proof):
         * - Fail-safe: null save ‚Üí retorna false, mant√©m GameState default
         * - Fail-safe: JSON inv√°lido ‚Üí backup + reset, retorna false
         * - Fail-safe: migration error ‚Üí fallback seguro
         * 
         * COMMIT 6: Integrado normalizeGameState()
         * PR3: Uses StorageManager for all localStorage access
         */
        function loadGame() {
            try {
                // PR3: Load via StorageManager
                const result = StorageManager.loadState();
                
                // 1. Fail-safe: Se n√£o tem save, n√£o faz nada (mant√©m GameState default)
                if (!result.loaded || result.state === null) {
                    console.log('[System] No save found. Starting new game.');
                    return false;
                }
                
                const loaded = result.state;
                
                // Valida√ß√£o estrutural m√≠nima antes de tocar no GameState
                if (!loaded || typeof loaded !== 'object') {
                    console.warn('[System] Invalid save format (not an object). Resetting.');
                    return false;
                }
                
                // 3. Migra√ß√£o em Escada (Safe Migration)
                const migrated = migrateSaveIfNeeded(loaded);
                
                // 4. Normaliza√ß√£o de Estado (COMMIT 6)
                // Garante estrutura e tipos corretos, chama normalizeMonster() em todos os monstros
                const normalized = normalizeGameState(migrated);
                
                // 5. Merge Seguro (n√£o substituir GameState inteiro)
                Object.assign(GameState, normalized);
                
                // 6. P√≥s-processamento espec√≠fico
                if (GameState.players) {
                    GameState.players.forEach(player => {
                        // Validar estrutura do jogador
                        if (!player || !player.id || !player.name) {
                            console.warn('[System] Invalid player detected:', player);
                            return;
                        }
                        
                        // Migrar invent√°rios antigos (se fun√ß√£o existe)
                        if (typeof migrateInventory === 'function') {
                            migrateInventory(player);
                        }
                        
                        // Progress√£o (Feature 3.3) - se fun√ß√£o existe
                        if (player.team) {
                            player.team.forEach(monster => {
                                if (!monster) return;
                                if (typeof ensureMonsterProgressFields === 'function') {
                                    ensureMonsterProgressFields(monster);
                                }
                            });
                        }
                        
                        if (player.box) {
                            player.box.forEach(monster => {
                                if (!monster) return;
                                if (typeof ensureMonsterProgressFields === 'function') {
                                    ensureMonsterProgressFields(monster);
                                }
                            });
                        }
                    });
                }
                
                console.log(`[System] Game loaded successfully. Save version: ${GameState.meta?.saveVersion || 0}`);
                return true;
                
            } catch (error) {
                console.error('[System] Critical error in loadGame:', error);
                alert('Error loading game. Check console for details.');
                return false;
            }
        }

        // Legacy wrapper for backward compatibility (Commit 3)
        function saveToLocalStorage() {
            saveGame();
        }

        function loadFromLocalStorage() {
            loadGame();
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            try {
                const tabs = document.querySelectorAll('.tab-content');
                const buttons = document.querySelectorAll('.tab-button');
                
                tabs.forEach(tab => tab.classList.remove('active'));
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeTab = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                const activeButton = Array.from(buttons).find(btn => 
                    btn.textContent.toLowerCase().includes(tabName.toLowerCase())
                );
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                
                // PR16B: Render PartyDex when tab is opened
                // Note: renderPartyDexTab() is idempotent (DOM-only, no side effects)
                // Safe to call multiple times without creating loops or duplicates
                if (tabName === 'partyDex' && typeof window.renderPartyDexTab === 'function') {
                    window.renderPartyDexTab();
                }
                
                updateAllViews();
            } catch (error) {
                showError('Tab switching failed', error.stack);
            }
        }

        // THERAPIST MODE HELPERS (Feature 4.6)
        
        // Helper functions for show/hide elements using CSS classes
        function showEl(el) {
            if (!el) return;
            el.classList.remove('is-hidden');
        }
        
        function hideEl(el) {
            if (!el) return;
            el.classList.add('is-hidden');
        }
        
        function mmIsTherapistMode() {
            try {
                if (GameState && typeof GameState.therapistMode === "boolean") return GameState.therapistMode;
            } catch (e) {
                console.warn('Failed to access GameState.therapistMode:', e);
            }
            return StorageManager.getTherapistMode(); // PR3
        }

        function mmSetTherapistMode(on) {
            const v = !!on;
            try { 
                GameState.therapistMode = v; 
            } catch (e) {
                console.warn('Failed to set GameState.therapistMode:', e);
                return false;
            }
            const storageSaved = StorageManager.setTherapistMode(v); // PR3
            if (!storageSaved) {
                console.warn('[mmSetTherapistMode] StorageManager.setTherapistMode failed');
                return false;
            }
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            // Update UI elements
            mmUpdateTherapistUI();
            return true;
        }

        function mmRequireGameOrAlert() {
            if (!GameState?.players || GameState.players.length === 0) {
                alert("Crie um novo jogo primeiro!");
                return false;
            }
            return true;
        }

        function mmUpdateTherapistUI() {
            // Update therapist button visibility in menu
            const btn = document.getElementById("mmTherapistBtn");
            if (btn) {
                if (mmIsTherapistMode()) {
                    showEl(btn);
                } else {
                    hideEl(btn);
                }
            }
            
            // Update checkbox in settings
            const checkbox = document.getElementById("therapistMode");
            if (checkbox) checkbox.checked = mmIsTherapistMode();
            
            // Update therapist panel visibility (Commit 1)
            const panel = document.getElementById("therapistPanel");
            if (panel) {
                if (mmIsTherapistMode()) {
                    showEl(panel);
                } else {
                    hideEl(panel);
                }
            }
        }

        // COMMIT 2: Therapist Export/Import Save Tools
        function therapistExportSave() {
            try {
                const saveData = JSON.stringify(GameState, null, 2);
                
                // Copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(saveData).then(() => {
                        alert('‚úÖ Save data copied to clipboard!\n\nYou can also download it as a file.');
                    }).catch(() => {
                        alert('‚ö†Ô∏è Could not copy to clipboard, but you can download the file.');
                    });
                }
                
                // Also download as file
                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_save_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log('[Therapist] Save exported successfully');
            } catch (error) {
                console.error('[Therapist] Export failed:', error);
                alert('‚ùå Export failed: ' + error.message);
            }
        }

        function therapistImportSave() {
            try {
                // Show textarea and buttons for JSON paste
                const textarea = document.getElementById('therapistJsonArea');
                const buttons = document.getElementById('therapistJsonButtons');
                
                if (textarea && buttons) {
                    showEl(textarea);
                    buttons.classList.remove('d-none');
                    buttons.classList.add('d-flex');
                    textarea.value = '';
                    textarea.focus();
                }
                
                console.log('[Therapist] Ready to import save - paste JSON and click Load');
            } catch (error) {
                console.error('[Therapist] Import UI failed:', error);
                alert('‚ùå Import failed: ' + error.message);
            }
        }

        function therapistLoadJson() {
            try {
                const textarea = document.getElementById('therapistJsonArea');
                const jsonText = textarea?.value?.trim();
                
                if (!jsonText) {
                    alert('‚ö†Ô∏è Please paste JSON data first');
                    return;
                }
                
                // Validate JSON
                let saveData;
                try {
                    saveData = JSON.parse(jsonText);
                } catch (parseError) {
                    console.error('[Therapist] Invalid JSON:', parseError);
                    alert('‚ùå Invalid JSON format:\n' + parseError.message);
                    return;
                }
                
                // Basic validation
                if (typeof saveData !== 'object' || saveData === null) {
                    alert('‚ùå Invalid save data: must be an object');
                    return;
                }
                
                // Load through existing safe load routine
                Object.assign(GameState, saveData);
                
                // Re-run load validation and migrations
                if (GameState.players && Array.isArray(GameState.players)) {
                    GameState.players.forEach(player => {
                        if (!player) return;
                        
                        // Ensure arrays
                        player.team = Array.isArray(player.team) ? player.team : [];
                        player.box = Array.isArray(player.box) ? player.box : [];
                        player.inventory = player.inventory || {};
                        
                        // ENE migration for monsters
                        if (player.team) {
                            player.team.forEach(monster => {
                                if (!monster) return;
                                // COMMIT 5: Use normalizeMonster instead of manual migration
                                normalizeMonster(monster);
                            });
                        }
                        
                        if (player.box) {
                            player.box.forEach(monster => {
                                if (!monster) return;
                                normalizeMonster(monster);
                            });
                        }
                    });
                }
                
                // Save to localStorage using centralized function (Commit 3)
                saveGame();
                
                // Update all views
                if (typeof updateAllViews === 'function') updateAllViews();
                
                // Hide import UI
                therapistCancelImport();
                
                alert('‚úÖ Save data loaded successfully!');
                console.log('[Therapist] Save imported and loaded successfully');
                
            } catch (error) {
                console.error('[Therapist] Load failed:', error);
                alert('‚ùå Load failed: ' + error.message);
            }
        }

        function therapistCancelImport() {
            try {
                const textarea = document.getElementById('therapistJsonArea');
                const buttons = document.getElementById('therapistJsonButtons');
                
                if (textarea) {
                    hideEl(textarea);
                    textarea.value = '';
                }
                if (buttons) {
                    buttons.classList.remove('d-flex');
                    buttons.classList.add('d-none');
                }
                
                console.log('[Therapist] Import cancelled');
            } catch (error) {
                console.error('[Therapist] Cancel failed:', error);
            }
        }

        // ============================================================================
        // FASE 1 POKEMON: Fun√ß√µes de Sistema
        // ============================================================================

        /**
         * FASE 1.1: Indicador Visual de Vantagem de Classe
         * Calcula vantagem de classe entre atacante e defensor
         * @param {string} attackerClass - Classe do atacante
         * @param {string} defenderClass - Classe do defensor
         * @returns {object} - { multiplier, bonus, text, cssClass }
         */
        function getClassAdvantage(attackerClass, defenderClass) {
            try {
                const advantages = GameState.config?.classAdvantages || {};
                const adv = advantages[attackerClass];
                
                if (!adv) {
                    return { multiplier: 1.0, bonus: 0, text: '‚û°Ô∏è Efetividade normal', cssClass: 'neutral' };
                }
                
                // Vantagem: atacante forte contra defensor
                if (adv.strong === defenderClass) {
                    return { 
                        multiplier: 1.1, 
                        bonus: 2, 
                        text: '‚úÖ Super efetivo! (+2 ATK, +10% DMG)', 
                        cssClass: 'advantage' 
                    };
                }
                
                // Desvantagem: atacante fraco contra defensor
                if (adv.weak === defenderClass) {
                    return { 
                        multiplier: 0.9, 
                        bonus: -2, 
                        text: '‚ö†Ô∏è Pouco efetivo... (-2 ATK, -10% DMG)', 
                        cssClass: 'disadvantage' 
                    };
                }
                
                // Neutro
                return { 
                    multiplier: 1.0, 
                    bonus: 0, 
                    text: '‚û°Ô∏è Efetividade normal', 
                    cssClass: 'neutral' 
                };
            } catch (error) {
                console.error('Error calculating class advantage:', error);
                return { multiplier: 1.0, bonus: 0, text: '', cssClass: 'neutral' };
            }
        }

        /**
         * FASE 1.2: Monstr√≥dex - Atualiza progresso de monstrinhos vistos/capturados
         * @param {string} action - 'see' ou 'capture'
         * @param {string} monsterId - ID do monstrinho (templateId)
         */
        function updateMonstrodex(action, monsterId) {
            try {
                if (!monsterId) return;
                
                // Inicializar monstrodex se n√£o existir
                if (!GameState.monstrodex) {
                    GameState.monstrodex = { seen: [], captured: [] };
                }
                
                // Marcar como visto
                if (action === 'see' && !GameState.monstrodex.seen.includes(monsterId)) {
                    GameState.monstrodex.seen.push(monsterId);
                }
                
                // Marcar como capturado (tamb√©m marca como visto)
                if (action === 'capture') {
                    if (!GameState.monstrodex.seen.includes(monsterId)) {
                        GameState.monstrodex.seen.push(monsterId);
                    }
                    if (!GameState.monstrodex.captured.includes(monsterId)) {
                        GameState.monstrodex.captured.push(monsterId);
                    }
                }
                
                saveGame();
            } catch (error) {
                console.error('Error updating monstrodex:', error);
            }
        }

        /**
         * FASE 1.3: Livro de Conquistas - Atualiza estat√≠sticas do jogo
         * @param {string} stat - Nome da estat√≠stica (ex: 'battlesWon', 'captureAttempts')
         * @param {number} value - Valor a adicionar (padr√£o: 1)
         */
        function updateStats(stat, value = 1) {
            try {
                // Inicializar stats se n√£o existir
                if (!GameState.stats) {
                    GameState.stats = {
                        battlesWon: 0,
                        battlesLost: 0,
                        captureAttempts: 0,
                        capturesSuccessful: 0,
                        totalXpGained: 0,
                        totalMoneyEarned: 0,
                        currentWinStreak: 0,
                        highestWinStreak: 0
                    };
                }
                
                // Incrementar estat√≠stica
                if (stat in GameState.stats) {
                    GameState.stats[stat] = (GameState.stats[stat] || 0) + value;
                }
                
                // Atualizar streak de vit√≥rias
                if (stat === 'battlesWon') {
                    GameState.stats.currentWinStreak = (GameState.stats.currentWinStreak || 0) + 1;
                    if (GameState.stats.currentWinStreak > (GameState.stats.highestWinStreak || 0)) {
                        GameState.stats.highestWinStreak = GameState.stats.currentWinStreak;
                    }
                } else if (stat === 'battlesLost') {
                    GameState.stats.currentWinStreak = 0;
                }
                
                saveGame();
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        /**
         * FASE 1.4: Shiny - Gera chance de monstrinho shiny
         * @returns {boolean} - true se deve ser shiny (1% chance)
         */
        function generateShinyChance() {
            const SHINY_CHANCE_RATE = 0.01; // 1% chance
            return Math.random() < SHINY_CHANCE_RATE;
        }

        // PLAYER MANAGEMENT
        function addPlayer() {
            try {
                const name = document.getElementById('playerName')?.value?.trim();
                const playerClass = document.getElementById('playerClass')?.value;
                
                if (!name) {
                    alert('Please enter a player name');
                    return;
                }
                
                if (!playerClass) {
                    alert('Please select a class');
                    return;
                }
                
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    class: playerClass, // Armazena a classe diretamente
                    playerClassId: playerClass,
                    money: 100,
                    afterlifeCurrency: 0,
                    team: [],
                    box: [],
                    inventory: {
                        'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                        'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                        'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                        'IT_HEAL_01': 3           // Petisco de Cura x3
                    }
                };
                
                GameState.players = GameState.players || [];
                GameState.players.push(player);
                
                giveStarterMonster(player);
                
                document.getElementById('playerName').value = '';
                document.getElementById('playerClass').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add player', error.stack);
            }
        }

        function giveStarterMonster(player) {
            try {
                // Busca monstrinho inicial da mesma classe do jogador
                const classMonsters = MONSTER_CATALOG.filter(m => 
                    m?.class === player?.class && m?.rarity === 'Comum'
                );
                
                // Se n√£o encontrar da mesma classe, pega qualquer starter comum
                const starterTemplate = classMonsters.length > 0 ? classMonsters[0] : 
                    MONSTER_CATALOG.find(m => m?.rarity === 'Comum');
                
                if (!starterTemplate) return;
                
                // COMMIT 8 (Wave A): Use Award API for canonical monster creation
                const monster = awardMonster(
                    starterTemplate.id,  // templateId
                    5,                   // level
                    null,                // rarity (use template default)
                    'party',             // destination
                    player               // player object
                );
                
                if (!monster) {
                    console.error('Failed to award starter monster via Award API');
                }
            } catch (error) {
                console.error('Failed to give starter monster:', error);
            }
        }

        function createMonsterInstance(template, ownerId, level = 1) {
            try {
                if (!template) return null;
                
                // Calcular stats baseados no n√≠vel
                const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult); // SPD adicionado
                const poder = Math.floor(atk * 0.5); // PODER √© derivado de ATK
                
                // Calcular ENE (Sistema ENE)
                const baseEne = template.baseEne || 10; // Fallback se n√£o tiver no template
                const eneGrowth = 2; // growth_ene padr√£o
                const eneMax = Math.floor(baseEne + eneGrowth * (level - 1));
                
                // Determinar stage baseado no n√≠vel (simplificado)
                // S0: n√≠vel 1-9, S1: 10-24, S2: 25-44, S3: 45+
                let stage = 0;
                if (level >= 45) stage = 3;
                else if (level >= 25) stage = 2;
                else if (level >= 10) stage = 1;
                
                return {
                    id: Date.now() + Math.random(),
                    ownerId: ownerId,
                    monsterId: template.id,
                    name: template.name,
                    nickname: template.name, // Nickname padr√£o
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji,
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level), // Feature 3.3
                    hp: hpMax,
                    hpMax: hpMax,
                    atk: atk,
                    def: def,
                    spd: spd,           // SPD adicionado
                    poder: poder,
                    ene: eneMax,      // ENE atual (come√ßa cheio)
                    eneMax: eneMax,   // ENE m√°ximo
                    stage: stage,     // Est√°gio de evolu√ß√£o (0-3)
                    status: 'healthy',
                    buffs: [],        // Array para buffs tempor√°rios
                    friendship: DEFAULT_FRIENDSHIP    // Sistema de Amizade (0-100, padr√£o neutro)
                };
            } catch (error) {
                console.error('Failed to create monster instance:', error);
                return null;
            }
        }

        // COMMIT 7: Factory Pattern - createMonsterInstanceFromTemplate()
        /**
         * Factory function para criar inst√¢ncias de monstros com schema can√¥nico.
         * 
         * Esta √© a fun√ß√£o OFICIAL para criar novos monstros a partir do cat√°logo.
         * Garante que todos os monstros nascam com estrutura can√¥nica consistente.
         * 
         * @param {string} templateId - ID do template no MONSTER_CATALOG (ex: 'MON_001')
         * @param {number} level - N√≠vel do monstrinho (padr√£o: 1)
         * @param {string|null} rarity - Raridade (se null, usa do template)
         * @param {object} overrides - Campos opcionais para sobrescrever (ex: {nickname: 'Fofinho'})
         * @returns {object|null} - Inst√¢ncia do monstrinho ou null se template n√£o encontrado
         * 
         * SCHEMA CAN√îNICO (Commit 5):
         * - templateId: ID do template (n√£o monsterId, baseId, idBase)
         * - instanceId: ID √∫nico da inst√¢ncia (n√£o id)
         * - hp/hpMax: HP atual/m√°ximo (n√£o currentHp, maxHp)
         * - ene/eneMax: ENE atual/m√°ximo
         * - level, xp, buffs, class, rarity
         */
        function createMonsterInstanceFromTemplate(templateId, level = 1, rarity = null, overrides = {}) {
            try {
                // 1. Buscar template no cat√°logo
                const catalog = MONSTER_CATALOG || [];
                const template = catalog.find(m => m && m.id === templateId);
                
                if (!template) {
                    console.warn(`[Factory] Template not found: ${templateId}`);
                    return null;
                }
                
                // 2. Gerar instanceId √∫nico
                // Formato: mi_timestamp_random (mi = monster instance)
                const instanceId = `mi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // 3. Determinar raridade (par√¢metro ou do template)
                const finalRarity = rarity || template.rarity || 'Comum';
                
                // 4. Calcular stats baseados no n√≠vel
                const rarityMult = GameState.config?.rarityPower?.[finalRarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult);
                const poder = Math.floor(atk * 0.5);
                
                // 5. Calcular ENE usando f√≥rmula can√¥nica: floor(10 + 2*(level-1))
                const eneMax = Math.floor(10 + 2 * (level - 1));
                
                // 6. Criar inst√¢ncia com campos can√¥nicos
                const instance = {
                    // IDs (schema can√¥nico)
                    templateId: template.id,     // ‚úÖ Can√¥nico (n√£o monsterId)
                    instanceId: instanceId,       // ‚úÖ Can√¥nico (n√£o id)
                    
                    // Info b√°sica
                    name: template.name,
                    nickname: template.name,      // Padr√£o (pode ser sobrescrito)
                    emoji: template.emoji || 'üëæ',
                    
                    // Classe e raridade
                    class: template.class || 'Neutro',
                    rarity: finalRarity,
                    
                    // Progress√£o
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level),
                    
                    // HP (schema can√¥nico)
                    hp: hpMax,          // ‚úÖ Can√¥nico (n√£o currentHp)
                    hpMax: hpMax,       // ‚úÖ Can√¥nico (n√£o maxHp)
                    
                    // ENE (schema can√¥nico)
                    ene: eneMax,        // ‚úÖ Come√ßa cheio
                    eneMax: eneMax,     // ‚úÖ Can√¥nico
                    
                    // Stats de combate
                    atk: atk,
                    def: def,
                    spd: spd,
                    poder: poder,
                    
                    // Estado
                    status: 'healthy',
                    buffs: [],          // ‚úÖ Array vazio (n√£o undefined)
                    
                    // Evolu√ß√£o
                    stage: 0,           // Sempre come√ßa em stage 0
                    
                    // Sistema de Amizade
                    friendship: DEFAULT_FRIENDSHIP,     // Padr√£o: neutro (0-100)
                    
                    // FASE 1 POKEMON: Shiny (1% chance se selvagem)
                    isShiny: false      // Padr√£o false, ser√° sobrescrito se necess√°rio
                };
                
                // 7. Aplicar overrides (ex: nickname personalizado, ownerId, etc.)
                if (overrides && typeof overrides === 'object') {
                    Object.assign(instance, overrides);
                }
                
                // 8. Normalizar usando fun√ß√£o robusta do Commit 5
                // Isso garante que mesmo com overrides, a estrutura fica can√¥nica
                const normalized = normalizeMonster(instance);
                
                if (!normalized) {
                    console.error('[Factory] Normalization failed for template:', templateId);
                    return null;
                }
                
                console.log(`[Factory] Created ${normalized.name} (${templateId}) at level ${level}`);
                return normalized;
                
            } catch (error) {
                console.error('[Factory] Error creating monster instance:', error, { templateId, level, rarity });
                return null;
            }
        }

        // TODO (Commit 8): Substituir chamadas de createMonsterInstance() por createMonsterInstanceFromTemplate()
        // A fun√ß√£o antiga ainda funciona para compatibilidade, mas a nova garante schema can√¥nico.

        // ============================================================================
        // COMMIT 8: Award API - Single Official Path for Rewards
        // ============================================================================

        /**
         * Awards XP to a monster and triggers level-ups automatically.
         * @param {Object|number} target - Monster object or index in player's team
         * @param {number} amount - XP amount to award (must be >= 1)
         * @param {Object} player - Player object (optional, for index-based targeting)
         * @returns {boolean} - true if successful, false otherwise
         */
        function awardXP(target, amount, player = null) {
            try {
                // Validate amount
                const xpAmount = Math.max(1, Number(amount) || 0);
                if (xpAmount < 1) {
                    console.warn('[Award] Invalid XP amount:', amount);
                    return false;
                }

                // Resolve target monster
                let monster = null;
                if (typeof target === 'object' && target !== null) {
                    // Direct monster object
                    monster = target;
                } else if (typeof target === 'number' && player) {
                    // Index in player's team
                    if (!player.team || !Array.isArray(player.team)) {
                        console.warn('[Award] Player has no team array');
                        return false;
                    }
                    monster = player.team[target];
                }

                if (!monster) {
                    console.warn('[Award] Target monster not found');
                    return false;
                }

                // Use existing giveXP function (already handles level-ups)
                const logArr = [];
                giveXP(monster, xpAmount, logArr);

                // Log to console if in therapist mode
                if (typeof mmGetTherapistMode === 'function' && mmGetTherapistMode()) {
                    console.log('[Award] Granted XP:', {
                        monster: monster.name || monster.templateId,
                        amount: xpAmount,
                        newLevel: monster.level,
                        log: logArr
                    });
                }

                // Persist
                saveGame();
                return true;

            } catch (error) {
                console.error('[Award] awardXP failed:', error);
                return false;
            }
        }

        /**
         * Awards an item to a player's inventory.
         * @param {string} itemId - Item ID to award
         * @param {number} qty - Quantity to award (must be >= 1)
         * @param {Object} player - Player object
         * @returns {boolean} - true if successful, false otherwise
         */
        function awardItem(itemId, qty, player) {
            try {
                // Commit 12 (Wave C12.2): Validate itemId against catalog
                const itemDef = requireItemDef(itemId, 'awardItem');
                if (!itemDef) {
                    // Commit 13 (Wave 13.2): Use mmDebugLog
                    mmDebugLog("AWARD_ITEM", {
                        context: 'awardItem',
                        itemId,
                        error: 'Invalid itemId',
                        success: false
                    }, "error");
                    return false;
                }

                // Validate inputs
                if (!itemId || typeof itemId !== 'string') {
                    mmDebugLog("AWARD_ITEM", {
                        context: 'awardItem',
                        itemId,
                        error: 'Invalid itemId type',
                        success: false
                    }, "warn");
                    return false;
                }

                const quantity = Math.max(1, Number(qty) || 1);
                if (quantity < 1) {
                    mmDebugLog("AWARD_ITEM", {
                        context: 'awardItem',
                        qty,
                        error: 'Invalid quantity',
                        success: false
                    }, "warn");
                    return false;
                }

                if (!player || typeof player !== 'object') {
                    mmDebugLog("AWARD_ITEM", {
                        context: 'awardItem',
                        error: 'Invalid player object',
                        success: false
                    }, "warn");
                    return false;
                }

                // Ensure inventory exists
                player.inventory = player.inventory || {};

                // Add item (reuse existing inventory logic)
                player.inventory[itemId] = (player.inventory[itemId] || 0) + quantity;

                // Commit 13 (Wave 13.2): Success log with mmDebugLog
                mmDebugLog("AWARD_ITEM", {
                    context: 'awardItem',
                    itemId: itemId,
                    quantity: quantity,
                    newTotal: player.inventory[itemId],
                    playerId: player.id,
                    playerName: player.name,
                    success: true
                }, "info");

                // Persist
                saveGame();
                return true;

            } catch (error) {
                // Commit 13 (Wave 13.2): Error logging
                mmDebugLog("AWARD_ITEM", {
                    context: 'awardItem',
                    itemId,
                    error: error.message || String(error),
                    success: false
                }, "error");
                return false;
            }
        }

        /**
         * Awards a new monster to a player (party or box).
         * @param {string} templateId - Monster template ID from catalog
         * @param {number} level - Starting level
         * @param {string|null} rarity - Rarity override (null = use template default)
         * @param {string} destination - 'party', 'box', or 'auto' (auto respects team limit)
         * @param {Object} player - Player object
         * @param {Object} overrides - Optional field overrides
         * @returns {Object|null} - Created monster or null if failed
         */
        function awardMonster(templateId, level, rarity, destination, player, overrides = {}) {
            try {
                // Commit 12 (Wave C12.2): Validate templateId against catalog
                const template = requireMonsterTemplate(templateId, 'awardMonster');
                if (!template) {
                    // Commit 13 (Wave 13.2): Use mmDebugLog for errors
                    mmDebugLog("AWARD_MONSTER", {
                        context: 'awardMonster',
                        templateId,
                        error: 'Invalid templateId',
                        success: false
                    }, "error");
                    return null;
                }

                // Validate inputs
                if (!templateId || typeof templateId !== 'string') {
                    mmDebugLog("AWARD_MONSTER", {
                        context: 'awardMonster',
                        templateId,
                        error: 'Invalid templateId type',
                        success: false
                    }, "warn");
                    return null;
                }

                if (!player || typeof player !== 'object') {
                    mmDebugLog("AWARD_MONSTER", {
                        context: 'awardMonster',
                        error: 'Invalid player object',
                        success: false
                    }, "warn");
                    return null;
                }

                const monsterLevel = Math.max(1, Number(level) || 1);
                const dest = destination || 'auto';

                // Create monster using factory (Commit 7)
                const monster = createMonsterInstanceFromTemplate(templateId, monsterLevel, rarity, overrides);
                
                if (!monster) {
                    mmDebugLog("AWARD_MONSTER", {
                        context: 'awardMonster',
                        templateId,
                        error: 'Failed to create monster from template',
                        success: false
                    }, "warn");
                    return null;
                }

                // Set owner
                if (player.id) {
                    monster.ownerId = player.id;
                }

                // Ensure arrays exist
                player.team = player.team || [];
                player.box = player.box || [];

                // Determine destination
                let actualDest = dest;
                if (dest === 'auto') {
                    const maxTeamSize = GameState.config?.maxTeamSize || 6;
                    actualDest = (player.team.length < maxTeamSize) ? 'party' : 'box';
                }

                // Add to destination
                if (actualDest === 'party' || actualDest === 'team') {
                    const maxTeamSize = GameState.config?.maxTeamSize || 6;
                    if (player.team.length < maxTeamSize) {
                        player.team.push(monster);
                    } else {
                        // Party full, add to box instead
                        player.box.push(monster);
                        actualDest = 'box';
                        // Commit 13 (Wave 13.2): Use mmDebugLog
                        mmDebugLog("AWARD_MONSTER", {
                            context: 'awardMonster',
                            templateId,
                            note: 'Party full, redirected to box',
                            requestedDest: 'team',
                            actualDest: 'box'
                        }, "warn");
                    }
                } else {
                    // box
                    player.box.push(monster);
                }

                // Add to global monsters list (for compatibility)
                GameState.monsters = GameState.monsters || [];
                GameState.monsters.push(monster);

                // Commit 13 (Wave 13.2): Success log with mmDebugLog
                mmDebugLog("AWARD_MONSTER", {
                    context: 'awardMonster',
                    templateId: templateId,
                    monsterName: monster.name,
                    level: monsterLevel,
                    rarity: monster.rarity,
                    destination: actualDest,
                    playerId: player.id,
                    playerName: player.name,
                    success: true
                }, "info");

                // PR16A: Mark as captured in PartyDex and check milestones
                if (window.PartyDex && templateId) {
                    window.PartyDex.onMonsterAddedToGroup(GameState, templateId, {
                        showToast: showToast,
                        saveToLocalStorage: saveToLocalStorage
                    });
                }

                // Persist
                saveGame();
                return monster;

            } catch (error) {
                // Commit 13 (Wave 13.2): Error logging
                mmDebugLog("AWARD_MONSTER", {
                    context: 'awardMonster',
                    templateId,
                    error: error.message || String(error),
                    success: false
                }, "error");
                return null;
            }
        }

        // ============================================================================
        // End of Award API
        // ============================================================================

        // Fun√ß√£o para obter habilidade do monstrinho
        // Obter habilidades do monstrinho baseado em classe e est√°gio
        function getMonsterSkills(monster) {
            try {
                if (!monster || !monster.class) return [];
                
                const classSkills = SKILL_DEFS[monster.class];
                if (!classSkills) return [];
                
                const stage = monster.stage || 0;
                const skillList = [];
                
                // Pegar as duas primeiras skills sempre dispon√≠veis
                const skillNames = Object.keys(classSkills);
                for (let i = 0; i < Math.min(2, skillNames.length); i++) {
                    const skillTiers = classSkills[skillNames[i]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                // Terceira skill (se existir e stage >= 1)
                if (skillNames.length > 2 && stage >= 1) {
                    const skillTiers = classSkills[skillNames[2]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                return skillList;
            } catch (error) {
                console.error('Failed to get monster skills:', error);
                return [];
            }
        }

        // Aplicar regenera√ß√£o de ENE
        function applyEneRegen(monster, encounter) {
            try {
                if (!monster || !monster.class) return;
                
                const regenData = ENE_REGEN_BY_CLASS[monster.class] || { pct: 0.10, min: 1 };
                const eneGain = Math.max(regenData.min, Math.ceil(monster.eneMax * regenData.pct));
                
                monster.ene = Math.min(monster.eneMax, monster.ene + eneGain);
                
                if (encounter && encounter.log) {
                    encounter.log.push(`‚ö° ${monster.name} regenerou ${eneGain} ENE (${monster.ene}/${monster.eneMax})`);
                }
            } catch (error) {
                console.error('Failed to apply ENE regen:', error);
            }
        }

        // Usar habilidade
        function useSkill(attacker, skill, defender, encounter) {
            try {
                if (!attacker || !skill || !defender) return false;
                
                // Verificar se tem ENE suficiente
                if (attacker.ene < skill.cost) {
                    return false;
                }
                
                // Consumir ENE
                attacker.ene -= skill.cost;
                
                encounter.log = encounter.log || [];
                encounter.log.push(`‚ú® ${attacker.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                
                // Aplicar efeito baseado no tipo
                switch (skill.type) {
                    case 'DAMAGE':
                        // Calcular dano da habilidade com nova f√≥rmula
                        const atkMods = getBuffModifiers(attacker);
                        const effectiveAtk = Math.max(1, attacker.atk + atkMods.atk);
                        
                        const defMods = getBuffModifiers(defender);
                        const effectiveDef = Math.max(1, defender.def + defMods.def);
                        
                        // Vantagem de classe
                        const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                        let damageMult = 1.0;
                        if (classAdv?.strong === defender.class) {
                            damageMult = 1.10;
                        } else if (classAdv?.weak === defender.class) {
                            damageMult = 0.90;
                        }
                        
                        const skillDamage = calcDamage({
                            atk: effectiveAtk,
                            def: effectiveDef,
                            power: skill.power,
                            damageMult: damageMult
                        });
                        
                        defender.hp = Math.max(0, defender.hp - skillDamage);
                        encounter.log.push(`üí• ${defender.name} recebe ${skillDamage} de dano!`);
                        break;
                        
                    case 'HEAL':
                        // Curar (self ou ally)
                        const healAmount = skill.power;
                        const target = (skill.target === 'ally' || skill.target === 'self') ? attacker : defender;
                        target.hp = Math.min(target.hpMax, target.hp + healAmount);
                        encounter.log.push(`üíö ${target.name} recupera ${healAmount} HP!`);
                        break;
                        
                    case 'BUFF':
                        // Aplicar buff/debuff
                        const buffTarget = skill.target === 'enemy' ? defender : attacker;
                        buffTarget.buffs = buffTarget.buffs || [];
                        
                        const buff = {
                            type: skill.buffType,
                            power: skill.power,
                            duration: skill.duration || 1,
                            source: skill.name
                        };
                        buffTarget.buffs.push(buff);
                        
                        const buffDesc = skill.power > 0 ? `+${skill.power}` : skill.power;
                        encounter.log.push(`üîÆ ${buffTarget.name} recebe ${buff.type} ${buffDesc} por ${buff.duration} turnos!`);
                        
                        // Se for F√∫ria (B√°rbaro), aplicar tamb√©m o debuff
                        if (skill.debuffType && skill.debuffPower) {
                            const debuff = {
                                type: skill.debuffType,
                                power: skill.debuffPower,
                                duration: skill.duration || 1,
                                source: skill.name
                            };
                            attacker.buffs.push(debuff);
                            encounter.log.push(`‚ö†Ô∏è ${attacker.name} recebe ${debuff.type} ${debuff.power} por ${debuff.duration} turnos!`);
                        }
                        break;
                        
                    case 'TAUNT':
                        // Marcar alvo como provocado (flag simples)
                        defender.taunted = true;
                        encounter.log.push(`üò† ${defender.name} foi provocado!`);
                        break;
                }
                
                return true;
            } catch (error) {
                console.error('Failed to use skill:', error);
                return false;
            }
        }

        // Atualizar buffs (reduzir dura√ß√£o, remover expirados)
        function updateBuffs(monster) {
            try {
                if (!monster || !monster.buffs) return;
                
                monster.buffs = monster.buffs.filter(buff => {
                    buff.duration--;
                    return buff.duration > 0;
                });
            } catch (error) {
                console.error('Failed to update buffs:', error);
            }
        }

        // Calcular modificadores de buffs
        function getBuffModifiers(monster) {
            try {
                if (!monster || !monster.buffs) return { atk: 0, def: 0, spd: 0 };
                
                const mods = { atk: 0, def: 0, spd: 0 };
                
                monster.buffs.forEach(buff => {
                    const type = buff.type.toLowerCase();
                    if (type === 'atk') mods.atk += buff.power;
                    else if (type === 'def') mods.def += buff.power;
                    else if (type === 'spd') mods.spd += buff.power;
                });
                
                return mods;
            } catch (error) {
                console.error('Failed to get buff modifiers:', error);
                return { atk: 0, def: 0, spd: 0 };
            }
        }

        // Fun√ß√£o antiga removida - usar getMonsterSkills acima

        // Migrar invent√°rio antigo para novo sistema ClasterOrb
        function migrateInventory(player) {
            try {
                if (!player || !player.inventory) return;
                
                // Se tem IT_CAP_01 antigo, converter para CLASTERORB_COMUM
                if (player.inventory['IT_CAP_01']) {
                    const oldCount = player.inventory['IT_CAP_01'];
                    player.inventory['CLASTERORB_COMUM'] = (player.inventory['CLASTERORB_COMUM'] || 0) + oldCount;
                    delete player.inventory['IT_CAP_01'];
                }
                
                // Garantir que novos itens existam
                if (!player.inventory['CLASTERORB_COMUM']) player.inventory['CLASTERORB_COMUM'] = 0;
                if (!player.inventory['CLASTERORB_INCOMUM']) player.inventory['CLASTERORB_INCOMUM'] = 0;
                if (!player.inventory['CLASTERORB_RARA']) player.inventory['CLASTERORB_RARA'] = 0;
            } catch (error) {
                console.error('Failed to migrate inventory:', error);
            }
        }

        // SESSION MANAGEMENT
        function createSession() {
            try {
                const name = document.getElementById('sessionName')?.value?.trim();
                
                if (!name) {
                    alert('Please enter a session name');
                    return;
                }
                
                if (!GameState.players || GameState.players.length === 0) {
                    alert('Please add players first');
                    return;
                }
                
                const session = {
                    id: Date.now(),
                    name: name,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    players: GameState.players.map(p => p?.id).filter(id => id),
                    turnOrder: [...GameState.players.map(p => p?.id).filter(id => id)],
                    currentTurnIndex: 0,
                    encountersLog: [],
                    therapy: {
                        perPlayer: {}
                    }
                };
                
                GameState.players.forEach(player => {
                    if (player?.id) {
                        session.therapy.perPlayer[player.id] = {
                            pm: 0,
                            medals: [],
                            logs: [],
                            completedObjectives: []
                        };
                    }
                });
                
                GameState.sessions = GameState.sessions || [];
                GameState.sessions.push(session);
                GameState.currentSession = session;
                
                document.getElementById('sessionName').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to create session', error.stack);
            }
        }

        function nextTurn() {
            try {
                if (!GameState.currentSession) return;
                
                const session = GameState.currentSession;
                session.currentTurnIndex = ((session.currentTurnIndex || 0) + 1) % (session.turnOrder?.length || 1);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to advance turn', error.stack);
            }
        }

        function endSession() {
            try {
                if (!GameState.currentSession) return;
                
                if (confirm('End this session?')) {
                    GameState.currentSession.completedAt = new Date().toISOString();
                    GameState.currentSession = null;
                    
                    saveToLocalStorage();
                    updateAllViews();
                }
            } catch (error) {
                showError('Failed to end session', error.stack);
            }
        }

        // ENCOUNTER MANAGEMENT
        function startEncounter() {
            try {
                const type = document.getElementById('encounterType')?.value;
                
                if (!type) {
                    alert('Please select encounter type');
                    return;
                }
                
                if (!GameState.currentSession) {
                    alert('Please create a session first');
                    return;
                }
                
                // Para encontros em grupo (trainer/boss), usar sistema de grupo
                if (type === 'trainer' || type === 'boss') {
                    // Coletar participantes selecionados
                    const checkboxes = document.querySelectorAll('input[name="groupParticipant"]:checked');
                    const selectedPlayerIds = Array.from(checkboxes).map(cb => cb.value);
                    
                    if (selectedPlayerIds.length === 0) {
                        alert('Selecione pelo menos 1 jogador para a batalha em grupo');
                        return;
                    }
                    
                    if (selectedPlayerIds.length > 6) {
                        alert('M√°ximo de 6 jogadores por batalha');
                        return;
                    }
                    
                    const enemyLevel = parseInt(document.getElementById('enemyLevel')?.value || '5');
                    startGroupEncounter(selectedPlayerIds, type, enemyLevel);
                    return;
                }
                
                // Para encontros individuais (captura), precisa selecionar jogador
                if (type === 'wild') {
                    const selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                    if (!selectedPlayerId) {
                        alert('Please select a player for individual encounter');
                        return;
                    }
                    
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (!player || !player.team || player.team.length === 0) {
                        alert('Selected player has no monsters in team');
                        return;
                    }
                    
                    // GAME_RULES.md: Em batalha, s√≥ pode usar monstros da mesma classe do jogador
                    const validMonsters = player.team.filter(m => m.class === player.class && m.status !== 'fainted');
                    if (validMonsters.length === 0) {
                        alert(`‚ö†Ô∏è ${player.name} n√£o tem monstrinhos da classe ${player.class} dispon√≠veis!\n\nREGRA: Em batalha, voc√™ s√≥ pode usar monstrinhos da SUA classe.\nTroque com outros jogadores para conseguir monstrinhos da sua classe!`);
                        return;
                    }
                }
                
                const encounter = {
                    id: Date.now(),
                    type: type,
                    active: true,
                    log: [],
                    selectedPlayerId: type === 'wild' ? document.getElementById('encounterPlayer')?.value : null,
                    rewardsGranted: false  // Previne duplica√ß√£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                if (type === 'wild') {
                    // Limpar buffs do monstrinho do jogador antes da batalha
                    const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
                    if (player && player.team) {
                        // Commit 11 (Wave B): Use resetBattleBuffs helper
                        for (const mon of player.team) {
                            resetBattleBuffs(mon);
                        }
                    }
                    
                    // Wave B1: enemy instances now use factory
                    const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                    const level = Math.floor(Math.random() * 10) + 1;
                    encounter.wildMonster = createMonsterInstanceFromTemplate(
                        randomMonster.id,  // Template ID from catalog
                        level, 
                        null, // Use template's default rarity
                        { id: 'wild_' + Date.now() } // Override with wild encounter ID
                    );
                    
                    // FASE 1 POKEMON: Gerar shiny (1% chance)
                    encounter.wildMonster.isShiny = generateShinyChance();
                    
                    // FASE 1 POKEMON: Marcar como visto no Monstr√≥dex
                    updateMonstrodex('see', randomMonster.id);
                    
                    // PR16A: Mark as seen in PartyDex (randomMonster.id is the template ID)
                    if (window.PartyDex) {
                        window.PartyDex.markDexSeen(GameState, randomMonster.id);
                    }
                }
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start encounter', error.stack);
            }
        }

        // GROUP BATTLE FUNCTIONS (Feature 3.2)
        
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        // ==================== GROUP/BOSS COMBAT ====================
        // PR5A: Fun√ß√µes abaixo ser√£o movidas para js/combat/groupActions.js em PR futuro
        // Por enquanto, mant√™m implementa√ß√£o inline (sem mudan√ßa de comportamento)
        
        /**
         * WRAPPER FUTURO: Combat.Group.Actions.initializeGroupEncounter()
         * Inicializa encounter de grupo/boss
         */
        function startGroupEncounter(selectedPlayerIds, encounterType, enemyLevel) {
            try {
                // TODO PR5B: Mover para Combat.Group.Actions.initializeGroupEncounter()
                // Initialize activeIndex for all participating players
                for (const pid of selectedPlayerIds) {
                    const player = GameState.players.find(p => p.id === pid);
                    if (!player) continue;
                    
                    // Ensure player has valid starter
                    if (!autoSelectStarter(player)) {
                        alert(`‚ö†Ô∏è ${player.name || player.nome} n√£o tem monstrinhos vivos! N√£o pode participar da batalha.`);
                        return;
                    }
                }
                
                // Limpar buffs dos monstrinhos dos jogadores participantes
                for (const pid of selectedPlayerIds) {
                    const player = GameState.players.find(p => p.id === pid);
                    if (player && player.team) {
                        // Commit 11 (Wave B): Use resetBattleBuffs helper
                        for (const mon of player.team) {
                            resetBattleBuffs(mon);
                        }
                    }
                }
                
                // Wave B2: enemy instances now use factory
                const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                const enemy = createMonsterInstanceFromTemplate(
                    randomMonster.id,  // Template ID from catalog
                    enemyLevel, 
                    null, // Use template's default rarity
                    { id: 'enemy_1' } // Override with group encounter enemy ID
                );
                
                // PR16A: Mark as seen in PartyDex (randomMonster.id is the template ID)
                if (window.PartyDex) {
                    window.PartyDex.markDexSeen(GameState, randomMonster.id);
                }
                
                // Criar encounter de grupo
                const encounter = {
                    id: Date.now(),
                    type: encounterType === 'boss' ? 'boss' : 'group_trainer',
                    active: true,
                    log: [],
                    participants: selectedPlayerIds,
                    enemies: [enemy],
                    turnOrder: [],
                    turnIndex: 0,
                    currentActor: null,
                    finished: false,
                    result: null,
                    rewardsGranted: false  // Previne duplica√ß√£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                // Calcular ordem de turnos
                encounter.turnOrder = calculateGroupTurnOrder(encounter);
                encounter.turnIndex = 0;
                encounter.currentActor = getCurrentActor(encounter);
                
                encounter.log.push('üé≤ Ordem de turnos calculada!');
                encounter.turnOrder.forEach((actor, idx) => {
                    const tieInfo = actor._tiebreak ? ` (d20: ${actor._tiebreak})` : '';
                    encounter.log.push(`   ${idx + 1}. ${actor.name} (${actor.side === 'player' ? 'Jogador' : 'Inimigo'}, SPD: ${actor.spd}${tieInfo})`);
                });
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start group encounter', error.stack);
            }
        }
        
        function calculateGroupTurnOrder(enc) {
            // PR5B: Use pure function from groupCore
            return GroupCore.calculateTurnOrder(enc, GameState.players, rollD20);
        }
        
        function getCurrentActor(enc) {
            // PR5B: Use pure function from groupCore
            return GroupCore.getCurrentActor(enc);
        }
        
        function _hasAlivePlayers(enc) {
            // PR5B: Use pure function from groupCore
            return GroupCore.hasAlivePlayers(enc, GameState.players);
        }
        
        function _hasAliveEnemies(enc) {
            // PR5B: Use pure function from groupCore
            return GroupCore.hasAliveEnemies(enc);
        }
        
        /**
         * PR5C: WRAPPER - Combat.Group.Actions.advanceGroupTurn()
         * (Chamado internamente pelas actions, n√£o exposto diretamente)
         */
        function advanceTurn(enc) {
            const deps = createGroupCombatDeps();
            Combat.Group.Actions.advanceGroupTurn(enc, deps);
        }
        
        /**
         * PR5C: WRAPPER - Combat.Group.Actions.passTurn()
         * Passa turno sem a√ß√£o
         */
        function groupPassTurn() {
            try {
                const deps = createGroupCombatDeps();
                Combat.Group.Actions.passTurn(deps);
            } catch (error) {
                showError('Failed to pass turn', error.stack);
            }
        }

        // ==================== FASE 3: Helper Functions ====================

        function _getGroupEncounter() {
            return GameState.currentEncounter;
        }

        function _getPlayerById(playerId) {
            return GameState.players.find(p => p.id === playerId) || null;
        }

        function _getActiveMonsterOfPlayer(player) {
            if (!player || !Array.isArray(player.team)) return null;
            
            // Initialize activeIndex if not set
            if (typeof player.activeIndex !== 'number') {
                player.activeIndex = firstAliveIndex(player.team);
            }
            
            // Return the active monster (or null if index is invalid)
            return player.team[player.activeIndex] || null;
        }

        function _getEnemyByIndex(enc, idx) {
            return enc?.enemies?.[idx] || null;
        }

        function _clamp(n, min, max) {
            // PR5B: Use pure function from groupCore
            return GroupCore.clamp(n, min, max);
        }

        /**
         * Commit 11 (Wave A): Combat Helper - Apply Damage
         * Applies damage to a target with HP clamping
         * @param {Object} target - The monster receiving damage
         * @param {number} dmg - Amount of damage to apply
         * @returns {Object} { oldHp, newHp, fainted } - Damage application result
         */
        function applyDamage(target, dmg) {
            if (!target) return { oldHp: 0, newHp: 0, fainted: true };
            
            const oldHp = Number(target.hp) || 0;
            const hpMax = Number(target.hpMax) || 999999;
            const newHp = _clamp(oldHp - dmg, 0, hpMax);
            
            target.hp = newHp;
            
            return {
                oldHp: oldHp,
                newHp: newHp,
                fainted: newHp <= 0
            };
        }

        /**
         * Commit 11 (Wave A): Combat Helper - Reset Battle Buffs
         * Resets a monster's buffs array (exactly matches current behavior)
         * @param {Object} mon - The monster whose buffs to reset
         */
        function resetBattleBuffs(mon) {
            if (mon && mon.buffs !== undefined) {
                mon.buffs = [];
            }
        }

        function _calcDamage(power, atk, def) {
            const A = Number(atk) || 0;
            const D = Number(def) || 0;
            const P = Number(power) || 0;
            const ratio = (A <= 0 && D <= 0) ? 0.5 : (A / (A + D));
            const base = Math.floor(P * ratio);
            return Math.max(1, base);
        }

        function _isAlive(entity) {
            // PR5B: Use pure function from groupCore
            return GroupCore.isAlive(entity);
        }

        function _log(enc, msg) {
            enc.log = enc.log || [];
            enc.log.push(msg);
        }

        // ==================== Team Management Helpers ====================
        
        /**
         * Returns the index of the first alive monster in the team (hp > 0).
         * Returns -1 if no alive monsters found.
         */
        function firstAliveIndex(team) {
            if (!Array.isArray(team)) return -1;
            for (let i = 0; i < team.length; i++) {
                if (_isAlive(team[i])) return i;
            }
            return -1;
        }

        /**
         * Moves a team member from one position to another.
         * Updates the player's team array and saves.
         */
        function moveTeamMember(player, fromIdx, toIdx) {
            if (!player || !Array.isArray(player.team)) return;
            if (fromIdx < 0 || fromIdx >= player.team.length) return;
            if (toIdx < 0 || toIdx >= player.team.length) return;
            if (fromIdx === toIdx) return;

            const monster = player.team[fromIdx];
            player.team.splice(fromIdx, 1);
            player.team.splice(toIdx, 0, monster);

            // Update activeIndex if player has one
            if (typeof player.activeIndex === 'number') {
                if (player.activeIndex === fromIdx) {
                    player.activeIndex = toIdx;
                } else if (fromIdx < toIdx) {
                    if (player.activeIndex > fromIdx && player.activeIndex <= toIdx) {
                        player.activeIndex--;
                    }
                } else {
                    if (player.activeIndex >= toIdx && player.activeIndex < fromIdx) {
                        player.activeIndex++;
                    }
                }
            }

            saveToLocalStorage();
        }

        /**
         * Auto-selects the starter for encounter.
         * Sets player.activeIndex to the first alive monster.
         * Returns true if a valid starter was found, false otherwise.
         */
        function autoSelectStarter(player) {
            if (!player || !Array.isArray(player.team)) return false;
            const idx = firstAliveIndex(player.team);
            if (idx >= 0) {
                player.activeIndex = idx;
                return true;
            }
            player.activeIndex = -1;
            return false;
        }

        /**
         * Ensures the active monster is alive.
         * - Outside battle: auto-switches to first alive
         * - During battle: opens modal for manual selection (if inBattle is true)
         */
        function ensureActiveAlive(player, options = {}) {
            if (!player || !Array.isArray(player.team)) return false;
            
            // Initialize activeIndex if not set
            if (typeof player.activeIndex !== 'number') {
                player.activeIndex = 0;
            }

            const currentMon = player.team[player.activeIndex];
            
            // If current is alive, we're good
            if (_isAlive(currentMon)) return true;

            // Current is fainted
            if (options.inBattle) {
                // In battle: need to open modal for replacement
                return false; // Caller should handle modal
            } else {
                // Outside battle: auto-switch to first alive
                const idx = firstAliveIndex(player.team);
                if (idx >= 0) {
                    player.activeIndex = idx;
                    saveToLocalStorage();
                    return true;
                }
                // No alive monsters
                player.activeIndex = -1;
                return false;
            }
        }

        function _chooseTargetPlayerId(enc) {
            // PR5B: Use pure function from groupCore
            // Prepare targets data array for pure function
            const targets = [];
            for (const pid of (enc.participants || [])) {
                const p = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(p);
                if (!mon || !_isAlive(mon)) continue;
                
                targets.push({
                    id: pid,
                    hp: Number(mon.hp) || 0,
                    hpMax: Number(mon.hpMax) || 1
                });
            }
            
            return GroupCore.chooseTargetByLowestHP(targets);
        }

        // ==================== FASE 3.A: Player Attack ====================

        /**
         * PR5C: Criar objeto de depend√™ncias para injetar nas actions
         */
        function createGroupCombatDeps() {
            return {
                state: GameState,
                core: GroupCore,
                ui: {
                    render: renderEncounter,
                    showDamageFeedback: Combat.Group.UI.showDamageFeedback,
                    showMissFeedback: Combat.Group.UI.showMissFeedback,
                    playAttackFeedback: Combat.Group.UI.playAttackFeedback
                },
                audio: Audio,
                storage: {
                    save: saveToLocalStorage
                },
                helpers: {
                    getPlayerById: _getPlayerById,
                    getActiveMonsterOfPlayer: _getActiveMonsterOfPlayer,
                    getEnemyByIndex: _getEnemyByIndex,
                    log: _log,
                    applyEneRegen: applyEneRegen,
                    updateBuffs: updateBuffs,
                    rollD20: rollD20,
                    recordD20Roll: recordD20Roll,
                    getBasicAttackPower: (cls) => MM_TABLES.getBasicAttackPower(cls),
                    applyDamage: applyDamage,
                    chooseTargetPlayerId: _chooseTargetPlayerId,
                    firstAliveIndex: firstAliveIndex,
                    openSwitchMonsterModal: openSwitchMonsterModal,
                    handleVictoryRewards: handleVictoryRewards
                }
            };
        }

        /**
         * PR5C: WRAPPER - Combat.Group.Actions.executePlayerAttackGroup()
         * Executa ataque do jogador em combate de grupo
         */
        function groupAttack() {
            try {
                const deps = createGroupCombatDeps();
                Combat.Group.Actions.executePlayerAttackGroup(deps);
            } catch (error) {
                showError('Failed to attack', error.stack);
            }
        }

        // ==================== FASE 3.B: Enemy AI ====================

        /**
         * PR5C: WRAPPER - Combat.Group.Actions.executeEnemyTurnGroup()
         * Processa turno do inimigo em combate de grupo
         */
        function processEnemyTurnGroup(enc) {
            try {
                const deps = createGroupCombatDeps();
                Combat.Group.Actions.executeEnemyTurnGroup(enc, deps);
            } catch (error) {
                showError('Failed to process enemy turn', error.stack);
            }
        }

        // ==================== Switch Monster Modal ====================

        function openSwitchMonsterModal(player, enc) {
            if (!player || !Array.isArray(player.team)) return;
            
            // Get alive monsters (excluding current active)
            const aliveMonsters = [];
            player.team.forEach((mon, idx) => {
                if (_isAlive(mon) && idx !== player.activeIndex) {
                    aliveMonsters.push({ monster: mon, index: idx });
                }
            });
            
            if (aliveMonsters.length === 0) {
                alert('Sem monstrinhos vivos para substituir!');
                // Continue battle
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
                return;
            }
            
            // Build modal HTML
            let html = '<div class="modal-overlay-fixed" id="switchMonsterModal">';
            html += '<div class="modal-content-card">';
            html += `<h3>üíÄ ${player.name || player.nome}: Escolha um Substituto</h3>`;
            html += '<p>Seu monstrinho foi derrotado! Escolha um substituto:</p>';
            html += '<div class="modal-items-container">';
            
            aliveMonsters.forEach(({ monster, index }) => {
                const hpPercent = Math.floor((monster.hp / monster.hpMax) * 100);
                html += `<div class="modal-item-card cursor-pointer" onclick="selectReplacementMonster('${player.id}', ${index}, '${enc.id}')">`;
                html += `<strong>${monster.emoji || ''} ${monster.name || monster.nome}</strong> - Nv ${monster.level}`;
                html += `<br>HP: ${monster.hp}/${monster.hpMax} (${hpPercent}%)`;
                html += `<br>Classe: ${monster.class}`;
                html += `</div>`;
            });
            
            html += '</div>';
            html += '</div>';
            html += '</div>';
            
            // Add modal to body
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = html;
            document.body.appendChild(modalDiv);
        }

        function selectReplacementMonster(playerId, newActiveIndex, encounterId) {
            try {
                const player = _getPlayerById(playerId);
                const enc = GameState.currentEncounter;
                
                if (!player || !enc || enc.id !== encounterId) {
                    console.error('Invalid state for monster replacement');
                    return;
                }
                
                // Set new active index
                player.activeIndex = newActiveIndex;
                
                const newMon = player.team[newActiveIndex];
                _log(enc, `üîÑ ${player.name || player.nome} trocou para ${newMon.name || newMon.nome}!`);
                
                // Close modal
                const modal = document.getElementById('switchMonsterModal');
                if (modal) modal.remove();
                
                // Continue battle
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to select replacement monster', error.stack);
            }
        }

        // ==================== FASE 3.C: Skills and Items ====================

        /**
         * WRAPPER FUTURO: Combat.Group.Actions.executeGroupUseSkill()
         * Usa habilidade em combate de grupo (STUB - n√£o implementado)
         */
        function groupUseSkill(skillIndex) {
            try {
                // TODO PR5B: Mover para Combat.Group.Actions.executeGroupUseSkill()
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon || !_isAlive(mon)) return;

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;
                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) return;

                _log(enc, "‚ÑπÔ∏è (Ajuste) Sistema de habilidades ser√° integrado na Feature 3.3");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use skill', error.stack);
            }
        }

        /**
         * WRAPPER FUTURO: Combat.Group.Actions.executeGroupUseItem()
         * Usa item em combate de grupo
         */
        function groupUseItem(itemId) {
            try {
                // TODO PR5B: Mover para Combat.Group.Actions.executeGroupUseItem()
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                // Reutiliza l√≥gica do 3.1
                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;

                if (hp <= 0) {
                    _log(enc, "‚ö†Ô∏è Monstrinho est√° desmaiado.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (hp >= hpMax) {
                    _log(enc, "‚ÑπÔ∏è HP j√° est√° cheio.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (!itemId || itemId === 'IT_HEAL_01') {
                    itemId = 'IT_HEAL_01';
                }

                const itemCount = Number(player.inventory?.[itemId]) || 0;
                if (itemCount <= 0) {
                    _log(enc, "‚ö†Ô∏è Voc√™ n√£o tem esse item.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Consumir item
                player.inventory[itemId] = Math.max(0, itemCount - 1);

                // Aplicar cura (mesmo do 3.1)
                const healAmount = Math.max(30, Math.floor(hpMax * 0.30));
                const newHp = Math.min(hpMax, hp + healAmount);
                const healed = newHp - hp;
                mon.hp = newHp;

                const playerName = player.name || "Jogador";
                const monName = mon.nickname || mon.name || "Monstrinho";

                _log(enc, `üíö ${playerName} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                _log(enc, `‚ú® ${monName} recuperou ${healed} HP! (${mon.hp}/${hpMax})`);
                
                // Feature 4.4: Heal sound
                Audio.playSfx("heal");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use item', error.stack);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FEATURE 3.3 - SISTEMA DE XP E LEVEL UP (com idempot√™ncia)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Garante que um monstro tenha campos de progress√£o (compatibilidade com saves antigos)
         */
        function ensureMonsterProgressFields(mon) {
            if (!mon) return;
            mon.level = Math.max(1, Number(mon.level) || 1);
            mon.xp = Math.max(0, Number(mon.xp) || 0);
            mon.xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
            // Fallback hpMax/maxHp
            if (mon.hpMax == null && mon.maxHp != null) mon.hpMax = mon.maxHp;
            if (mon.hp == null && mon.hpMax != null) mon.hp = mon.hpMax;
        }
        
        /**
         * Calcula XP necess√°rio para pr√≥ximo n√≠vel (curva suave)
         */
        function calcXpNeeded(level) {
            const L = Math.max(1, Number(level) || 1);
            return Math.round(40 + 6 * L + 0.6 * (L * L));
        }
        
        // Alias para compatibilidade
        function calculateXPNeeded(level) {
            return calcXpNeeded(level);
        }
        
        /**
         * Garante que um monstro tenha campos de XP preenchidos
         */
        function ensureXpFields(mon) {
            if (!mon) return;
            if (mon.level == null) mon.level = 1;
            if (mon.xp == null) mon.xp = 0;
            if (mon.xpNeeded == null) mon.xpNeeded = calcXpNeeded(mon.level);
        }
        
        /**
         * PR12B: Formata informa√ß√µes do item equipado para exibi√ß√£o em combate
         * @param {string} itemId - ID do item equipado
         * @returns {string} HTML formatado ou mensagem padr√£o
         */
        function formatEquippedItemDisplay(itemId) {
            if (!itemId) {
                return '<div class="equipped-item-info"><strong>‚öîÔ∏è Item:</strong> Nenhum</div>';
            }
            
            const itemDef = window.Data?.getItemById?.(itemId);
            if (!itemDef) {
                return '<div class="equipped-item-info"><strong>‚öîÔ∏è Item:</strong> Desconhecido</div>';
            }
            
            // Formatar b√¥nus
            const bonuses = [];
            if (itemDef.stats?.atk > 0) bonuses.push(`+${itemDef.stats.atk} ATK`);
            if (itemDef.stats?.def > 0) bonuses.push(`+${itemDef.stats.def} DEF`);
            
            let itemLabel = itemDef.name;
            if (bonuses.length > 0) {
                itemLabel += ` (${bonuses.join(', ')})`;
            }
            
            // Mostrar chance de quebra apenas se break.enabled
            let breakInfo = '';
            if (itemDef.break?.enabled) {
                const chancePercent = Math.round(itemDef.break.chance * 100);
                breakInfo = ` <span class="text-warning">| Quebra: ${chancePercent}%</span>`;
            }
            
            return `<div class="equipped-item-info"><strong>‚öîÔ∏è Item:</strong> ${itemLabel}${breakInfo}</div>`;
        }
        
        /**
         * Exibe um toast notification tempor√°rio
         */
        function showToast(text, type = 'success') {
            const host = document.getElementById("mmToastHost");
            if (!host) return;

            const el = document.createElement("div");
            el.className = `mm-toast ${type}`;
            el.textContent = text;

            host.appendChild(el);

            // Show toast with slide-in animation
            setTimeout(() => {
                el.classList.add('show');
            }, 10);

            // Start fade-out after 1.5 seconds
            setTimeout(() => {
                el.style.opacity = "0";
                el.style.transform = "translateY(-4px)";
                el.style.transition = "opacity .2s ease, transform .2s ease";
            }, 1500);

            // Remove from DOM after animation
            setTimeout(() => el.remove(), 2000);
        }

        /**
         * Logs a message to the therapist log panel (only if therapist mode is active)
         * @param {string} message - Message to log
         */
        function therapistLog(message) {
            // Only log if therapist mode is enabled
            if (typeof mmIsTherapistMode !== 'function' || !mmIsTherapistMode()) {
                return;
            }

            const logContainer = document.getElementById("therapistLog");
            if (!logContainer) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement("div");
            logEntry.className = "therapist-log-entry";
            logEntry.textContent = `[${timestamp}] ${message}`;

            logContainer.appendChild(logEntry);

            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;

            // Keep only last 50 entries to avoid memory issues
            const entries = logContainer.querySelectorAll(".therapist-log-entry");
            if (entries.length > 50) {
                entries[0].remove();
            }
        }

        // ============================================================================
        // Commit 13: mmDebugLog - Standardized Debug Logging System
        // ============================================================================

        /**
         * Get current timestamp in ISO format
         * @returns {string} ISO timestamp or empty string on error
         */
        function mmNowISO() {
            try {
                return new Date().toISOString();
            } catch (e) {
                return "";
            }
        }

        /**
         * Safely stringify an object to JSON
         * @param {*} obj - Object to stringify
         * @returns {string} JSON string or error object
         */
        function mmSafeStringify(obj) {
            try {
                return JSON.stringify(obj);
            } catch (e) {
                try {
                    return JSON.stringify({
                        error: "stringify_failed",
                        keys: Object.keys(obj || {})
                    });
                } catch (_) {
                    return '{"error":"stringify_failed"}';
                }
            }
        }

        /**
         * Normalize log level to standard values
         * @param {string} level - Log level (error, warn, info, debug)
         * @returns {string} Normalized level
         */
        function mmNormalizeLevel(level) {
            const L = String(level || "info").toLowerCase();
            if (L === "error" || L === "warn" || L === "info" || L === "debug") {
                return L;
            }
            return "info";
        }

        // In-memory debug buffer (useful for export or audit)
        window.MM_DEBUG_BUFFER = window.MM_DEBUG_BUFFER || [];
        const MM_DEBUG_BUFFER_MAX = 200;

        /**
         * Standardized debug logging function
         * @param {string} event - Event name (e.g., 'CATALOG_ID_INVALID', 'AWARD_MONSTER')
         * @param {object} details - Event details (context, ids, values, etc.)
         * @param {string} level - Log level ('error', 'warn', 'info', 'debug')
         * @returns {object} The logged payload
         */
        function mmDebugLog(event, details, level) {
            const lvl = mmNormalizeLevel(level);
            const ev = String(event || "EVENT_UNSPECIFIED").trim() || "EVENT_UNSPECIFIED";
            const det = (details && typeof details === "object") ? details : { value: details };

            // Enrich payload with context (det first, then override with standard fields)
            const payload = {
                ...det,
                ts: mmNowISO(),
                level: lvl,
                event: ev,
                context: det.context || det.fn || det.source || "unknown",
                saveSlot: (window.GameState && GameState.saveSlot) ? GameState.saveSlot : null
            };

            // 1) Console output with standard format
            const tag = `[MM:${String(payload.level).toUpperCase()}] ${payload.event}`;
            if (payload.level === "error") {
                console.error(tag, payload);
            } else if (payload.level === "warn") {
                console.warn(tag, payload);
            } else if (payload.level === "debug") {
                console.debug(tag, payload);
            } else {
                console.log(tag, payload);
            }

            // 2) Add to debug buffer
            window.MM_DEBUG_BUFFER.push(payload);
            if (window.MM_DEBUG_BUFFER.length > MM_DEBUG_BUFFER_MAX) {
                window.MM_DEBUG_BUFFER.splice(0, window.MM_DEBUG_BUFFER.length - MM_DEBUG_BUFFER_MAX);
            }

            // 3) Therapist panel log (if therapist mode is active)
            if (typeof therapistLog === 'function') {
                // Create condensed message for therapist panel
                const icon = lvl === 'error' ? '‚ùå' : lvl === 'warn' ? '‚ö†Ô∏è' : lvl === 'debug' ? 'üîç' : '‚ÑπÔ∏è';
                const condensed = `${icon} ${ev}: ${det.context || 'unknown'}`;
                
                // Add key details if present
                const keyDetails = [];
                if (det.templateId) keyDetails.push(`template=${det.templateId}`);
                if (det.itemId) keyDetails.push(`item=${det.itemId}`);
                if (det.className) keyDetails.push(`class=${det.className}`);
                if (det.rarity) keyDetails.push(`rarity=${det.rarity}`);
                if (det.note) keyDetails.push(`note=${det.note}`);
                
                const fullMessage = keyDetails.length > 0 
                    ? `${condensed} (${keyDetails.join(', ')})`
                    : condensed;
                
                therapistLog(fullMessage);
            }

            return payload;
        }

        /**
         * Log invalid class warning
         * @param {string} className - The invalid class name
         * @param {string} context - Where the validation failed
         */
        function mmLogInvalidClass(className, context) {
            const isValid = (window.MM_TABLES && typeof MM_TABLES.validateClass === 'function')
                ? MM_TABLES.validateClass(className)
                : false;

            if (!isValid) {
                mmDebugLog("CLASS_INVALID", {
                    context,
                    className,
                    allowedClasses: (MM_TABLES && MM_TABLES.CLASSES) ? MM_TABLES.CLASSES : null
                }, "warn");
            }
        }

        /**
         * Log invalid rarity warning
         * @param {string} rarityName - The invalid rarity name
         * @param {string} context - Where the validation failed
         */
        function mmLogInvalidRarity(rarityName, context) {
            const isValid = (window.MM_TABLES && typeof MM_TABLES.validateRarity === 'function')
                ? MM_TABLES.validateRarity(rarityName)
                : false;

            if (!isValid) {
                mmDebugLog("RARITY_INVALID", {
                    context,
                    rarity: rarityName,
                    allowedRarities: (MM_TABLES && MM_TABLES.RARITIES) ? MM_TABLES.RARITIES : null
                }, "warn");
            }
        }

        /**
         * Log legacy fallback usage
         * @param {string} context - Where the fallback occurred
         * @param {object} details - Additional details
         */
        function mmLogLegacyFallback(context, details) {
            mmDebugLog("WARN_LEGACY_FALLBACK", {
                context,
                legacy: true,
                ...details
            }, "warn");
        }

        /**
         * Inicializa campos de toast para um encounter
         * Garante que cada encounter tenha IDs √∫nicos e cursor de toast resetado
         */
        function initializeEncounterToast(enc) {
            if (!enc) return;
            
            // Garantir ID √∫nico do encounter
            if (!enc.encounterId) {
                enc.encounterId = "enc_" + Date.now() + "_" + Math.random().toString(16).slice(2);
            }
            
            // Inicializar cursor de toast
            enc._toastCursor = 0;
            
            // Opcional: tracking de mensagens j√° vistas (para futuro uso)
            enc._toastSeen = {};
        }
        
        /**
         * Verifica novas entradas no log e exibe toasts para eventos importantes
         * Usa cursor para evitar repetir toasts em re-render
         * Detecta level up e evolu√ß√£o por emoji OU por texto
         */
        function maybeToastFromLog(enc) {
            if (!enc || !Array.isArray(enc.log)) return;

            // Garantir inicializa√ß√£o do cursor (seguran√ßa para encounters antigos)
            if (enc._toastCursor == null) enc._toastCursor = 0;

            const start = Number.isFinite(enc._toastCursor) ? enc._toastCursor : 0;
            for (let i = start; i < enc.log.length; i++) {
                const line = String(enc.log[i] || "");
                
                // Detectar level up: por emoji OU por texto
                const isLevelUp = line.includes("‚ú®") || /subiu para o n√≠vel/i.test(line);
                if (isLevelUp) showToast(line);
                
                // Detectar evolu√ß√£o: por emoji OU por texto
                const isEvo = line.includes("üåü") || /evoluiu para/i.test(line);
                if (isEvo) showToast(line);
            }
            enc._toastCursor = enc.log.length;
        }
        
        /**
         * Feature 4.4: Plays sounds for level up and evolution events from log
         * Uses cursor to prevent repeating sounds on re-render
         */
        function maybeSfxFromLog(enc) {
            if (!enc || !Array.isArray(enc.log)) return;
            
            // Guarantee cursor initialization
            if (enc._sfxCursor == null) enc._sfxCursor = 0;
            
            const start = Number.isFinite(enc._sfxCursor) ? enc._sfxCursor : 0;
            for (let i = start; i < enc.log.length; i++) {
                const line = String(enc.log[i] || "");
                
                // Detect level up - check emoji first to avoid double-trigger
                if (line.includes("‚ú®")) {
                    Audio.playSfx("levelup");
                } else if (/subiu para o n√≠vel/i.test(line)) {
                    Audio.playSfx("levelup");
                }
                
                // Detect evolution - check emoji first to avoid double-trigger
                if (line.includes("üåü")) {
                    Audio.playSfx("evolve");
                } else if (/evoluiu para/i.test(line)) {
                    Audio.playSfx("evolve");
                }
            }
            enc._sfxCursor = enc.log.length;
        }
        
        /**
         * PR8B: FACTORY - Create dependencies for Progression.Actions
         * Cria objeto de depend√™ncias para injetar nas fun√ß√µes de progress√£o
         */
        function createProgressionDeps() {
            return {
                state: GameState,
                constants: {
                    DEFAULT_FRIENDSHIP: DEFAULT_FRIENDSHIP
                },
                helpers: {
                    // Progression helpers
                    ensureMonsterProgressFields: ensureMonsterProgressFields,
                    calcXpNeeded: calcXpNeeded,
                    recalculateStatsFromTemplate: recalculateStatsFromTemplate,
                    
                    // Friendship helpers
                    getFriendshipBonuses: getFriendshipBonuses,
                    formatFriendshipBonusPercent: formatFriendshipBonusPercent,
                    updateFriendship: updateFriendship,
                    
                    // Evolution and skills
                    maybeEvolveAfterLevelUp: maybeEvolveAfterLevelUp,
                    maybeUpgradeSkillsModelB: maybeUpgradeSkillsModelB,
                    
                    // Stats tracking
                    updateStats: updateStats,
                    
                    // XP calculation (wrapped)
                    calculateBattleXP: calculateBattleXP
                }
            };
        }
        
        /**
         * Calcula XP ganho de uma batalha
         * @param {Object} defeatedEnemy - Inimigo derrotado
         * @param {string} encounterType - Tipo do encontro ('wild', 'group_trainer', 'boss')
         * @returns {number} - XP calculado
         */
        /**
         * PR8A: WRAPPER - Progression.Core.calculateBattleXP()
         * Calcula XP de batalha (wrapper para manter compatibilidade)
         */
        function calculateBattleXP(defeatedEnemy, encounterType) {
            return Progression.Core.calculateBattleXP(
                defeatedEnemy, 
                encounterType, 
                GameState.config
            );
        }
        
        /**
         * PR8B: WRAPPER - Progression.Actions.giveXP()
         * D√° XP para um monstro e processa level ups (wrapper para manter compatibilidade)
         * @param {Object} mon - Monstro que receber√° XP
         * @param {number} amount - Quantidade de XP
         * @param {Array} logArr - Array de log (opcional, usa encounter.log se n√£o fornecido)
         */
        function giveXP(mon, amount, logArr) {
            return Progression.Actions.giveXP(createProgressionDeps(), mon, amount, logArr);
        }
        
        /**
         * PR8B: WRAPPER - Progression.Actions.levelUpMonster()
         * Processa um level up para o monstro (wrapper para manter compatibilidade)
         * @param {Object} mon - Monstro que vai subir de n√≠vel
         * @param {Array} logArr - Array de log (opcional)
         */
        function levelUpMonster(mon, logArr) {
            return Progression.Actions.levelUpMonster(createProgressionDeps(), mon, logArr);
        }
        
        // Alias para compatibilidade
        function levelUp(mon) {
            return levelUpMonster(mon, GameState.currentEncounter?.log);
        }
        
        /**
         * Recalcula stats do monstro baseado no n√≠vel e raridade (com fallbacks)
         * @param {Object} mon - Monstro para recalcular
         */
        function recalculateStatsFromTemplate(mon) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Buscar template base do cat√°logo (com m√∫ltiplos fallbacks)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            if (!template) return; // N√£o quebra se n√£o encontrar
            
            // Obter raridade (com fallback)
            const rarity = template.rarity || template.raridade || mon.rarity || mon.raridade;
            
            // Multiplicadores
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (Math.max(1, mon.level) - 1) * 0.1;
            
            // Base stats (com m√∫ltiplos fallbacks)
            const baseAtk = Number(template.baseAtk ?? template.atkBase ?? template.atk) || 0;
            const baseDef = Number(template.baseDef ?? template.defBase ?? template.def) || 0;
            const baseSpd = Number(template.baseSpd ?? template.spdBase ?? template.spd) || 0;
            
            // Recalcular stats (HP √© tratado separadamente em levelUpMonster)
            mon.atk = Math.floor(baseAtk * levelMult * rarityMult);
            mon.def = Math.floor(baseDef * levelMult * rarityMult);
            mon.spd = Math.floor(baseSpd * levelMult * rarityMult);
        }
        
        // Alias para compatibilidade
        function recalculateStats(mon) {
            return recalculateStatsFromTemplate(mon);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FEATURE 3.4 ‚Äî EVOLUTION (MVP)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Busca template base de um monstro no cat√°logo
         * @param {Object} mon - Monstro
         * @returns {Object|null} - Template encontrado ou null
         */
        function getMonsterTemplateFromInstance(mon) {
            if (!mon) return null;
            
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            return template || null;
        }
        
        /**
         * Extrai dados de evolu√ß√£o de um template (com fallbacks para m√∫ltiplos nomes)
         * @param {Object} template - Template do monstro
         * @returns {Object|null} - { toId, atLv } ou null se n√£o evoluir
         */
        function getEvolutionData(template) {
            if (!template) return null;

            const evolvesTo = template.evolvesTo ?? template.evolve_to ?? template.evoluiPara ?? template.evolutionTo ?? null;
            const evolvesAt = template.evolvesAt ?? template.evolve_at ?? template.evoluiNoNivel ?? template.evolutionAt ?? null;

            const toId = evolvesTo != null ? String(evolvesTo) : "";
            const atLv = evolvesAt != null ? Number(evolvesAt) : NaN;

            if (!toId || !Number.isFinite(atLv) || atLv <= 0) return null;
            return { toId, atLv };
        }

        /**
         * Busca template do monstro evolu√≠do
         * @param {Object} mon - Monstro atual
         * @returns {Object|null} - { nextTemplate, evolvesAt } ou null
         */
        function getEvolutionTargetTemplate(mon) {
            const currentTemplate = getMonsterTemplateFromInstance(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return null;

            // Busca o template alvo no cat√°logo (usa MONSTER_CATALOG como fonte prim√°ria)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const nextTemplate = catalog.find(m => String(m.id) === String(evo.toId));
            
            if (nextTemplate) return { nextTemplate, evolvesAt: evo.atLv };
            return null;
        }

        /**
         * Aplica evolu√ß√£o no monstro (atualiza ID, nome, stats, preserva HP%)
         * @param {Object} mon - Monstro que vai evoluir
         * @param {Object} nextTemplate - Template da evolu√ß√£o
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional, se n√£o fornecido usa HP% atual)
         */
        function applyEvolution(mon, nextTemplate, logArr, hpPctOverride) {
            if (!mon || !nextTemplate) return;

            // preserva % de HP (usa override se fornecido, sen√£o usa o atual)
            let hpPct;
            if (hpPctOverride != null && Number.isFinite(hpPctOverride)) {
                hpPct = hpPctOverride;
            } else {
                const oldHp = Math.max(0, Number(mon.hp) || 0);
                const oldHpMax = Math.max(1, Number(mon.hpMax) || 1);
                hpPct = oldHp / oldHpMax;
            }

            const oldName = mon.nickname || mon.name || mon.nome || "Monstrinho";
            const newName = nextTemplate.name || nextTemplate.nome || oldName;

            // Atualiza o ID base do monstro (tenta manter compatibilidade)
            if (mon.monsterId != null) mon.monsterId = String(nextTemplate.id);
            else if (mon.templateId != null) mon.templateId = String(nextTemplate.id);
            else mon.monsterId = String(nextTemplate.id);

            // Atualiza campos visuais e de gameplay se existirem no template
            if (nextTemplate.name || nextTemplate.nome) mon.name = (nextTemplate.name || nextTemplate.nome);
            if (nextTemplate.emoji) mon.emoji = nextTemplate.emoji;
            if (nextTemplate.class || nextTemplate.classe) mon.class = (nextTemplate.class || nextTemplate.classe);
            if (nextTemplate.rarity || nextTemplate.raridade) mon.rarity = (nextTemplate.rarity || nextTemplate.raridade);

            // Recalcula stats com a nova forma
            recalculateStatsFromTemplate(mon);
            
            // Recalcula hpMax baseado no novo baseHp do template
            const baseHp = Number(nextTemplate.baseHp ?? nextTemplate.hpBase ?? nextTemplate.hp) || mon.hpMax || 1;
            const level = Math.max(1, mon.level);
            const rarity = nextTemplate.rarity || nextTemplate.raridade || mon.rarity;
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (level - 1) * 0.1;
            
            // Nova hpMax baseada no template da evolu√ß√£o
            mon.hpMax = Math.floor(baseHp * levelMult * rarityMult);

            // Ajuste final de HP mantendo percentual
            const newHpMax = Math.max(1, Number(mon.hpMax) || 1);
            mon.hp = Math.max(1, Math.floor(newHpMax * hpPct)); // m√≠nimo 1 para n√£o "morrer" ao evoluir

            if (Array.isArray(logArr)) {
                logArr.push(`üåü ${oldName} evoluiu para ${newName}!`);
            }
            
            // Verificar e aplicar upgrade de skills ap√≥s evolu√ß√£o (Feature 3.6)
            maybeUpgradeSkillsModelB(mon, logArr);
        }

        /**
         * Verifica e aplica evolu√ß√£o se o monstro atingiu o n√≠vel necess√°rio
         * @param {Object} mon - Monstro a verificar
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional)
         * @returns {boolean} - true se evoluiu, false caso contr√°rio
         */
        function checkEvolution(mon, logArr, hpPctOverride) {
            if (!mon) return false;
            ensureMonsterProgressFields(mon);

            const currentTemplate = getMonsterTemplateFromInstance(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return false;

            if (mon.level < evo.atLv) return false;

            const target = getEvolutionTargetTemplate(mon);
            if (!target?.nextTemplate) return false;

            applyEvolution(mon, target.nextTemplate, logArr, hpPctOverride);
            return true;
        }

        /**
         * Tenta evoluir monstro ap√≥s level up (no m√°ximo 1 evolu√ß√£o por levelUp no MVP)
         * @param {Object} mon - Monstro que acabou de subir de n√≠vel
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% de antes do level up para preservar
         */
        function maybeEvolveAfterLevelUp(mon, logArr, hpPctOverride) {
            checkEvolution(mon, logArr, hpPctOverride);
        }
        
        // =============================
        // FEATURE 3.6 ‚Äî SKILLS (MODEL B) AUTO UPGRADE I->II->III
        // =============================

        /**
         * Determina o est√°gio do monstro baseado no n√≠vel
         * @param {number} level - N√≠vel do monstro
         * @returns {string} - Est√°gio (S0, S1, S2, S3)
         */
        function getMonsterStage(level) {
            const lv = Math.max(1, Number(level) || 1);
            if (lv <= 9) return "S0";
            if (lv <= 24) return "S1";
            if (lv <= 44) return "S2";
            return "S3";
        }

        /**
         * Determina o tier de skill desejado baseado no est√°gio
         * @param {string} stage - Est√°gio do monstro (S0, S1, S2, S3)
         * @returns {number} - Tier desejado (1, 2, ou 3)
         */
        function getDesiredSkillTier(stage) {
            // MVP mapping: S0/S1 => I, S2 => II, S3 => III
            if (stage === "S2") return 2;
            if (stage === "S3") return 3;
            return 1;
        }

        /**
         * Obt√©m array de skills do monstro (compat√≠vel com m√∫ltiplos formatos)
         * @param {Object} mon - Monstro
         * @returns {Array} - Array de skill IDs
         */
        function getSkillsArray(mon) {
            if (!mon) return [];
            // formatos comuns: mon.skills (array) ou mon.skillIds (array)
            if (Array.isArray(mon.skills)) return mon.skills.slice();
            if (Array.isArray(mon.skillIds)) return mon.skillIds.slice();
            return [];
        }

        /**
         * Define array de skills no monstro
         * @param {Object} mon - Monstro
         * @param {Array} arr - Array de skill IDs
         */
        function setSkillsArray(mon, arr) {
            if (!mon) return;
            // preferir mon.skills se j√° existe, sen√£o criar
            if (Array.isArray(mon.skills) || mon.skills == null) mon.skills = arr.slice();
            else mon.skillIds = arr.slice();
        }

        /**
         * Obt√©m cat√°logo de skills de m√∫ltiplas fontes poss√≠veis
         * @returns {Array} - Cat√°logo de skills
         */
        function getSkillCatalog() {
            // PR10B: Try JSON first (synchronous lookup, no blocking)
            if (window.Data && window.Data.getSkillsMapSync) {
                const skillsMap = window.Data.getSkillsMapSync();
                if (skillsMap && skillsMap.size > 0) {
                    // Convert Map to Array with deep clone to prevent cache mutation
                    return Array.from(skillsMap.values()).map(skill => 
                        JSON.parse(JSON.stringify(skill))
                    );
                }
            }
            
            // Fallback: hardcoded sources
            const candidates = [];
            
            // Verificar SKILLS_CATALOG definido no escopo local
            if (typeof SKILLS_CATALOG !== 'undefined' && Array.isArray(SKILLS_CATALOG)) {
                candidates.push(SKILLS_CATALOG);
            }
            
            if (window.DB) {
                if (Array.isArray(DB.SKILLS)) candidates.push(DB.SKILLS);
                if (Array.isArray(DB.HABILIDADES)) candidates.push(DB.HABILIDADES);
                if (Array.isArray(DB.ABILITIES)) candidates.push(DB.ABILITIES);
            }
            if (Array.isArray(window.SKILLS)) candidates.push(window.SKILLS);
            if (Array.isArray(window.SKILLS_CATALOG)) candidates.push(window.SKILLS_CATALOG);
            if (Array.isArray(window.ABILITIES)) candidates.push(window.ABILITIES);
            return candidates.find(arr => Array.isArray(arr) && arr.length) || [];
        }

        /**
         * Busca skill por ID no cat√°logo
         * @param {string} id - ID da skill
         * @returns {Object|null} - Objeto da skill ou null
         */
        function getSkillById(id) {
            const sid = String(id || "");
            if (!sid) return null;
            
            // PR10B: Try JSON first (synchronous lookup, no blocking)
            if (window.Data && window.Data.getSkillsMapSync) {
                const skillsMap = window.Data.getSkillsMapSync();
                if (skillsMap && skillsMap.has(sid)) {
                    // Deep clone to prevent cache mutation
                    const skill = skillsMap.get(sid);
                    return JSON.parse(JSON.stringify(skill));
                }
            }
            
            // Fallback: search in hardcoded catalog
            const cat = getSkillCatalog();
            return cat.find(s => String(s.id) === sid) || null;
        }

        /**
         * Extrai a "fam√≠lia" de uma skill (remove sufixos de tier)
         * @param {Object|string} skillOrId - Skill object ou ID
         * @returns {string} - Chave da fam√≠lia
         */
        function getSkillFamilyKey(skillOrId) {
            const skill = typeof skillOrId === "object" ? skillOrId : getSkillById(skillOrId);
            const id = String(skill?.id ?? skillOrId ?? "");
            const name = String(skill?.name ?? skill?.nome ?? "");

            // 1) por ID (mais confi√°vel)
            if (id) {
                // exemplos: FIREBALL_I, FIREBALL_II, FIREBALL_III
                let base = id
                    .replace(/(_I|_II|_III)$/i, "")
                    .replace(/(-I|-II|-III)$/i, "");
                if (base !== id) return base;
            }

            // 2) por nome
            if (name) {
                const baseName = name.replace(/\s+(I|II|III)$/i, "").trim();
                if (baseName && baseName !== name) return baseName.toLowerCase();
            }

            // 3) fallback: o pr√≥prio id
            return id || name.toLowerCase() || "";
        }

        /**
         * Busca variante de skill pela fam√≠lia e tier desejado
         * @param {string} familyKey - Chave da fam√≠lia da skill
         * @param {number} tier - Tier desejado (1, 2, ou 3)
         * @returns {Object|null} - Skill encontrada ou null
         */
        function findSkillVariantByFamily(familyKey, tier) {
            const cat = getSkillCatalog();
            if (!familyKey || !cat.length) return null;

            const roman = tier === 3 ? "III" : tier === 2 ? "II" : "I";
            const fk = String(familyKey);

            // tentar padr√µes de ID
            const idCandidates = [
                `${fk}_${roman}`, `${fk}-${roman}`,
                `${fk.toUpperCase()}_${roman}`, `${fk.toUpperCase()}-${roman}`,
            ];

            for (const cand of idCandidates) {
                const hit = cat.find(s => String(s.id) === cand);
                if (hit) return hit;
            }

            // tentar por fam√≠lia via getSkillFamilyKey + nome com sufixo
            const romanNameSuffix = " " + roman;
            const fkLower = fk.toLowerCase();

            // primeira passada: fam√≠lia igual + nome termina com roman
            for (const s of cat) {
                const fam = getSkillFamilyKey(s);
                const nm = String(s.name ?? s.nome ?? "");
                if (fam && String(fam).toLowerCase() === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            // segunda passada: nome base igual + roman
            for (const s of cat) {
                const nm = String(s.name ?? s.nome ?? "");
                const base = nm.replace(/\s+(I|II|III)$/i, "").trim().toLowerCase();
                if (base && base === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            return null;
        }
        
        // =============================
        // FEATURE 3.8 ‚Äî BATTLE POLISH (VISUAL FEEDBACK)
        // =============================
        
        /**
         * Mostra texto flutuante (dano/cura) sobre um elemento
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} text - Texto a exibir (ex: "-12", "+8")
         * @param {string} kind - Tipo: "damage", "heal", "crit"
         */
        function showFloatingText(target, text, kind = 'damage') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const floater = document.createElement('div');
                floater.className = `floating-text ${kind}`;
                floater.textContent = text;
                
                // Posicionar no centro do elemento alvo
                const rect = element.getBoundingClientRect();
                floater.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floater.style.top = `${rect.top + rect.height / 2 - 20}px`;
                
                document.body.appendChild(floater);
                
                // Remover ap√≥s anima√ß√£o
                setTimeout(() => floater.remove(), 1000);
            } catch (error) {
                console.error('showFloatingText error:', error);
            }
        }
        
        /**
         * Aplica efeito de flash no alvo
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} type - Tipo: "crit", "fail", "hit"
         */
        function flashTarget(target, type = 'hit') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const className = `flash-${type}`;
                element.classList.add(className);
                
                setTimeout(() => element.classList.remove(className), 400);
            } catch (error) {
                console.error('flashTarget error:', error);
            }
        }
        
        /**
         * Armazena o √∫ltimo roll de d20 no encounter
         * @param {Object} enc - Encounter
         * @param {string} name - Nome de quem rolou
         * @param {number} roll - Valor do d20
         * @param {string} type - "crit", "fail", ou "normal"
         */
        function recordD20Roll(enc, name, roll, type = 'normal') {
            if (!enc) return;
            enc.lastRoll = { name, roll, type };
        }

        /**
         * Tenta fazer upgrade autom√°tico das skills quando monstro muda de est√°gio
         * @param {Object} mon - Monstro
         * @param {Array} logArr - Array de log (opcional)
         */
        function maybeUpgradeSkillsModelB(mon, logArr) {
            if (!mon) return;

            const stageNow = getMonsterStage(mon.level);
            const tierNow = getDesiredSkillTier(stageNow);

            // dedupe: s√≥ roda quando est√°gio muda
            if (mon._skillStage === stageNow) return;

            const skills = getSkillsArray(mon);
            if (!skills.length) {
                // MVP: se n√£o tem skills, n√£o inventa. Apenas marca est√°gio para n√£o spammar.
                mon._skillStage = stageNow;
                return;
            }

            let changed = false;
            const newSkills = skills.map(oldId => {
                const oldSkill = getSkillById(oldId);
                const family = getSkillFamilyKey(oldSkill || oldId);
                if (!family) return oldId;

                const variant = findSkillVariantByFamily(family, tierNow);
                if (!variant) return oldId;

                const newId = String(variant.id);
                if (newId && newId !== String(oldId)) {
                    changed = true;

                    const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                    const newName = variant.name || variant.nome || newId;

                    if (Array.isArray(logArr)) {
                        logArr.push(`üéì ${monName} aprendeu ${newName}!`);
                    }
                    return newId;
                }
                return oldId;
            });

            if (changed) setSkillsArray(mon, newSkills);

            mon._skillStage = stageNow;
        }
        
        // =============================
        // FEATURE 3.7 ‚Äî SKILLS HUD UI
        // =============================
        
        /**
         * Formata o label de um bot√£o de skill mostrando nome e custo ENE
         * @param {Object} skill - Skill do cat√°logo
         * @param {Object} mon - Monstro (para contexto futuro se necess√°rio)
         * @returns {string} - Label formatado
         */
        function formatSkillButtonLabel(skill, mon) {
            if (!skill) return "Habilidade";
            
            const name = skill.name || skill.nome || String(skill.id);
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const power = Number(skill.power ?? skill.POWER ?? skill.pwr ?? 0) || 0;
            
            // emoji opcional: se j√° tiver no dataset, usa
            const icon = skill.icon || "";
            
            // MVP: nome + ENE (sem poluir)
            const parts = [];
            if (icon) parts.push(icon);
            parts.push(name);
            if (cost > 0) parts.push(`(ENE ${cost})`);
            
            return parts.join(" ");
        }
        
        /**
         * Verifica se o monstro tem ENE suficiente para usar a skill
         * @param {Object} skill - Skill do cat√°logo
         * @param {Object} mon - Monstro
         * @returns {boolean} - true se pode usar
         */
        function canUseSkillNow(skill, mon) {
            if (!skill || !mon) return false;
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const ene = Number(mon.ene ?? mon.ENE ?? 0) || 0;
            return ene >= cost;
        }
        
        /**
         * Distribui XP para todos participantes vivos de uma batalha em grupo
         * @param {Object} enc - Encounter de grupo
         */
        function distributeGroupXP(enc) {
            if (!enc || !enc.rewards || !enc.rewards.xp) return;
            
            const xp = enc.rewards.xp;
            
            enc.participants.forEach(pid => {
                const player = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(player);
                
                // S√≥ ganha XP se estiver vivo
                if (!mon || mon.hp <= 0) return;
                
                giveXP(mon, xp);
            });
        }
        
        /**
         * Distribui XP para o jogador de uma batalha wild (1v1)
         * @param {Object} encounter - Encounter wild
         */
        function distributeWildXP(encounter) {
            if (!encounter || !encounter.rewards || !encounter.rewards.xp) return;
            
            const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
            const mon = player?.team?.[0];
            
            // S√≥ ganha XP se estiver vivo
            if (!mon || mon.hp <= 0) return;
            
            giveXP(mon, encounter.rewards.xp);
        }
        
        /**
         * PR8B: WRAPPER - Progression.Actions.handleVictoryRewards()
         * Distribui recompensas de vit√≥ria de forma idempotente (XP + recompensas futuras)
         * Previne duplica√ß√£o via flag rewardsGranted
         * @param {Object} enc - Encounter (wild ou group)
         */
        function handleVictoryRewards(enc) {
            return Progression.Actions.handleVictoryRewards(createProgressionDeps(), enc);
        }
        
        /**
         * PR5C: WRAPPER - Combat.Group.UI.renderGroupEncounterPanel()
         * Renderiza UI do encounter de grupo
         */
        function renderGroupEncounter(panel, encounter) {
            try {
                const deps = {
                    state: GameState,
                    core: GroupCore,
                    helpers: {
                        renderTutorialBanner: renderTutorialBanner,
                        ensureXpFields: ensureXpFields,
                        calcXpNeeded: calcXpNeeded,
                        getSkillsArray: getSkillsArray,
                        getSkillById: getSkillById,
                        formatSkillButtonLabel: formatSkillButtonLabel,
                        canUseSkillNow: canUseSkillNow,
                        saveToLocalStorage: saveToLocalStorage,
                        maybeToastFromLog: maybeToastFromLog,
                        maybeSfxFromLog: maybeSfxFromLog,
                        formatEquippedItemDisplay: formatEquippedItemDisplay
                    }
                };
                Combat.Group.UI.renderGroupEncounterPanel(panel, encounter, deps);
            } catch (error) {
                showError('Failed to render group encounter', error.stack);
            }
        }

        function renderEncounter() {
            try {
                const panel = document.getElementById('encounterPanel');
                if (!panel) return;
                
                const encounter = GameState.currentEncounter;
                
                if (!encounter || !encounter.active) {
                    hideEl(panel);
                    return;
                }
                
                showEl(panel);
                
                if (encounter.type === 'wild') {
                    renderWildEncounter(panel, encounter);
                } else if (encounter.type === 'group_trainer' || encounter.type === 'boss') {
                    renderGroupEncounter(panel, encounter);
                } else {
                    panel.innerHTML = '<div class="encounter-panel"><h3>Encounter type not yet implemented</h3></div>';
                }
            } catch (error) {
                showError('Failed to render encounter', error.stack);
            }
        }

        function renderWildEncounter(panel, encounter) {
            try {
                const monster = encounter.wildMonster;
                if (!monster) return;
                
                // Buscar jogador selecionado
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                const playerMonster = player?.team?.[0];
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const canCapture = hpPercent <= baseThreshold;
                
                const html = `
                    <div class="encounter-panel">
                        ${renderTutorialBanner(encounter)}
                        <h3>Wild ${monster.emoji} ${monster.name} appeared!</h3>
                        ${encounter.lastRoll ? (() => {
                            const lr = encounter.lastRoll;
                            const badgeClass = lr.type === 'crit' ? 'crit' : lr.type === 'fail' ? 'fail' : '';
                            const emoji = lr.type === 'crit' ? 'üåü' : lr.type === 'fail' ? 'üí•' : 'üé≤';
                            return `<div class="d20-badge ${badgeClass}">${emoji} ${lr.name}: ${lr.roll} ${lr.type === 'crit' ? '(CRIT!)' : lr.type === 'fail' ? '(FALHA!)' : ''}</div>`;
                        })() : ''}
                        ${player ? `<p><strong>Jogador:</strong> ${player.name} (${player.class})</p>` : ''}
                        ${playerMonster ? (() => {
                            const xpCurrent = playerMonster.xp || 0;
                            const xpNeeded = playerMonster.xpNeeded || calcXpNeeded(playerMonster.level);
                            const xpPercent = Math.max(0, Math.min(100, (xpCurrent / xpNeeded) * 100));
                            
                            return `
                        <div id="wildPlayerBox" class="player-select-box">
                            <p><strong>Seu Monstrinho:</strong> ${playerMonster.emoji} ${playerMonster.name} (Nv ${playerMonster.level})</p>
                            <div><strong>HP:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                            <div><strong>‚ö° ENE:</strong> ${playerMonster.ene || 0}/${playerMonster.eneMax || 0}</div>
                            <div class="progress-bar h-15 mt-5">
                                <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                            </div>
                            <small><strong>XP:</strong> ${xpCurrent}/${xpNeeded} (${Math.floor(xpPercent)}%)</small>
                            ${formatEquippedItemDisplay(playerMonster.heldItemId)}
                        </div>
                        `;
                        })() : ''}
                        
                        <div id="wildEnemyBox" class="monster-card enemy-box ${monster.class}">
                            <div class="font-size-48">${monster.emoji}</div>
                            <strong>${monster.name}</strong>
                            ${monster.isShiny ? '<div class="badge badge-shiny">‚≠ê SHINY ‚≠ê</div>' : ''}
                            <div class="badge badge-${monster.rarity}">${monster.rarity}</div>
                            <div><strong>Classe:</strong> ${monster.class}</div>
                            <div><strong>Level:</strong> ${monster.level}</div>
                            <div class="mt-8">
                                <div><strong>ATK:</strong> ${monster.atk} | <strong>DEF:</strong> ${monster.def}</div>
                                <div><strong>PODER:</strong> ${monster.poder}</div>
                                <div><strong>‚ö° ENE:</strong> ${monster.ene || 0}/${monster.eneMax || 0}</div>
                            </div>
                            <div class="progress-bar mt-10">
                                <div class="progress-fill hp" style="width: ${(monster.hp / monster.hpMax) * 100}%">
                                    ${monster.hp}/${monster.hpMax} HP (${Math.floor(hpPercent * 100)}%)
                                </div>
                            </div>
                            ${canCapture ? 
                                '<div class="color-success mt-5">‚úÖ HP baixo! Pode tentar captura!</div>' : 
                                `<div class="color-warning mt-5">‚ö†Ô∏è Abaixe HP para ${Math.floor(baseThreshold * 100)}% para capturar</div>`
                            }
                        </div>
                        
                        <h4>Choose Action:</h4>
                        <div class="flex-center-col">
                            <div class="my-10">
                                <label class="d20-label">üé≤ Enter your d20 roll:</label>
                                <input type="number" id="diceRoll" min="1" max="20" placeholder="1-20" 
                                       class="d20-input">
                            </div>
                            
                            ${player ? (() => {
                                const comum = player.inventory?.['CLASTERORB_COMUM'] || 0;
                                const incomum = player.inventory?.['CLASTERORB_INCOMUM'] || 0;
                                const rara = player.inventory?.['CLASTERORB_RARA'] || 0;
                                const hasAnyOrb = comum > 0 || incomum > 0 || rara > 0;
                                
                                return `
                                <div class="capture-system-box">
                                    <strong class="capture-system-title">üéØ Sistema de Captura</strong>
                                    <div class="mt-10">
                                        <div><strong>HP% Selvagem:</strong> ${Math.floor(hpPercent * 100)}%</div>
                                        <div><strong>Base Threshold (${monster.rarity}):</strong> ${Math.floor(baseThreshold * 100)}%</div>
                                        <div><strong>B√¥nus HP Baixo (‚â§25%):</strong> ${hpPercent <= 0.25 ? '+10%' : '0%'}</div>
                                    </div>
                                    
                                    ${hasAnyOrb ? `
                                    <div class="mt-10">
                                        <label class="text-bold">Escolha sua ClasterOrb:</label>
                                        <select id="captureOrbSelect" onchange="updateCaptureThreshold()" class="orb-select">
                                            ${comum > 0 ? `<option value="CLASTERORB_COMUM">‚ö™ Comum (${comum}x) - +0% bonus</option>` : ''}
                                            ${incomum > 0 ? `<option value="CLASTERORB_INCOMUM">üîµ Incomum (${incomum}x) - +5% bonus</option>` : ''}
                                            ${rara > 0 ? `<option value="CLASTERORB_RARA">üü£ Rara (${rara}x) - +10% bonus</option>` : ''}
                                        </select>
                                    </div>
                                    <div id="captureThresholdDisplay" class="capture-threshold-box">
                                        <strong>Threshold Final:</strong> <span id="finalThresholdValue">Calculando...</span>
                                    </div>
                                    ` : `
                                    <div class="capture-warning">
                                        <strong>‚ùå Sem ClasterOrbs!</strong><br>
                                        Voc√™ n√£o tem orbes de captura dispon√≠veis.
                                    </div>
                                    `}
                                    
                                    <div class="mt-10">
                                        <strong>üì¶ Invent√°rio:</strong> 
                                        ‚ö™ ${comum} | üîµ ${incomum} | üü£ ${rara} | 
                                        üíö Cura: ${player.inventory?.['IT_HEAL_01'] || 0}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                            
                            <div class="flex-center">
                                ${player && (player.inventory?.['CLASTERORB_COMUM'] > 0 || player.inventory?.['CLASTERORB_INCOMUM'] > 0 || player.inventory?.['CLASTERORB_RARA'] > 0) ? 
                                    `<button class="btn btn-success btn-large" onclick="attemptCapture()" ${tutorialAllows("capture") ? "" : "disabled title='Tutorial: ainda n√£o liberado'"}>üéØ Tentar Capturar</button>` :
                                    `<button class="btn btn-success btn-large opacity-50" disabled>üéØ Sem Orbes</button>`
                                }
                                ${playerMonster && monster ? (() => {
                                    // FASE 1 POKEMON: Indicador Visual de Vantagem de Classe
                                    const advantage = getClassAdvantage(playerMonster.class, monster.class);
                                    const advantageHtml = advantage.cssClass !== 'neutral' ? 
                                        `<div class="class-advantage-indicator ${advantage.cssClass}">${advantage.text}</div>` : '';
                                    
                                    return `
                                        ${advantageHtml}
                                        <button class="btn btn-danger btn-large" onclick="attackWild()" ${tutorialAllows("attack") ? "" : "disabled title='Tutorial: ainda n√£o liberado'"}>‚öîÔ∏è Attack</button>
                                    `;
                                })() : '<button class="btn btn-danger btn-large" onclick="attackWild()">‚öîÔ∏è Attack</button>'}
                                <button class="btn btn-warning btn-large" onclick="fleeEncounter()" ${tutorialAllows("flee") ? "" : "disabled title='Tutorial: ainda n√£o liberado'"}>üèÉ Flee</button>
                            </div>
                            
                            ${playerMonster && player ? (() => {
                                const healItems = player.inventory?.['IT_HEAL_01'] || 0;
                                const canUseItem = healItems > 0 && playerMonster.hp > 0 && playerMonster.hp < playerMonster.hpMax;
                                
                                return `
                                <div class="heal-box">
                                    <strong class="font-size-16 text-bold">üíö Usar Item de Cura</strong>
                                    <div class="mt-10">
                                        <div><strong>Petisco de Cura dispon√≠vel:</strong> ${healItems}x</div>
                                        <div><strong>HP atual:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                                        ${!canUseItem && healItems === 0 ? 
                                            `<div class="color-error mt-5">‚ùå Sem itens de cura dispon√≠veis</div>` : 
                                            !canUseItem && playerMonster.hp <= 0 ? 
                                            `<div class="color-error mt-5">‚ùå Monstrinho desmaiado, n√£o pode usar item</div>` :
                                            !canUseItem && playerMonster.hp >= playerMonster.hpMax ?
                                            `<div class="color-warning mt-5">‚ö†Ô∏è HP j√° est√° cheio</div>` : ''
                                        }
                                    </div>
                                    <button class="btn btn-primary mt-10 w-100" 
                                            onclick="useItemInBattle('IT_HEAL_01')"
                                            ${!canUseItem || !tutorialAllows("item") ? 'disabled class="opacity-50"' : ''}
                                            ${!tutorialAllows("item") ? 'title="Tutorial: ainda n√£o liberado"' : ''}>
                                        üíö Usar Petisco de Cura
                                    </button>
                                </div>
                                `;
                            })() : ''}
                            
                            ${playerMonster ? (() => {
                                // Feature 3.7: Use skill catalog and getSkillsArray
                                const skillIds = getSkillsArray(playerMonster);
                                if (!skillIds || skillIds.length === 0) return '';
                                
                                return `
                                <div class="skills-box">
                                    <strong class="skills-title">‚ú® Habilidades</strong>
                                    <div class="flex-center flex-gap-10 mt-10">
                                        ${skillIds.map((skillId, idx) => {
                                            const skill = getSkillById(skillId);
                                            if (!skill) return '';
                                            
                                            const label = formatSkillButtonLabel(skill, playerMonster);
                                            const canUse = canUseSkillNow(skill, playerMonster) && playerMonster.hp > 0;
                                            const tutAllows = tutorialAllows("skill");
                                            const tooltip = !tutAllows ? 'Tutorial: ainda n√£o liberado' : (canUse ? (skill.desc || skill.descricao || '') : 'Sem ENE');
                                            
                                            return `
                                            <button class="btn btn-primary" 
                                                    onclick="useSkillWild(${idx})" 
                                                    ${!canUse || !tutAllows ? 'disabled class="opacity-50"' : ''}
                                                    title="${tooltip}">
                                                ${label}
                                            </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                        </div>
                        
                        <div class="combat-log mt-20 p-15 bg-light-gray border-radius-12 max-h-300 overflow-auto" id="combatLog">
                            ${(encounter.log || []).map(entry => `<div class="py-8 border-bottom-gray">${entry}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                panel.innerHTML = html;
                
                // Atualizar threshold inicial
                setTimeout(() => updateCaptureThreshold(), 100);
                
                // Exibir toasts para eventos importantes (level up, evolu√ß√£o)
                maybeToastFromLog(GameState.currentEncounter);
                
                // Feature 4.4: Tocar sons para level up e evolu√ß√£o
                maybeSfxFromLog(GameState.currentEncounter);
            } catch (error) {
                showError('Failed to render wild encounter', error.stack);
            }
        }

        // Atualizar c√°lculo de threshold de captura em tempo real
        function updateCaptureThreshold() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const select = document.getElementById('captureOrbSelect');
                const display = document.getElementById('finalThresholdValue');
                if (!select || !display) return;
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) return;
                
                // Calcular threshold
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const orbBonus = orbInfo.capture_bonus_pp / 100; // Converter pp para decimal
                const lowHpBonus = hpPercent <= 0.25 ? 0.10 : 0;
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                // Atualizar display
                display.innerHTML = `
                    <span class="hp-threshold-text" style="color: ${hpPercent <= thresholdFinal ? '#2e7d32' : '#c62828'};">
                        ${Math.floor(thresholdFinal * 100)}%
                    </span>
                    <br><small>
                        (Base ${Math.floor(baseThreshold * 100)}% + Orb ${orbInfo.capture_bonus_pp}% + HP ${Math.floor(lowHpBonus * 100)}%)
                        <br>${hpPercent <= thresholdFinal ? '‚úÖ Captura prov√°vel!' : '‚ùå HP muito alto'}
                    </small>
                `;
            } catch (error) {
                console.error('Failed to update capture threshold:', error);
            }
        }

        function attemptCapture() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                // Valida√ß√£o: HP > 0 obrigat√≥rio
                if (monster.hp <= 0) {
                    alert('‚ùå N√£o pode capturar um monstrinho desmaiado! HP deve ser > 0.');
                    return;
                }
                
                // Obter ClasterOrb selecionada
                const select = document.getElementById('captureOrbSelect');
                if (!select) {
                    alert('‚ùå Erro ao ler sele√ß√£o de ClasterOrb.');
                    return;
                }
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) {
                    alert('‚ùå ClasterOrb inv√°lida.');
                    return;
                }
                
                // Valida√ß√£o: precisa ter a orb selecionada
                player.inventory = player.inventory || {};
                const orbCount = player.inventory[selectedOrbId] || 0;
                
                if (orbCount <= 0) {
                    alert(`‚ùå Voc√™ n√£o tem ${orbInfo.name}!`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // SEMPRE CONSOME 1 item (mesmo se falhar)
                player.inventory[selectedOrbId]--;
                encounter.log.push(`${orbInfo.emoji} ${player.name} usou ${orbInfo.name}! (Restam: ${player.inventory[selectedOrbId]})`);
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                
                // B√¥nus se HP <= 25%
                let lowHpBonus = 0;
                if (hpPercent <= 0.25) {
                    lowHpBonus = 0.10;
                    encounter.log.push(`‚ú® HP cr√≠tico! B√¥nus de +10% na captura!`);
                }
                
                // B√¥nus da orb (em decimal: 0, 0.05, 0.10)
                const orbBonus = orbInfo.capture_bonus_pp / 100;
                
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                encounter.log.push(`HP: ${Math.floor(hpPercent * 100)}% | Base: ${Math.floor(baseThreshold * 100)}% | Orb: +${orbInfo.capture_bonus_pp}% | HP Bonus: +${Math.floor(lowHpBonus * 100)}%`);
                encounter.log.push(`üéØ Threshold Final: ${Math.floor(thresholdFinal * 100)}%`);
                
                // FASE 1 POKEMON: Rastrear tentativa de captura
                updateStats('captureAttempts', 1);
                
                // Captura determin√≠stica: sucesso se HP% <= Threshold_final
                if (hpPercent <= thresholdFinal) {
                    encounter.log.push(`‚úÖ SUCESSO! ${monster.name} foi capturado!`);
                    
                    // Feature 4.4: Capture success sound
                    Audio.playSfx("capture_ok");
                    
                    monster.ownerId = player.id;
                    
                    player.team = player.team || [];
                    player.box = player.box || [];
                    
                    if (player.team.length < (GameState.config?.maxTeamSize || 6)) {
                        player.team.push(monster);
                        encounter.log.push(`${monster.name} foi adicionado ao time de ${player.name}!`);
                    } else {
                        player.box.push(monster);
                        encounter.log.push(`${monster.name} foi enviado para a caixa de ${player.name}!`);
                    }
                    
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                    
                    // FASE 1 POKEMON: Rastrear captura bem-sucedida
                    updateStats('capturesSuccessful', 1);
                    
                    // FASE 1 POKEMON: Adicionar ao Monstr√≥dex como capturado
                    if (monster.monsterId || monster.templateId) {
                        updateMonstrodex('capture', monster.monsterId || monster.templateId);
                    }
                    
                    // PR16A: Mark as captured in PartyDex and check milestones
                    if (window.PartyDex && (monster.monsterId || monster.templateId)) {
                        const templateId = monster.monsterId || monster.templateId;
                        window.PartyDex.onMonsterAddedToGroup(GameState, templateId, {
                            showToast: showToast,
                            saveToLocalStorage: saveToLocalStorage
                        });
                    }
                    
                    // Feature 4.2: Tutorial hook
                    tutorialOnAction("capture");
                    
                    encounter.active = false;
                    GameState.currentEncounter = null;
                } else {
                    // FALHA: Monstrinho realiza 1 ataque b√°sico IMEDIATO
                    encounter.log.push(`‚ùå FALHA! ${monster.name} quebrou livre!`);
                    
                    // Feature 4.4: Capture fail sound
                    Audio.playSfx("capture_fail");
                    
                    const playerMonster = player.team?.[0];
                    if (playerMonster && playerMonster.hp > 0) {
                        encounter.log.push(`‚ö° ${monster.name} contra-ataca!`);
                        
                        // Monstrinho selvagem ataca imediatamente
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, monster, playerMonster));
                        encounter.log.push(`üé≤ ${monster.name} rola ${enemyRoll} (ATK: ${monster.atk})`);
                        
                        // Feature 4.4: Enemy counter-attack sound (wild - after failed capture)
                        const enemyIsCrit = (enemyRoll === 20);
                        const enemyIsFail = (enemyRoll === 1);
                        if (enemyIsCrit) {
                            Audio.playSfx("crit");
                        } else if (enemyIsFail || !enemyHit) {
                            Audio.playSfx("miss");
                        } else {
                            Audio.playSfx("hit");
                        }
                        
                        if (enemyHit) {
                            const damage = calculateDamage(monster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${monster.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`‚ùå ${monster.name} erra o ataque!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Capture attempt failed', error.stack);
            }
        }

        // Feature 3.1: Usar Item em Batalha
        function useItemInBattle(itemId) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('Nenhum jogador selecionado para este encontro');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Jogador n√£o tem monstrinhos no time');
                    return;
                }
                
                // VALIDA√á√ïES (GAME_RULES.md)
                
                // 1. Validar HP > 0 (monstrinho n√£o desmaiado)
                if (playerMonster.hp <= 0) {
                    alert('‚ùå N√£o pode usar item! Monstrinho est√° desmaiado (HP = 0).');
                    return;
                }
                
                // 2. Validar HP < HPMax (n√£o usar se j√° est√° cheio)
                if (playerMonster.hp >= playerMonster.hpMax) {
                    alert('‚ö†Ô∏è HP j√° est√° no m√°ximo! N√£o √© necess√°rio usar item de cura.');
                    return;
                }
                
                // 3. Validar item dispon√≠vel no invent√°rio
                player.inventory = player.inventory || {};
                const itemCount = player.inventory[itemId] || 0;
                
                if (itemCount <= 0) {
                    alert('‚ùå Voc√™ n√£o tem Petisco de Cura dispon√≠vel!');
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // CONSUMIR 1 unidade do item
                player.inventory[itemId]--;
                encounter.log.push(`üíö ${player.name} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                
                // APLICAR CURA
                // Petisco de Cura: restaura 30 HP ou 30% do HP m√°ximo (o que for maior)
                const healAmount = Math.max(30, Math.floor(playerMonster.hpMax * 0.30));
                const hpBefore = playerMonster.hp;
                playerMonster.hp = Math.min(playerMonster.hpMax, playerMonster.hp + healAmount);
                const actualHeal = playerMonster.hp - hpBefore;
                
                encounter.log.push(`‚ú® ${playerMonster.name} recuperou ${actualHeal} HP! (${playerMonster.hp}/${playerMonster.hpMax})`);
                
                // SISTEMA DE AMIZADE: Ganhar amizade ao usar item de cura
                updateFriendship(playerMonster, 'useHealItem');
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("item");
                
                // Feature 4.4: Heal sound
                Audio.playSfx("heal");
                
                // SALVAR ESTADO
                saveToLocalStorage();
                renderEncounter();
                
                // Feature 3.8: Visual feedback for healing
                setTimeout(() => {
                    showFloatingText('wildPlayerBox', `+${actualHeal}`, 'heal');
                }, 50);
                
                // INIMIGO ATACA (contra-ataque autom√°tico ap√≥s usar item)
                if (encounter.wildMonster.hp > 0) {
                    encounter.log.push(`‚öîÔ∏è Vez do inimigo...`);
                    
                    const wildMonster = encounter.wildMonster;
                    
                    // Aplicar ENE regen do inimigo
                    applyEneRegen(wildMonster, encounter);
                    
                    // Atualizar buffs do inimigo
                    updateBuffs(wildMonster);
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const wildSkills = getMonsterSkills(wildMonster);
                    const canUseSkill = wildSkills && wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                    const shouldUseSkill = canUseSkill && Math.random() < 0.5;
                    
                    if (shouldUseSkill) {
                        const skill = wildSkills[0];
                        wildMonster.ene -= skill.cost;
                        encounter.log.push(`‚ú® ${wildMonster.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                        
                        // Usar habilidade
                        useSkill(wildMonster, skill, playerMonster, encounter);
                    } else {
                        // Ataque b√°sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        encounter.log.push(`üé≤ ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, wildMonster, playerMonster));
                        
                        // Feature 4.4: Enemy counter-attack sound (wild - after item)
                        const enemyIsCrit = (enemyRoll === 20);
                        const enemyIsFail = (enemyRoll === 1);
                        if (enemyIsCrit) {
                            Audio.playSfx("crit");
                        } else if (enemyIsFail || !enemyHit) {
                            Audio.playSfx("miss");
                        } else {
                            Audio.playSfx("hit");
                        }
                        
                        if (enemyHit) {
                            // Commit 12 (Wave C12.3.2): Use MM_TABLES for basic attack power
                            const power = MM_TABLES.getBasicAttackPower(wildMonster.class);
                            
                            const atkMods = getBuffModifiers(wildMonster);
                            const effectiveAtk = Math.max(1, wildMonster.atk + atkMods.atk);
                            
                            const defMods = getBuffModifiers(playerMonster);
                            const effectiveDef = Math.max(1, playerMonster.def + defMods.def);
                            
                            const classAdv = GameState.config?.classAdvantages?.[wildMonster.class];
                            let damageMult = 1.0;
                            if (classAdv?.strong === playerMonster.class) {
                                damageMult = 1.10;
                            } else if (classAdv?.weak === playerMonster.class) {
                                damageMult = 0.90;
                            }
                            
                            const damage = calcDamage({
                                atk: effectiveAtk,
                                def: effectiveDef,
                                power: power,
                                damageMult: damageMult
                            });
                            
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`üí• ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Verificar se jogador perdeu
                            if (playerMonster.hp <= 0) {
                                // SISTEMA DE AMIZADE: Perder amizade ao desmaiar
                                updateFriendship(playerMonster, 'faint');
                                
                                encounter.log.push(`üíÄ ${playerMonster.name} fainted! Defeat!`);
                                
                                // Feature 4.4: Defeat sound (com idempot√™ncia)
                                if (!encounter._loseSfxPlayed) {
                                    Audio.playSfx("lose");
                                    encounter._loseSfxPlayed = true;
                                }
                                
                                encounter.active = false;
                                GameState.currentEncounter = null;
                                saveToLocalStorage();
                                renderEncounter();
                                return;
                            }
                        } else {
                            if (enemyRoll === 1) {
                                encounter.log.push(`üíÄ FALHA CR√çTICA! ${wildMonster.name} erra!`);
                            } else {
                                encounter.log.push(`‚ùå ${wildMonster.name} misses!`);
                            }
                        }
                    }
                }
                
                // RENDER atualizado
                saveToLocalStorage();
                renderEncounter();
                
            } catch (error) {
                showError('Failed to use item in battle', error.stack);
            }
        }

        // ===== COMBAT WILD 1v1 - Wrapper de Compatibilidade =====
        // Mant√©m API p√∫blica, delega para m√≥dulo Combat
        function attackWild() {
            try {
                // 1. Valida√ß√µes iniciais
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Player has no monsters in team');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho √© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`‚ö†Ô∏è Voc√™ s√≥ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} √© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // 2. Capturar input do usu√°rio
                const d20Roll = Combat.UI.getCombatInputRoll();
                if (!d20Roll) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                Combat.UI.clearCombatInput();
                
                // 3. Preparar depend√™ncias
                const dependencies = {
                    classAdvantages: GameState.config?.classAdvantages || {},
                    getBasicPower: (monsterClass) => MM_TABLES.getBasicAttackPower(monsterClass),
                    eneRegenData: ENE_REGEN_BY_CLASS,
                    recordD20Roll: recordD20Roll,
                    audio: Audio,
                    ui: {
                        flashTarget: flashTarget,
                        showFloatingText: showFloatingText
                    },
                    tutorialOnAction: tutorialOnAction,
                    updateFriendship: updateFriendship,
                    updateMultipleFriendshipEvents: updateMultipleFriendshipEvents,
                    handleVictoryRewards: handleVictoryRewards,
                    updateStats: updateStats,
                    showToast: showToast
                };
                
                // 4. Executar combate via m√≥dulo
                const result = Combat.Actions.executeWildAttack({
                    encounter,
                    player,
                    playerMonster,
                    d20Roll,
                    dependencies
                });
                
                // 5. Processar resultado
                if (!result.success) {
                    console.error('Attack failed:', result.reason);
                    return;
                }
                
                // 6. Limpar encounter se terminou
                if (result.result === 'victory' || result.result === 'defeat') {
                    GameState.currentEncounter = null;
                }
                
                // 7. Atualizar UI (1 vez s√≥ ao final)
                saveToLocalStorage();
                renderEncounter();
                
            } catch (error) {
                showError('Attack failed', error.stack);
            }
        }

        // Usar habilidade contra o selvagem (por √≠ndice 0, 1, 2)
        function useSkillWild(skillIndex) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('No monster available');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho √© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`‚ö†Ô∏è Voc√™ s√≥ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} √© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Obter habilidades dispon√≠veis
                const skills = getMonsterSkills(playerMonster);
                if (!skills || skillIndex >= skills.length || !skills[skillIndex]) {
                    alert('Skill not available');
                    return;
                }
                
                const skill = skills[skillIndex];
                
                // Validar ENE suficiente
                if ((playerMonster.ene || 0) < skill.cost) {
                    alert(`‚ùå ENE insuficiente! Precisa de ${skill.cost} ENE.`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no in√≠cio do turno
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs
                updateBuffs(playerMonster);
                
                // Usar habilidade
                const success = useSkill(playerMonster, skill, encounter.wildMonster, encounter);
                
                if (!success) {
                    alert('Failed to use skill');
                    return;
                }
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("skill");
                
                // Verificar se o selvagem foi derrotado
                if (encounter.wildMonster.hp <= 0) {
                    encounter.log.push(`üèÜ ${encounter.wildMonster.name} foi derrotado!`);
                    const xpGained = calculateBattleXP(encounter.wildMonster);
                    giveXP(playerMonster, xpGained, encounter.log);
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }
                
                // Fase 2: Contra-ataque do selvagem
                const wildMonster = encounter.wildMonster;
                
                // Atualizar buffs do selvagem
                updateBuffs(wildMonster);
                
                // IA: 50% chance de usar habilidade se tiver ENE
                const wildSkills = getMonsterSkills(wildMonster);
                const canUseSkill = wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                const useWildSkill = canUseSkill && Math.random() < 0.5;
                
                if (useWildSkill) {
                    // Selvagem usa habilidade
                    useSkill(wildMonster, wildSkills[0], playerMonster, encounter);
                    
                    if (playerMonster.hp <= 0) {
                        encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                        playerMonster.status = 'fainted';
                        encounter.active = false;
                        GameState.currentEncounter = null;
                    }
                } else {
                    // Ataque b√°sico do selvagem
                    const enemyRoll = Math.floor(Math.random() * 20) + 1;
                    const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                    encounter.log.push(`üé≤ ${wildMonster.name} rola ${enemyRoll} (ATK: ${wildMonster.atk})`);
                    
                    if (enemyHit) {
                        const mods = getBuffModifiers(wildMonster);
                        const effectiveAtk = wildMonster.atk + mods.atk;
                        const damage = calculateDamage(wildMonster, playerMonster);
                        playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                        encounter.log.push(`üí• ${wildMonster.name} acerta! Causa ${damage} de dano!`);
                        
                        if (playerMonster.hp <= 0) {
                            encounter.log.push(`üòµ ${playerMonster.name} desmaiou!`);
                            playerMonster.status = 'fainted';
                            encounter.active = false;
                            GameState.currentEncounter = null;
                        }
                    } else {
                        encounter.log.push(`‚ùå ${wildMonster.name} erra!`);
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Skill use failed', error.stack);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SISTEMA DE DANO - F√≥rmulas Oficiais (GAME_RULES.md)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Verifica se um ataque acerta o alvo
         * F√ìRMULA: d20 + ATK + ClassBonus >= DEF
         * 
         * @param {number} d20Roll - Resultado do dado d20 (1-20)
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {boolean} true se acertou, false se errou
         * 
         * VANTAGEM DE CLASSE (Acerto):
         * - Vantagem: +2 ATK
         * - Desvantagem: -2 ATK
         * 
         * REGRAS ESPECIAIS:
         * - d20 = 1: sempre erra (falha cr√≠tica)
         * - d20 = 20: sempre acerta (acerto cr√≠tico)
         */
        function checkHit(d20Roll, attacker, defender) {
            try {
                if (!attacker || !defender) return false;
                
                const atkMod = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +2 ATK se forte, -2 ATK se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let atkBonus = 0;
                if (classAdv?.strong === defender.class) {
                    atkBonus = 2;
                } else if (classAdv?.weak === defender.class) {
                    atkBonus = -2;
                }
                
                const totalAtk = d20Roll + atkMod + atkBonus;
                return totalAtk >= defValue;
            } catch (error) {
                console.error('Hit check failed:', error);
                return false;
            }
        }

        /**
         * Calcula dano de um ataque
         * F√ìRMULA BASE: floor(POWER * (ATK / (ATK + DEF))) * damageMult
         * DANO M√çNIMO: sempre 1
         * 
         * @param {object} params - Par√¢metros de dano
         * @param {number} params.atk - Ataque efetivo (com buffs)
         * @param {number} params.def - Defesa efetiva (com buffs)
         * @param {number} params.power - Poder da habilidade/ataque
         * @param {number} params.damageMult - Multiplicador (1.0 padr√£o, 1.10 vantagem, 0.90 desvantagem)
         * @returns {number} Dano final (m√≠nimo 1)
         * 
         * VANTAGEM DE CLASSE (Dano):
         * - Vantagem: 1.10 (110% do dano base)
         * - Desvantagem: 0.90 (90% do dano base)
         * - Neutro: 1.0 (100% do dano base)
         * 
         * EXEMPLO:
         * ATK=10, DEF=5, POWER=15
         * ratio = 10/(10+5) = 0.666
         * baseD = floor(15 * 0.666) = floor(9.99) = 9
         * finalD = floor(9 * 1.0) = 9
         */
        function calcDamage({ atk, def, power, damageMult = 1.0 }) {
            try {
                // ratio = ATK / (ATK + DEF)
                const ratio = atk / (atk + def);
                
                // danoBase = floor(POWER * ratio)
                const baseD = Math.floor(power * ratio);
                
                // Aplicar multiplicador de classe
                const finalD = Math.floor(baseD * damageMult);
                
                // Dano m√≠nimo sempre 1
                return Math.max(1, finalD);
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        /**
         * Wrapper de compatibilidade - calcula dano com ataque b√°sico
         * Aplica automaticamente buffs e vantagens de classe
         * 
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {number} Dano final
         * 
         * FLUXO:
         * 1. Obt√©m stats base (atk, def)
         * 2. Aplica modificadores de buffs
         * 3. Obt√©m POWER b√°sico da classe
         * 4. Calcula multiplicador de classe
         * 5. Chama calcDamage() com todos os par√¢metros
         */
        function calculateDamage(attacker, defender) {
            try {
                if (!attacker || !defender) return 1;
                
                const atkValue = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // POWER b√°sico por classe
                // Commit 12 (Wave C12.3.2): Use MM_TABLES for basic attack power
                const basicPower = MM_TABLES.getBasicAttackPower(attacker.class);
                
                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(attacker);
                const effectiveAtk = Math.max(1, atkValue + atkMods.atk);
                
                const defMods = getBuffModifiers(defender);
                const effectiveDef = Math.max(1, defValue + defMods.def);
                
                // Vantagem de classe: +10% dano se forte, -10% dano se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let damageMult = 1.0;
                if (classAdv?.strong === defender.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === defender.class) {
                    damageMult = 0.90;
                }
                
                return calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: basicPower,
                    damageMult: damageMult
                });
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        function fleeEncounter() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter) return;
                
                if (confirm('Flee from this encounter?')) {
                    encounter.log = encounter.log || [];
                    encounter.log.push('üèÉ Fled from encounter');
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    
                    saveToLocalStorage();
                    renderEncounter();
                }
            } catch (error) {
                showError('Flee failed', error.stack);
            }
        }

        function getCurrentPlayer() {
            try {
                if (!GameState.currentSession) return null;
                
                const turnIndex = GameState.currentSession.currentTurnIndex || 0;
                const playerId = GameState.currentSession.turnOrder?.[turnIndex];
                
                return GameState.players?.find(p => p?.id === playerId) || null;
            } catch (error) {
                console.error('Failed to get current player:', error);
                return null;
            }
        }

        // ========================================================================
        // PR15A: BOX (PC) SYSTEM
        // ========================================================================
        
        /**
         * Get active player for Box operations with proper fallbacks
         * Priority: getCurrentPlayer() > ui.activePlayerId > players[0]
         */
        function getActivePlayerForBox() {
            try {
                if (typeof getCurrentPlayer === "function") {
                    const p = getCurrentPlayer();
                    if (p && p.id) return p;
                }
            } catch {}

            const uiId = GameState.ui?.activePlayerId;
            if (uiId) {
                const p = GameState.players.find(x => x.id === uiId);
                if (p) return p;
            }

            return GameState.players[0] || null;
        }

        /**
         * Ensure Box UI state is properly initialized
         */
        function ensureBoxUIState() {
            if (!GameState.ui) GameState.ui = {};

            const fallbackId = GameState.players?.[0]?.id || null;

            if (!GameState.ui.activePlayerId ||
                !GameState.players.some(p => p.id === GameState.ui.activePlayerId)) {
                GameState.ui.activePlayerId = fallbackId;
            }

            if (!GameState.ui.boxViewedPlayerId ||
                !GameState.players.some(p => p.id === GameState.ui.boxViewedPlayerId)) {
                GameState.ui.boxViewedPlayerId = GameState.ui.activePlayerId;
            }

            if (typeof GameState.ui.boxPageIndex !== 'number') {
                GameState.ui.boxPageIndex = 0;
            }

            if (!Array.isArray(GameState.sharedBox)) {
                GameState.sharedBox = [];
            }
        }

        /**
         * Add a monster to the shared box
         */
        function addToSharedBox(ownerPlayerId, monster) {
            if (!GameState.sharedBox) GameState.sharedBox = [];
            
            const BOX_MAX_TOTAL = 100;
            if (GameState.sharedBox.length >= BOX_MAX_TOTAL) {
                return { success: false, message: 'Box est√° cheia (100/100)' };
            }

            const slotId = 'BX_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            GameState.sharedBox.push({
                slotId,
                ownerPlayerId,
                monster
            });

            return { success: true, slotId };
        }

        /**
         * Move monster from team to box
         */
        function moveTeamToBox(activePlayerId, teamIndex) {
            const player = GameState.players.find(p => p.id === activePlayerId);
            if (!player) {
                return { success: false, message: 'Jogador n√£o encontrado' };
            }

            if (!player.team || teamIndex < 0 || teamIndex >= player.team.length) {
                return { success: false, message: '√çndice de equipe inv√°lido' };
            }

            const monster = player.team[teamIndex];
            if (!monster) {
                return { success: false, message: 'Monstrinho n√£o encontrado' };
            }

            const result = addToSharedBox(activePlayerId, monster);
            if (!result.success) {
                return result;
            }

            // Remove from team
            player.team.splice(teamIndex, 1);

            return { success: true, message: `${monster.name} enviado para Box` };
        }

        /**
         * Move monster from box to team
         */
        function moveBoxToTeam(activePlayerId, slotId) {
            const player = GameState.players.find(p => p.id === activePlayerId);
            if (!player) {
                return { success: false, message: 'Jogador n√£o encontrado' };
            }

            const TEAM_MAX = GameState.config?.maxTeamSize || 6;
            if (player.team && player.team.length >= TEAM_MAX) {
                return { success: false, message: `Equipe cheia (${TEAM_MAX}/${TEAM_MAX})` };
            }

            const slotIndex = GameState.sharedBox.findIndex(slot => slot.slotId === slotId);
            if (slotIndex === -1) {
                return { success: false, message: 'Slot n√£o encontrado' };
            }

            const slot = GameState.sharedBox[slotIndex];
            if (slot.ownerPlayerId !== activePlayerId) {
                return { success: false, message: 'Este monstrinho n√£o √© seu' };
            }

            // Add to team
            if (!player.team) player.team = [];
            player.team.push(slot.monster);

            // Remove from box
            GameState.sharedBox.splice(slotIndex, 1);

            return { success: true, message: `${slot.monster.name} retirado da Box` };
        }

        /**
         * Handle box page selector change
         */
        function onBoxPageChange() {
            const select = document.getElementById('boxPageSelect');
            if (!select) return;

            const playerId = select.value;
            if (playerId && GameState.ui) {
                GameState.ui.boxViewedPlayerId = playerId;
                renderBoxTab();
            }
        }

        /**
         * Render Box tab content
         */
        function renderBoxTab() {
            try {
                // Check if box tab is visible before rendering
                const boxTab = document.getElementById('tabBox');
                if (!boxTab || !boxTab.classList.contains('active')) {
                    return; // Tab not active, skip rendering
                }
                
                ensureBoxUIState();
                
                const activePlayer = getActivePlayerForBox();
                const boxStatus = document.getElementById('boxStatus');
                
                if (!activePlayer) {
                    if (boxStatus) {
                        boxStatus.innerHTML = '<p>Nenhum jogador dispon√≠vel</p>';
                    }
                    return;
                }

                // Update status
                const teamCount = activePlayer.team?.length || 0;
                const TEAM_MAX = GameState.config?.maxTeamSize || 6;
                const boxTotal = GameState.sharedBox?.length || 0;
                const BOX_MAX_TOTAL = 100;

                const boxActivePlayer = document.getElementById('boxActivePlayer');
                const boxTeamCount = document.getElementById('boxTeamCount');
                const boxTotalCount = document.getElementById('boxTotalCount');

                if (boxActivePlayer) boxActivePlayer.textContent = activePlayer.name;
                if (boxTeamCount) boxTeamCount.textContent = `${teamCount}/${TEAM_MAX}`;
                if (boxTotalCount) boxTotalCount.textContent = `${boxTotal}/${BOX_MAX_TOTAL}`;

                // Populate page selector
                const pageSelect = document.getElementById('boxPageSelect');
                if (pageSelect) {
                    pageSelect.innerHTML = '<option value="">-- Selecione --</option>';
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = player.name;
                        if (player.id === GameState.ui.boxViewedPlayerId) {
                            option.selected = true;
                        }
                        pageSelect.appendChild(option);
                    });
                }

                // Render team
                const teamList = document.getElementById('boxTeamList');
                if (teamList && activePlayer.team && activePlayer.team.length > 0) {
                    teamList.innerHTML = '';
                    activePlayer.team.forEach((monster, index) => {
                        if (!monster) return;
                        
                        const slotDiv = document.createElement('div');
                        slotDiv.className = 'box-slot';
                        slotDiv.innerHTML = `
                            <div class="box-slot-emoji">${monster.emoji || 'üêæ'}</div>
                            <div class="box-slot-name">${monster.name || 'Sem Nome'}</div>
                            <div class="box-slot-class">${monster.class || '?'}</div>
                            <div class="box-slot-level">Nv. ${monster.level || 1}</div>
                            <button class="btn btn-warning box-slot-btn" onclick="sendToBox(${index})">
                                üì¶ Enviar para Box
                            </button>
                        `;
                        teamList.appendChild(slotDiv);
                    });
                } else if (teamList) {
                    teamList.innerHTML = '<p class="text-center">Equipe vazia</p>';
                }

                // Render box monsters for viewed player
                const viewedPlayerId = GameState.ui.boxViewedPlayerId;
                const boxList = document.getElementById('boxMonstersList');
                
                if (boxList) {
                    const playerSlots = GameState.sharedBox.filter(slot => slot.ownerPlayerId === viewedPlayerId);
                    
                    if (playerSlots.length > 0) {
                        boxList.innerHTML = '';
                        playerSlots.forEach(slot => {
                            const monster = slot.monster;
                            if (!monster) return;
                            
                            const isOwner = activePlayer.id === slot.ownerPlayerId;
                            const slotDiv = document.createElement('div');
                            slotDiv.className = isOwner ? 'box-slot' : 'box-slot locked';
                            
                            let buttonHtml = '';
                            if (isOwner) {
                                if (teamCount < TEAM_MAX) {
                                    buttonHtml = `
                                        <button class="btn btn-success box-slot-btn" onclick="withdrawFromBox('${slot.slotId}')">
                                            ‚¨ÜÔ∏è Retirar
                                        </button>
                                    `;
                                } else {
                                    buttonHtml = `
                                        <button class="btn box-slot-btn" disabled>
                                            Equipe Cheia
                                        </button>
                                    `;
                                }
                            } else {
                                buttonHtml = `<div class="box-slot-owner">üîí N√£o √© seu</div>`;
                            }
                            
                            slotDiv.innerHTML = `
                                <div class="box-slot-emoji">${monster.emoji || 'üêæ'}</div>
                                <div class="box-slot-name">${monster.name || 'Sem Nome'}</div>
                                <div class="box-slot-class">${monster.class || '?'}</div>
                                <div class="box-slot-level">Nv. ${monster.level || 1}</div>
                                ${buttonHtml}
                            `;
                            boxList.appendChild(slotDiv);
                        });
                    } else {
                        boxList.innerHTML = '<p class="text-center">Nenhum monstrinho na Box deste jogador</p>';
                    }
                }

            } catch (error) {
                console.error('Failed to render Box tab:', error);
                showError('Erro ao renderizar Box', error.stack);
            }
        }

        /**
         * Send monster from team to box
         */
        function sendToBox(teamIndex) {
            try {
                const activePlayer = getActivePlayerForBox();
                if (!activePlayer) {
                    alert('Jogador ativo n√£o encontrado');
                    return;
                }

                const result = moveTeamToBox(activePlayer.id, teamIndex);
                
                if (result.success) {
                    saveToLocalStorage();
                    renderBoxTab();
                    updateAllViews();
                } else {
                    alert(result.message || 'Erro ao enviar para Box');
                }
            } catch (error) {
                showError('Erro ao enviar para Box', error.stack);
            }
        }

        /**
         * Withdraw monster from box to team
         */
        function withdrawFromBox(slotId) {
            try {
                const activePlayer = getActivePlayerForBox();
                if (!activePlayer) {
                    alert('Jogador ativo n√£o encontrado');
                    return;
                }

                const result = moveBoxToTeam(activePlayer.id, slotId);
                
                if (result.success) {
                    saveToLocalStorage();
                    renderBoxTab();
                    updateAllViews();
                } else {
                    alert(result.message || 'Erro ao retirar da Box');
                }
            } catch (error) {
                showError('Erro ao retirar da Box', error.stack);
            }
        }

        // ========================================================================
        // END PR15A: BOX SYSTEM
        // ========================================================================

        // Make Box functions globally available
        window.sendToBox = sendToBox;
        window.withdrawFromBox = withdrawFromBox;
        window.onBoxPageChange = onBoxPageChange;

        // THERAPY MANAGEMENT
        function addObjective() {
            try {
                const text = document.getElementById('newObjective')?.value?.trim();
                const weight = parseInt(document.getElementById('objectiveWeight')?.value || '1');
                
                if (!text) {
                    alert('Please enter objective description');
                    return;
                }
                
                const objective = {
                    id: Date.now(),
                    text: text,
                    weight: weight
                };
                
                GameState.objectives = GameState.objectives || [];
                GameState.objectives.push(objective);
                
                document.getElementById('newObjective').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add objective', error.stack);
            }
        }

        function toggleObjectiveForPlayer(playerId, objectiveId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                therapy.completedObjectives = therapy.completedObjectives || [];
                
                const index = therapy.completedObjectives.indexOf(objectiveId);
                if (index > -1) {
                    therapy.completedObjectives.splice(index, 1);
                } else {
                    therapy.completedObjectives.push(objectiveId);
                }
                
                therapy.pm = 0;
                therapy.completedObjectives.forEach(objId => {
                    const obj = GameState.objectives?.find(o => o?.id === objId);
                    if (obj) {
                        therapy.pm += obj.weight || 0;
                    }
                });
                
                updateMedals(playerId);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to toggle objective', error.stack);
            }
        }

        function updateMedals(playerId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                const pm = therapy.pm || 0;
                const tiers = GameState.config?.medalTiers || { bronze: 10, silver: 25, gold: 50 };
                
                therapy.medals = therapy.medals || [];
                
                if (pm >= tiers.gold && !therapy.medals.includes('gold')) {
                    therapy.medals.push('gold');
                } else if (pm >= tiers.silver && !therapy.medals.includes('silver')) {
                    therapy.medals.push('silver');
                } else if (pm >= tiers.bronze && !therapy.medals.includes('bronze')) {
                    therapy.medals.push('bronze');
                }
            } catch (error) {
                console.error('Failed to update medals:', error);
            }
        }

        // UI UPDATE FUNCTIONS
        function updateAllViews() {
            try {
                updateHomeStats();
                updatePlayersList();
                updateSessionView();
                updateTherapyView();
                updateReportView();
                updateShopView();
                updateEncounterPlayerDropdown();
                updateEncounterUI();
                renderEncounter();
                renderBoxTab(); // PR15A: Box system
            } catch (error) {
                console.error('Failed to update views:', error);
            }
        }

        /**
         * PR16B: Render PartyDex tab
         * 
         * Wrapper function that calls the PartyDexUI module with proper dependencies.
         * 
         * IDEMPOTENT: Multiple calls only update DOM (no side effects, no loops).
         * Safe to call on tab switch and after relevant events (capture, egg hatch).
         */
        function renderPartyDexTab() {
            try {
                // Ensure PartyDex structures exist
                if (window.PartyDex) {
                    window.PartyDex.ensurePartyDex(GameState);
                    window.PartyDex.ensurePartyMoney(GameState);
                }
                
                const root = document.getElementById('partyDexRoot');
                if (!root) {
                    console.warn('[PartyDex] Root element not found');
                    return;
                }
                
                // Check if PartyDexUI is loaded
                if (!window.PartyDexUI || typeof window.PartyDexUI.renderPartyDex !== 'function') {
                    console.warn('[PartyDex] PartyDexUI module not loaded');
                    root.innerHTML = '<p class="error">M√≥dulo PartyDex UI n√£o carregado</p>';
                    return;
                }
                
                /**
                 * Get all monster templates (canonical source)
                 * Priority:
                 * 1. Data.getMonstersMapSync() - JSON-loaded monsters (PR9B)
                 *    Returns Map, so we convert to Array via Array.from(map.values())
                 * 2. MONSTER_CATALOG - Hardcoded fallback (only if JSON not available)
                 */
                function getMonsterTemplates() {
                    // Try JSON-loaded monsters first (canonical source from PR9B)
                    if (window.Data && window.Data.getMonstersMapSync) {
                        const monstersMap = window.Data.getMonstersMapSync();
                        // getMonstersMapSync() returns a Map, convert to Array
                        if (monstersMap && monstersMap.size > 0) {
                            return Array.from(monstersMap.values());
                        }
                    }
                    
                    // Fallback: Use hardcoded MONSTER_CATALOG only if JSON not available
                    console.log('[PartyDex] Using fallback MONSTER_CATALOG (JSON not loaded)');
                    return MONSTER_CATALOG || [];
                }
                
                // Render the PartyDex UI (idempotent DOM update)
                window.PartyDexUI.renderPartyDex(root, {
                    state: GameState,
                    getMonsterTemplates: getMonsterTemplates
                });
                
            } catch (error) {
                console.error('[PartyDex] Failed to render:', error);
                const root = document.getElementById('partyDexRoot');
                if (root) {
                    root.innerHTML = '<p class="error">Erro ao renderizar Monstrodex</p>';
                }
            }
        }

        // ===== SHOP SYSTEM (PR13A) =====
        
        /**
         * Update shop view with current player and items
         */
        function updateShopView() {
            try {
                const playerInfo = document.getElementById('shopPlayerInfo');
                const itemsList = document.getElementById('shopItemsList');
                const inventoryContainer = document.getElementById('shopPlayerInventory');
                
                if (!playerInfo || !itemsList) return;
                
                // Get selected player from encounter dropdown or first available player
                let selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                if (!selectedPlayerId && GameState.players && GameState.players.length > 0) {
                    selectedPlayerId = GameState.players[0].id;
                }
                
                const player = GameState.players?.find(p => p.id === selectedPlayerId);
                
                if (!player) {
                    playerInfo.innerHTML = '<p>Nenhum jogador dispon√≠vel. Crie um jogador primeiro!</p>';
                    itemsList.innerHTML = '';
                    if (inventoryContainer) {
                        inventoryContainer.innerHTML = '<p>Nenhum jogador selecionado.</p>';
                    }
                    return;
                }
                
                // Display player info
                const money = player.money || 0;
                playerInfo.innerHTML = `
                    <p><strong>Jogador:</strong> ${player.name} (${player.class || 'Sem classe'})</p>
                    <p><strong>üí∞ Dinheiro:</strong> ${money}</p>
                `;
                
                // PR13B: Render player inventory for selling
                if (inventoryContainer) {
                    renderPlayerInventory(player, inventoryContainer);
                }
                
                // Load and display items
                renderShopItems(player, itemsList);
                
            } catch (error) {
                console.error('Failed to update shop view:', error);
            }
        }
        
        /**
         * PR13B: Render player inventory for selling
         * @param {object} player - Player object
         * @param {HTMLElement} container - Container element to render inventory into
         */
        function renderPlayerInventory(player, container) {
            try {
                // Get player inventory
                const inventory = player.inventory || {};
                const inventoryItems = Object.entries(inventory).filter(([itemId, qty]) => qty > 0);
                
                if (inventoryItems.length === 0) {
                    container.innerHTML = '<p>Seu invent√°rio est√° vazio.</p>';
                    return;
                }
                
                // Get all items from the global itemsData
                const allItems = window.itemsData || [];
                
                // Sort by item name
                inventoryItems.sort((a, b) => {
                    const itemA = allItems.find(i => i.id === a[0]);
                    const itemB = allItems.find(i => i.id === b[0]);
                    return (itemA?.name || '').localeCompare(itemB?.name || '');
                });
                
                // Check which items are equipped
                const equippedItems = new Set();
                if (player.team && Array.isArray(player.team)) {
                    player.team.forEach(monster => {
                        if (monster?.equippedItem) {
                            equippedItems.add(monster.equippedItem);
                        }
                    });
                }
                
                // Render inventory items
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">';
                
                for (const [itemId, qty] of inventoryItems) {
                    const item = allItems.find(i => i.id === itemId);
                    
                    if (!item) {
                        // Item not found in catalog (maybe old/invalid item)
                        html += `
                            <div class="card" style="margin: 0; padding: 1rem; background: #f8f8f8;">
                                <h4 style="margin-top: 0; color: #999;">Item desconhecido (${itemId})</h4>
                                <p style="font-size: 0.85em; color: #555;">
                                    <strong>Quantidade:</strong> ${qty}x
                                </p>
                                <p style="font-size: 0.85em; color: #999;">
                                    Este item n√£o est√° mais no cat√°logo.
                                </p>
                            </div>
                        `;
                        continue;
                    }
                    
                    // Calculate sell price
                    const sellPrice = getSellPrice(item);
                    const isEquipped = equippedItems.has(itemId);
                    const canSell = sellPrice !== null && !isEquipped;
                    
                    // PR14A: Check if item is an egg
                    const isEgg = item.category === 'egg';
                    
                    // Tier badge color
                    const tierColors = {
                        'comum': '#999',
                        'incomum': '#2ecc71',
                        'raro': '#3498db',
                        'mistico': '#9b59b6',
                        'lendario': '#f39c12'
                    };
                    const tierColor = tierColors[item.tier] || '#999';
                    
                    html += `
                        <div class="card" style="margin: 0; padding: 1rem; border-left: 4px solid ${tierColor};">
                            <h4 style="margin-top: 0;">${item.name}</h4>
                            ${item.category === 'egg' ? `<p style="font-size: 0.9em; color: ${tierColor}; font-weight: bold;">ü•ö OVO</p>` : `
                            <p style="font-size: 0.9em; color: #666;">
                                <span style="color: ${tierColor}; font-weight: bold; text-transform: uppercase;">
                                    ${item.tier}
                                </span>
                            </p>`}
                            <p style="font-size: 0.9em;">${item.description}</p>
                            ${!isEgg && item.stats ? `<p style="font-size: 0.85em; color: #555;">
                                <strong>Stats:</strong> 
                                ${item.stats.atk > 0 ? `‚öîÔ∏è ATK +${item.stats.atk}` : ''}${item.stats.atk > 0 && item.stats.def > 0 ? ' ' : ''}${item.stats.def > 0 ? `üõ°Ô∏è DEF +${item.stats.def}` : ''}
                            </p>` : ''}
                            <p style="font-size: 0.85em; color: #555;">
                                <strong>Voc√™ tem:</strong> ${qty}x
                            </p>
                            ${isEquipped ? `<p style="font-size: 0.85em; color: #e74c3c;">‚ö†Ô∏è Item equipado em um monstro</p>` : ''}
                            ${isEgg ? `
                            <button 
                                class="btn btn-success" 
                                onclick="hatchEggFromInventory('${player.id}', '${itemId}')"
                                style="width: 100%; margin-top: 0.5rem;"
                            >
                                üê£ Chocar Ovo
                            </button>
                            ` : `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                                ${sellPrice !== null ? `<strong style="font-size: 1.1em;">üí∞ Vender por ${sellPrice}</strong>` : `<span style="font-size: 0.9em; color: #999;">N√£o vend√°vel</span>`}
                                <button 
                                    class="btn ${canSell ? 'btn-warning' : 'btn-secondary'}" 
                                    onclick="sellItem('${player.id}', '${itemId}', 1)"
                                    ${!canSell ? 'disabled' : ''}
                                    style="${!canSell ? 'opacity: 0.5; cursor: not-allowed;' : ''}"
                                    title="${isEquipped ? 'N√£o √© poss√≠vel vender item equipado' : (sellPrice === null ? 'Este item n√£o pode ser vendido' : 'Vender 1x')}"
                                >
                                    ${canSell ? `üíµ Vender (${sellPrice})` : (isEquipped ? 'üîí Equipado' : '‚úó N√£o vend√°vel')}
                                </button>
                            </div>
                            `}
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to render player inventory:', error);
                container.innerHTML = '<p style="color: red;">Erro ao carregar invent√°rio.</p>';
            }
        }
        
        /**
         * Render shop items list
         * @param {object} player - Player object
         * @param {HTMLElement} container - Container element to render items into
         */
        function renderShopItems(player, container) {
            try {
                // Get all items from the global itemsData (loaded at init)
                const allItems = window.itemsData || [];
                
                if (allItems.length === 0) {
                    container.innerHTML = '<p>Nenhum item dispon√≠vel.</p>';
                    return;
                }
                
                // Filter items that can be bought (have price.buy > 0)
                const buyableItems = allItems.filter(item => item.price && item.price.buy > 0);
                
                if (buyableItems.length === 0) {
                    container.innerHTML = '<p>Nenhum item dispon√≠vel para compra.</p>';
                    return;
                }
                
                // Sort by price
                buyableItems.sort((a, b) => a.price.buy - b.price.buy);
                
                // Render items
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">';
                
                for (const item of buyableItems) {
                    const price = item.price.buy;
                    const canAfford = (player.money || 0) >= price;
                    const owned = player.inventory?.[item.id] || 0;
                    
                    // Tier badge color
                    const tierColors = {
                        'comum': '#999',
                        'incomum': '#2ecc71',
                        'raro': '#3498db',
                        'mistico': '#9b59b6',
                        'lendario': '#f39c12'
                    };
                    const tierColor = tierColors[item.tier] || '#999';
                    
                    // Check if it's an egg
                    const isEgg = item.category === 'egg';
                    
                    html += `
                        <div class="card" style="margin: 0; padding: 1rem; border-left: 4px solid ${tierColor};">
                            <h4 style="margin-top: 0;">${item.name}</h4>
                            ${isEgg ? '<p style="font-size: 0.9em; color: #666; font-weight: bold;">ü•ö OVO</p>' : item.tier ? `<p style="font-size: 0.9em; color: #666;">
                                <span style="color: ${tierColor}; font-weight: bold; text-transform: uppercase;">
                                    ${item.tier}
                                </span>
                            </p>` : ''}
                            <p style="font-size: 0.9em;">${item.description}</p>
                            ${item.stats ? `<p style="font-size: 0.85em; color: #555;">
                                <strong>Stats:</strong> 
                                ${item.stats.atk > 0 ? `‚öîÔ∏è ATK +${item.stats.atk}` : ''}${item.stats.atk > 0 && item.stats.def > 0 ? ' ' : ''}${item.stats.def > 0 ? `üõ°Ô∏è DEF +${item.stats.def}` : ''}
                            </p>` : ''}
                            ${item.break?.enabled ? `<p style="font-size: 0.85em; color: #e74c3c;">‚ö†Ô∏è Pode quebrar (${Math.round(item.break.chance * 100)}%)</p>` : ''}
                            <p style="font-size: 0.85em; color: #555;">
                                <strong>Voc√™ tem:</strong> ${owned}x
                            </p>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                                <strong style="font-size: 1.1em;">üí∞ ${price}</strong>
                                <button 
                                    class="btn ${canAfford ? 'btn-success' : 'btn-secondary'}" 
                                    onclick="buyItem('${player.id}', '${item.id}')"
                                    ${!canAfford ? 'disabled' : ''}
                                    style="${!canAfford ? 'opacity: 0.5; cursor: not-allowed;' : ''}"
                                >
                                    ${canAfford ? '‚úì Comprar' : '‚úó Sem dinheiro'}
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to render shop items:', error);
                container.innerHTML = '<p style="color: red;">Erro ao carregar itens.</p>';
            }
        }
        
        /**
         * Buy an item for a player
         * 
         * Validates item availability and player funds, then performs the purchase transaction:
         * - Deducts cost from player.money
         * - Adds item to player.inventory
         * - Saves game state via StorageManager
         * - Updates shop view to reflect changes
         * - Shows alert to user with success/error message
         * 
         * @param {string} playerId - Player ID
         * @param {string} itemId - Item ID from items catalog
         * @returns {void}
         */
        function buyItem(playerId, itemId) {
            try {
                // Find player
                const player = GameState.players?.find(p => p.id === playerId);
                if (!player) {
                    alert('‚ùå Jogador n√£o encontrado!');
                    return;
                }
                
                // Find item
                const allItems = window.itemsData || [];
                const item = allItems.find(i => i.id === itemId);
                if (!item) {
                    alert('‚ùå Item n√£o encontrado!');
                    return;
                }
                
                // Validate item has price
                if (!item.price || !item.price.buy || item.price.buy <= 0) {
                    alert('‚ùå Item n√£o est√° dispon√≠vel para compra!');
                    return;
                }
                
                const price = item.price.buy;
                const playerMoney = player.money || 0;
                
                // Validate player has enough money
                if (playerMoney < price) {
                    alert(`‚ùå Dinheiro insuficiente! Voc√™ tem ${playerMoney} e precisa de ${price}.`);
                    return;
                }
                
                // Debit money
                player.money = playerMoney - price;
                
                // Add item to inventory
                player.inventory = player.inventory || {};
                player.inventory[itemId] = (player.inventory[itemId] || 0) + 1;
                
                // Save game state
                saveToLocalStorage();
                
                // Show success message
                alert(`‚úÖ Comprou ${item.name} por ${price}! Voc√™ tem ${player.money} restantes.`);
                
                // Update shop view
                updateShopView();
                
            } catch (error) {
                console.error('Failed to buy item:', error);
                alert('‚ùå Erro ao comprar item. Veja o console para detalhes.');
            }
        }

        /**
         * PR13B: Calculate sell price for an item with enforced sell < buy rule
         * 
         * Rules:
         * - If item has no buy price or buy <= 1: return null (not sellable)
         * - If item has explicit sell price: use it
         * - Otherwise: fallback to 50% of buy price (floor(buy * 0.5))
         * - Enforce: sell = max(1, sell)
         * - Enforce: sell = min(sell, buy - 1) to guarantee sell < buy
         * 
         * @param {object} itemDef - Item definition from catalog
         * @returns {number|null} Sell price or null if item cannot be sold
         */
        function getSellPrice(itemDef) {
            try {
                // Get buy price
                const buy = itemDef?.price?.buy;
                
                // Block sale if no buy price or buy <= 1
                if (typeof buy !== 'number' || buy <= 1) {
                    return null;
                }
                
                // Get raw sell price (explicit or fallback to 50%)
                const rawSell = itemDef?.price?.sell;
                let sell = (typeof rawSell === 'number') ? rawSell : Math.floor(buy * 0.5);
                
                // Enforce minimum: sell >= 1
                sell = Math.max(1, sell);
                
                // Enforce strict: sell < buy (never equal or greater)
                sell = Math.min(sell, buy - 1);
                
                return sell;
                
            } catch (error) {
                console.error('[getSellPrice] Error calculating sell price:', error);
                return null;
            }
        }

        /**
         * PR13B: Sell an item from player inventory
         * 
         * Validates item availability, calculates sell price, and performs the sale transaction:
         * - Validates player has item in inventory
         * - Validates item is not equipped on any team monster
         * - Calculates sell price via getSellPrice
         * - Decrements inventory (deletes key if qty reaches 0)
         * - Credits money to player
         * - Saves game state via StorageManager
         * - Updates shop view to reflect changes
         * 
         * @param {string} playerId - Player ID
         * @param {string} itemId - Item ID from items catalog
         * @param {number} qty - Quantity to sell (default: 1)
         * @returns {void}
         */
        function sellItem(playerId, itemId, qty = 1) {
            try {
                // Find player
                const player = GameState.players?.find(p => p.id === playerId);
                if (!player) {
                    alert('‚ùå Jogador n√£o encontrado!');
                    return;
                }
                
                // Find item
                const allItems = window.itemsData || [];
                const item = allItems.find(i => i.id === itemId);
                if (!item) {
                    alert('‚ùå Item n√£o encontrado!');
                    return;
                }
                
                // Validate quantity
                if (qty < 1 || !Number.isInteger(qty)) {
                    alert('‚ùå Quantidade inv√°lida!');
                    return;
                }
                
                // Check inventory
                const owned = player.inventory?.[itemId] || 0;
                if (owned < qty) {
                    alert(`‚ùå Voc√™ n√£o tem ${qty}x ${item.name}! Voc√™ tem apenas ${owned}x.`);
                    return;
                }
                
                // Calculate sell price
                const sellPrice = getSellPrice(item);
                if (sellPrice === null) {
                    alert('‚ùå Este item n√£o pode ser vendido!');
                    return;
                }
                
                // Check if item is equipped on any team monster
                if (player.team && Array.isArray(player.team)) {
                    const equippedMonster = player.team.find(monster => monster?.equippedItem === itemId);
                    if (equippedMonster) {
                        alert(`‚ùå N√£o √© poss√≠vel vender item equipado! ${item.name} est√° equipado em ${equippedMonster.name}.`);
                        return;
                    }
                }
                
                // Calculate total sale value
                const totalValue = sellPrice * qty;
                
                // Update inventory
                player.inventory = player.inventory || {};
                player.inventory[itemId] = owned - qty;
                
                // Clean up if quantity reaches 0
                if (player.inventory[itemId] <= 0) {
                    delete player.inventory[itemId];
                }
                
                // Credit money
                player.money = (player.money || 0) + totalValue;
                
                // Save game state
                saveToLocalStorage();
                
                // Show success message
                alert(`‚úÖ Vendeu ${qty}x ${item.name} por ${totalValue}! Voc√™ tem ${player.money} moedas.`);
                
                // Update shop view
                updateShopView();
                
            } catch (error) {
                console.error('Failed to sell item:', error);
                alert('‚ùå Erro ao vender item. Veja o console para detalhes.');
            }
        }

        /**
         * PR14A: Hatch an egg from player's inventory
         * @param {string} playerId - Player ID
         * @param {string} eggItemId - Egg item ID (ex: "EGG_C")
         * @returns {void}
         */
        async function hatchEggFromInventory(playerId, eggItemId) {
            try {
                // Find player
                const player = GameState.players?.find(p => p.id === playerId);
                if (!player) {
                    alert('‚ùå Jogador n√£o encontrado!');
                    return;
                }
                
                // Validate player has the egg
                const eggQty = player.inventory?.[eggItemId] || 0;
                if (eggQty <= 0) {
                    alert('‚ùå Voc√™ n√£o tem este ovo no invent√°rio!');
                    return;
                }
                
                // Get egg definition
                const allItems = window.itemsData || [];
                const eggItem = allItems.find(i => i.id === eggItemId);
                if (!eggItem || eggItem.category !== 'egg') {
                    alert('‚ùå Este item n√£o √© um ovo v√°lido!');
                    return;
                }
                
                // Get rarity from egg effect
                const hatchEffect = eggItem.effects?.find(e => e.type === 'hatch_egg');
                if (!hatchEffect || !hatchEffect.rarity) {
                    alert('‚ùå Ovo n√£o possui efeito de choque v√°lido!');
                    return;
                }
                
                const targetRarity = hatchEffect.rarity;
                
                // Get monsters of that rarity
                const monstersMap = window.Data?.getMonstersMapSync?.();
                if (!monstersMap || monstersMap.size === 0) {
                    alert('‚ùå Dados de monstros n√£o carregados. Recarregue a p√°gina.');
                    return;
                }
                
                // Filter by rarity
                const monsterPool = [];
                for (const [id, monster] of monstersMap.entries()) {
                    if (monster.rarity === targetRarity) {
                        monsterPool.push(monster);
                    }
                }
                
                if (monsterPool.length === 0) {
                    alert(`‚ùå Nenhum Monstrinhomon ${targetRarity} dispon√≠vel ainda.`);
                    return;
                }
                
                // Check team size
                const teamSize = player.team?.length || 0;
                const boxSize = player.box?.length || 0;
                const totalMonsters = teamSize + boxSize;
                
                const MAX_TEAM_SIZE = 6;
                const MAX_TOTAL = 100;
                
                if (totalMonsters >= MAX_TOTAL) {
                    alert('‚ùå Voc√™ atingiu o limite m√°ximo de Monstrinhomons (100)!');
                    return;
                }
                
                // Choose random monster from pool
                const randomIndex = Math.floor(Math.random() * monsterPool.length);
                const template = monsterPool[randomIndex];
                
                // Create monster instance
                const newMonster = {
                    id: `mi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    monsterId: template.id,
                    name: template.name,
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji || '‚ùì',
                    level: 1,
                    xp: 0,
                    hp: template.baseHp || 30,
                    hpMax: template.baseHp || 30,
                    atk: template.baseAtk || 5,
                    def: template.baseDef || 3,
                    spd: template.baseSpd || 5,
                    ene: template.baseEne || 6,
                    eneMax: template.baseEne || 6,
                    heldItemId: null,
                    buffs: []
                };
                
                // Add evolution fields if present
                if (template.evolvesTo) {
                    newMonster.evolvesTo = template.evolvesTo;
                }
                if (template.evolvesAt) {
                    newMonster.evolvesAt = template.evolvesAt;
                }
                
                // ============================================================================
                // PR14B: CRITICAL - Modal must be confirmed BEFORE any state changes
                // This ensures egg is NEVER consumed if:
                // - User closes tab/reloads during modal
                // - Modal fails to display
                // - Any error occurs before confirmation
                // ============================================================================
                
                // Show modal and WAIT for user confirmation
                // If this throws or user closes page, execution stops here
                // and NO state changes happen below
                try {
                    if (window.showEggHatchModal) {
                        await window.showEggHatchModal(newMonster);
                    }
                } catch (error) {
                    console.error('[EggHatch] Modal error - egg NOT consumed:', error);
                    alert('‚ùå Erro ao exibir resultado. Ovo n√£o foi consumido.');
                    return; // Exit without consuming egg
                }
                
                // ============================================================================
                // ONLY AFTER user confirms modal do we mutate state
                // ============================================================================
                
                // Ensure arrays exist
                player.team = player.team || [];
                player.box = player.box || [];
                
                // Add to team or box
                let location = '';
                if (teamSize < MAX_TEAM_SIZE) {
                    player.team.push(newMonster);
                    location = 'time';
                } else {
                    player.box.push(newMonster);
                    location = 'box';
                }
                
                // Decrease egg quantity (ONLY after modal confirmed)
                player.inventory[eggItemId] = eggQty - 1;
                if (player.inventory[eggItemId] <= 0) {
                    delete player.inventory[eggItemId];
                }
                
                // PR16A: Mark as captured in PartyDex and check milestones
                if (window.PartyDex && (newMonster.monsterId || template.id)) {
                    const templateId = newMonster.monsterId || template.id;
                    window.PartyDex.onMonsterAddedToGroup(GameState, templateId, {
                        showToast: showToast,
                        saveToLocalStorage: saveToLocalStorage
                    });
                }
                
                // Save game (ONLY after modal confirmed)
                saveToLocalStorage();
                
                // Update views
                updateShopView();
                updatePlayersList();
                updateAllViews();
                
                // Show brief success message (modal already showed details)
                console.log('[EggHatch] Successfully hatched:', newMonster);
                
            } catch (error) {
                console.error('[EggHatch] Failed to hatch egg:', error);
                alert(`‚ùå Erro ao chocar ovo: ${error.message}`);
            }
        }

        function updateEncounterPlayerDropdown() {
            try {
                const select = document.getElementById('encounterPlayer');
                if (!select) return;
                
                select.innerHTML = '<option value="">-- Select Player --</option>';
                
                if (GameState.players && GameState.players.length > 0) {
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.name} (${player.class || 'No class'})`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to update encounter player dropdown:', error);
            }
        }
        
        function updateEncounterUI() {
            try {
                const type = document.getElementById('encounterType')?.value;
                const playerSelectDiv = document.getElementById('playerSelectDiv');
                const groupSelectDiv = document.getElementById('groupSelectDiv');
                
                if (!playerSelectDiv || !groupSelectDiv) return;
                
                if (type === 'wild') {
                    showEl(playerSelectDiv);
                    hideEl(groupSelectDiv);
                } else if (type === 'trainer' || type === 'boss') {
                    hideEl(playerSelectDiv);
                    showEl(groupSelectDiv);
                    updateGroupParticipantsList();
                } else {
                    hideEl(playerSelectDiv);
                    hideEl(groupSelectDiv);
                }
            } catch (error) {
                console.error('Failed to update encounter UI:', error);
            }
        }
        
        function updateGroupParticipantsList() {
            try {
                const container = document.getElementById('groupParticipantsList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p class="opacity-80">No players available. Add players first.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    // Initialize activeIndex if not set
                    if (typeof player.activeIndex !== 'number') {
                        player.activeIndex = firstAliveIndex(player.team);
                    }
                    
                    const mon = _getActiveMonsterOfPlayer(player);
                    const monName = mon ? (mon.name || mon.nome || 'No monster') : 'No monster';
                    const hasValidMonster = mon && mon.hp > 0;
                    
                    html += `<div class="py-8">`;
                    html += `<label class="cursor-pointer d-flex align-center">`;
                    html += `<input type="checkbox" name="groupParticipant" value="${player.id}" ${!hasValidMonster ? 'disabled' : ''}>`;
                    html += `<span class="ml-8">${player.name} (${player.class})`;
                    if (hasValidMonster) {
                        html += ` - ${monName} Nv${mon.level}`;
                    } else {
                        html += ` - <span class="opacity-80">No valid monster</span>`;
                    }
                    html += `</span>`;
                    html += `</label>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
                
                // Also update team reorder UI
                updateTeamReorderUI();
            } catch (error) {
                console.error('Failed to update group participants list:', error);
            }
        }

        function updateTeamReorderUI() {
            try {
                const container = document.getElementById('teamReorderContainer');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p class="text-muted">No players available.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player || !Array.isArray(player.team) || player.team.length === 0) return;
                    
                    html += `<div class="team-reorder-container">`;
                    html += `<strong>${player.name || player.nome}</strong> (${player.class})<br>`;
                    html += `<small class="text-muted">Posi√ß√£o 0 = L√≠der (primeiro a lutar se vivo)</small>`;
                    html += `<div class="mt-8">`;
                    
                    player.team.forEach((monster, idx) => {
                        if (!monster) return;
                        
                        const isAlive = _isAlive(monster);
                        const hpPercent = Math.floor((monster.hp / monster.hpMax) * 100);
                        const isActive = idx === player.activeIndex;
                        
                        const cardClass = isActive ? 'team-member-card-active' : 'team-member-card-inactive';
                        html += `<div class="team-member-card ${cardClass}">`;
                        html += `<span class="team-member-index">${idx}</span>`;
                        html += `<div class="team-member-info">`;
                        html += `${monster.emoji || ''} ${monster.name || monster.nome} - Nv${monster.level}`;
                        html += `<br><small>HP: ${monster.hp}/${monster.hpMax} (${hpPercent}%)`;
                        if (!isAlive) html += ` <strong class="color-red">üíÄ DESMAIADO</strong>`;
                        if (isActive) html += ` <strong class="color-green">‚ö° ATIVO</strong>`;
                        html += `</small>`;
                        html += `</div>`;
                        html += `<div class="team-member-buttons">`;
                        if (idx > 0) {
                            html += `<button onclick="movePlayerTeamMember('${player.id}', ${idx}, ${idx - 1})" class="btn-sm-arrow">‚¨ÜÔ∏è</button>`;
                        }
                        if (idx < player.team.length - 1) {
                            html += `<button onclick="movePlayerTeamMember('${player.id}', ${idx}, ${idx + 1})" class="btn-sm-arrow">‚¨áÔ∏è</button>`;
                        }
                        html += `</div>`;
                        html += `</div>`;
                    });
                    
                    html += `</div>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update team reorder UI:', error);
            }
        }

        function movePlayerTeamMember(playerId, fromIdx, toIdx) {
            try {
                const player = _getPlayerById(playerId);
                if (!player) return;
                
                moveTeamMember(player, fromIdx, toIdx);
                updateTeamReorderUI();
                updateGroupParticipantsList();
            } catch (error) {
                showError('Failed to move team member', error.stack);
            }
        }

        function updateHomeStats() {
            try {
                const statPlayers = document.getElementById('statPlayers');
                const statMonsters = document.getElementById('statMonsters');
                const statSession = document.getElementById('statSession');
                
                if (statPlayers) statPlayers.textContent = GameState.players?.length || 0;
                if (statMonsters) statMonsters.textContent = GameState.monsters?.length || 0;
                if (statSession) statSession.textContent = GameState.currentSession ? 'Yes' : 'No';
                
                // FASE 1 POKEMON: Renderizar Monstr√≥dex
                renderMonstrodex();
                
                // FASE 1 POKEMON: Renderizar Estat√≠sticas
                renderAchievements();
            } catch (error) {
                console.error('Failed to update home stats:', error);
            }
        }

        /**
         * FASE 1 POKEMON: Renderiza se√ß√£o de Monstr√≥dex
         */
        function renderMonstrodex() {
            try {
                const container = document.getElementById('monstrodexStats');
                if (!container) return;
                
                const monstrodex = GameState.monstrodex || { seen: [], captured: [] };
                const totalMonsters = MONSTER_CATALOG.length;
                const seenCount = monstrodex.seen.length;
                const capturedCount = monstrodex.captured.length;
                
                const seenPercent = totalMonsters > 0 ? Math.floor((seenCount / totalMonsters) * 100) : 0;
                const capturedPercent = totalMonsters > 0 ? Math.floor((capturedCount / totalMonsters) * 100) : 0;
                
                // Estat√≠sticas por classe
                const classCounts = {};
                MONSTER_CATALOG.forEach(mon => {
                    const cls = mon.class || 'Unknown';
                    if (!classCounts[cls]) {
                        classCounts[cls] = { total: 0, seen: 0, captured: 0 };
                    }
                    classCounts[cls].total++;
                    if (monstrodex.seen.includes(mon.id)) classCounts[cls].seen++;
                    if (monstrodex.captured.includes(mon.id)) classCounts[cls].captured++;
                });
                
                let html = `
                    <div class="stats-grid-200">
                        <div class="stat-box">
                            <strong>üëÅÔ∏è Vistos:</strong> ${seenCount}/${totalMonsters} (${seenPercent}%)
                            <div class="progress-bar progress-bar-spacing">
                                <div class="progress-fill" style="width: ${seenPercent}%; background: #2196F3;"></div>
                            </div>
                        </div>
                        <div class="stat-box">
                            <strong>‚úÖ Capturados:</strong> ${capturedCount}/${totalMonsters} (${capturedPercent}%)
                            <div class="progress-bar progress-bar-spacing">
                                <div class="progress-fill" style="width: ${capturedPercent}%; background: #4CAF50;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <details class="mt-10">
                        <summary class="details-summary">üìä Progresso por Classe</summary>
                        <div class="mt-10">
                            ${Object.entries(classCounts).map(([cls, counts]) => {
                                const pct = counts.total > 0 ? Math.floor((counts.captured / counts.total) * 100) : 0;
                                return `
                                    <div class="mb-8">
                                        <strong>${cls}:</strong> ${counts.captured}/${counts.total}
                                        <div class="progress-bar progress-bar-spacing-sm">
                                            <div class="progress-fill" style="width: ${pct}%; background: #9C27B0;"></div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </details>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Error rendering monstrodex:', error);
            }
        }

        /**
         * FASE 1 POKEMON: Renderiza se√ß√£o de Conquistas
         */
        function renderAchievements() {
            try {
                const container = document.getElementById('achievementsStats');
                if (!container) return;
                
                const stats = GameState.stats || {
                    battlesWon: 0,
                    battlesLost: 0,
                    captureAttempts: 0,
                    capturesSuccessful: 0,
                    totalXpGained: 0,
                    totalMoneyEarned: 0,
                    currentWinStreak: 0,
                    highestWinStreak: 0
                };
                
                const totalBattles = stats.battlesWon + stats.battlesLost;
                const winRate = totalBattles > 0 ? Math.floor((stats.battlesWon / totalBattles) * 100) : 0;
                const captureRate = stats.captureAttempts > 0 ? Math.floor((stats.capturesSuccessful / stats.captureAttempts) * 100) : 0;
                
                let html = `
                    <div class="stats-grid-180">
                        <div class="stat-box">
                            <div class="stat-value success">‚öîÔ∏è ${stats.battlesWon}</div>
                            <div class="stat-label">Vit√≥rias</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value danger">üíÄ ${stats.battlesLost}</div>
                            <div class="stat-label">Derrotas</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value info">üìä ${winRate}%</div>
                            <div class="stat-label">Taxa de Vit√≥ria</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value warning">üî• ${stats.currentWinStreak}</div>
                            <div class="stat-label">Sequ√™ncia Atual</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value purple">üèÜ ${stats.highestWinStreak}</div>
                            <div class="stat-label">Melhor Sequ√™ncia</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value success">üéØ ${captureRate}%</div>
                            <div class="stat-label">Taxa de Captura</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value violet">‚ú® ${stats.totalXpGained}</div>
                            <div class="stat-label">XP Total</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value gold">üí∞ ${stats.totalMoneyEarned}</div>
                            <div class="stat-label">Moedas Ganhas</div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Error rendering achievements:', error);
            }
        }

        function updatePlayersList() {
            try {
                const container = document.getElementById('playersList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<div class="card"><p>No players yet. Add one above!</p></div>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const teamCount = player.team?.length || 0;
                    const boxCount = player.box?.length || 0;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <div class="badge badge-${player.playerClassId}">${player.playerClassId}</div>
                            <p>üí∞ Money: ${player.money || 0} | ‚≠ê Afterlife: ${player.afterlifeCurrency || 0}</p>
                            <p>üë• Team: ${teamCount}/${GameState.config?.maxTeamSize || 6} | üì¶ Box: ${boxCount}</p>
                            
                            <h4>Team Order (${teamCount}):</h4>
                            <div class="team-reorder-section">
                                <p class="text-small text-muted mb-10">First alive monster will be your starter in battle. Use arrows to reorder.</p>
                                ${renderTeamReorderList(player)}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update players list:', error);
            }
        }

        function renderMonsterCard(monster) {
            try {
                if (!monster) return '';
                
                const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                const xpNeeded = (monster.level || 1) * 100;
                const xpPercent = ((monster.xp || 0) / xpNeeded) * 100;
                
                // SISTEMA DE AMIZADE
                const friendship = monster.friendship || DEFAULT_FRIENDSHIP;
                const friendshipIcon = getFriendshipIcon(friendship);
                const friendshipLevel = getFriendshipLevel(friendship);
                const friendshipBonuses = getFriendshipBonuses(friendship);
                
                // Tooltip com informa√ß√µes completas de amizade
                let friendshipTooltip = `N√≠vel de Amizade: ${friendshipLevel}/5`;
                if (friendshipBonuses.xpMultiplier > 1.0) {
                    friendshipTooltip += `\nB√¥nus XP: +${formatFriendshipBonusPercent(friendshipBonuses.xpMultiplier)}%`;
                }
                if (friendshipBonuses.critChance > 0) {
                    friendshipTooltip += `\nChance Cr√≠tico: +${friendshipBonuses.critChance * 100}%`;
                }
                if (friendshipBonuses.statBonus > 0) {
                    friendshipTooltip += `\nB√¥nus Stats: +${friendshipBonuses.statBonus}`;
                }
                // Nota: surviveChance removido do tooltip at√© implementa√ß√£o
                // if (friendshipBonuses.surviveChance > 0) {
                //     friendshipTooltip += `\n[EM BREVE] Chance Sobreviver: ${friendshipBonuses.surviveChance * 100}%`;
                // }
                
                return `
                    <div class="monster-card ${monster.class || 'common'}">
                        <div class="font-size-36">${monster.emoji || 'üîÆ'}</div>
                        <strong>${monster.name || 'Unknown'}</strong>
                        ${monster.isShiny ? '<div class="badge badge-shiny">‚≠ê SHINY ‚≠ê</div>' : ''}
                        <div class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'common'}</div>
                        <div>Lv ${monster.level || 1}</div>
                        <div class="progress-bar h-30">
                            <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                        </div>
                        <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                        <div class="progress-bar h-15">
                            <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                        </div>
                        <small>${monster.xp || 0}/${xpNeeded} XP</small>
                        
                        <div class="friendship-indicator" title="${friendshipTooltip}">
                            ${friendshipIcon} <span class="friendship-text">${friendship}/100</span>
                            <div class="friendship-bar">
                                <div class="friendship-fill" style="width: ${friendship}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to render monster card:', error);
                return '<div class="monster-card">Error</div>';
            }
        }

        function renderTeamReorderList(player) {
            try {
                if (!player || !player.team || player.team.length === 0) {
                    return '<p class="text-muted">No monsters in team.</p>';
                }

                let html = '<div class="team-reorder-container">';
                
                player.team.forEach((monster, index) => {
                    if (!monster) return;
                    
                    const isActive = index === (player.activeIndex ?? 0);
                    const isAlive = _isAlive(monster);
                    const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                    
                    // PR12A: Get equipped item info
                    let equippedItemHtml = '';
                    if (monster.heldItemId && window.Data && window.Data.getItemById) {
                        const itemDef = window.Data.getItemById(monster.heldItemId);
                        if (itemDef) {
                            const atkBonus = itemDef.stats?.atk || 0;
                            const defBonus = itemDef.stats?.def || 0;
                            let statsText = '';
                            if (atkBonus > 0) statsText += `+${atkBonus} ATK `;
                            if (defBonus > 0) statsText += `+${defBonus} DEF`;
                            equippedItemHtml = `
                                <div class="text-small mt-5">
                                    üéí <strong>${itemDef.name}</strong> (${statsText})
                                    <button class="btn btn-xs" onclick="unequipItem('${player.id}', ${index})">Remover</button>
                                </div>
                            `;
                        }
                    } else {
                        equippedItemHtml = `
                            <div class="text-small mt-5">
                                üéí <em>Nenhum item equipado</em>
                            </div>
                        `;
                    }
                    
                    html += `
                        <div class="team-member-card ${isActive ? 'team-member-card-active' : 'team-member-card-inactive'}">
                            <span class="team-member-index">${index + 1}.</span>
                            <div class="team-member-info">
                                <strong>${monster.name || 'Unknown'}</strong>
                                <span class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'Comum'}</span>
                                Lv${monster.level || 1}
                                ${!isAlive ? '<span class="color-error text-bold"> (Fainted)</span>' : ''}
                                <div class="progress-bar h-15 mt-5">
                                    <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                                </div>
                                <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                                ${equippedItemHtml}
                            </div>
                            <div class="team-member-buttons">
                                ${index > 0 ? `<button class="btn btn-sm-arrow" onclick="moveTeamMemberUp('${player.id}', ${index})">‚ñ≤</button>` : '<span style="height:20px;display:block;"></span>'}
                                ${index < player.team.length - 1 ? `<button class="btn btn-sm-arrow" onclick="moveTeamMemberDown('${player.id}', ${index})">‚ñº</button>` : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // PR12A: Add equipable items section
                html += renderEquipableItems(player);
                
                return html;
            } catch (error) {
                console.error('Failed to render team reorder list:', error);
                return '<p class="color-error">Error rendering team list</p>';
            }
        }

        function moveTeamMemberUp(playerId, index) {
            try {
                const player = GameState.players?.find(p => p?.id === playerId);
                if (!player || !player.team || index <= 0 || index >= player.team.length) return;
                
                // Swap with previous
                const temp = player.team[index - 1];
                player.team[index - 1] = player.team[index];
                player.team[index] = temp;
                
                // Update activeIndex if needed
                if (player.activeIndex === index) {
                    player.activeIndex = index - 1;
                } else if (player.activeIndex === index - 1) {
                    player.activeIndex = index;
                }
                
                saveGame();
                updatePlayersList();
                showToast('Team order updated!');
            } catch (error) {
                console.error('Failed to move team member up:', error);
                showToast('Error reordering team');
            }
        }

        function moveTeamMemberDown(playerId, index) {
            try {
                const player = GameState.players?.find(p => p?.id === playerId);
                if (!player || !player.team || index < 0 || index >= player.team.length - 1) return;
                
                // Swap with next
                const temp = player.team[index + 1];
                player.team[index + 1] = player.team[index];
                player.team[index] = temp;
                
                // Update activeIndex if needed
                if (player.activeIndex === index) {
                    player.activeIndex = index + 1;
                } else if (player.activeIndex === index + 1) {
                    player.activeIndex = index;
                }
                
                saveGame();
                updatePlayersList();
                showToast('Team order updated!');
            } catch (error) {
                console.error('Failed to move team member down:', error);
                showToast('Error reordering team');
            }
        }

        // PR12A: Equipment UI Functions
        function renderEquipableItems(player) {
            try {
                if (!player || !player.inventory) {
                    return '';
                }
                
                // Get all items from inventory
                const inventoryItems = Object.keys(player.inventory || {});
                if (inventoryItems.length === 0) {
                    return '';
                }
                
                // Filter to equipable items only (type: held)
                const equipableItems = [];
                for (const itemId of inventoryItems) {
                    const qty = player.inventory[itemId] || 0;
                    if (qty > 0 && window.Data && window.Data.getItemById) {
                        const itemDef = window.Data.getItemById(itemId);
                        if (itemDef && itemDef.type === 'held') {
                            equipableItems.push({ id: itemId, def: itemDef, qty: qty });
                        }
                    }
                }
                
                if (equipableItems.length === 0) {
                    return '';
                }
                
                let html = `
                    <div class="card mt-10">
                        <h4 class="m-0">üéí Itens Dispon√≠veis para Equipar</h4>
                        <p class="text-small text-muted">Selecione um monstrinho acima, depois clique em Equipar</p>
                        <div class="mt-10">
                `;
                
                equipableItems.forEach(item => {
                    const atkBonus = item.def.stats?.atk || 0;
                    const defBonus = item.def.stats?.def || 0;
                    let statsText = '';
                    if (atkBonus > 0) statsText += `+${atkBonus} ATK `;
                    if (defBonus > 0) statsText += `+${defBonus} DEF`;
                    
                    html += `
                        <div class="flex-between mb-5">
                            <span>
                                <strong>${item.def.name}</strong> 
                                <span class="text-small text-muted">(${statsText})</span>
                                x${item.qty}
                            </span>
                            <div>
                    `;
                    
                    // Add equip button for each team member
                    if (player.team && player.team.length > 0) {
                        player.team.forEach((monster, idx) => {
                            if (!monster) return;
                            html += `
                                <button class="btn btn-xs" onclick="equipItem('${player.id}', ${idx}, '${item.id}')">
                                    ‚Üí ${monster.name}
                                </button>
                            `;
                        });
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            } catch (error) {
                console.error('Failed to render equipable items:', error);
                return '';
            }
        }
        
        function equipItem(playerId, monsterIndex, itemId) {
            try {
                const player = GameState.players?.find(p => p?.id === playerId);
                if (!player || !player.team || monsterIndex < 0 || monsterIndex >= player.team.length) {
                    showToast('Erro: Jogador ou monstrinho n√£o encontrado');
                    return;
                }
                
                const monster = player.team[monsterIndex];
                if (!monster) {
                    showToast('Erro: Monstrinho n√£o encontrado');
                    return;
                }
                
                // Check inventory
                player.inventory = player.inventory || {};
                const itemCount = player.inventory[itemId] || 0;
                if (itemCount < 1) {
                    showToast('Erro: Item n√£o dispon√≠vel no invent√°rio');
                    return;
                }
                
                // Get item definition
                let itemName = itemId;
                if (window.Data && window.Data.getItemById) {
                    const itemDef = window.Data.getItemById(itemId);
                    if (itemDef) {
                        itemName = itemDef.name;
                    }
                }
                
                // If monster already has item equipped, unequip it first
                if (monster.heldItemId) {
                    // Return old item to inventory
                    player.inventory[monster.heldItemId] = (player.inventory[monster.heldItemId] || 0) + 1;
                }
                
                // Equip new item
                monster.heldItemId = itemId;
                
                // Remove from inventory
                player.inventory[itemId] = itemCount - 1;
                if (player.inventory[itemId] === 0) {
                    delete player.inventory[itemId];
                }
                
                saveGame();
                updatePlayersList();
                showToast(`‚úÖ ${itemName} equipado em ${monster.name}!`);
            } catch (error) {
                console.error('Failed to equip item:', error);
                showToast('Erro ao equipar item');
            }
        }
        
        function unequipItem(playerId, monsterIndex) {
            try {
                const player = GameState.players?.find(p => p?.id === playerId);
                if (!player || !player.team || monsterIndex < 0 || monsterIndex >= player.team.length) {
                    showToast('Erro: Jogador ou monstrinho n√£o encontrado');
                    return;
                }
                
                const monster = player.team[monsterIndex];
                if (!monster || !monster.heldItemId) {
                    showToast('Erro: Nenhum item equipado');
                    return;
                }
                
                // Get item name
                let itemName = monster.heldItemId;
                if (window.Data && window.Data.getItemById) {
                    const itemDef = window.Data.getItemById(monster.heldItemId);
                    if (itemDef) {
                        itemName = itemDef.name;
                    }
                }
                
                // Return item to inventory
                player.inventory = player.inventory || {};
                player.inventory[monster.heldItemId] = (player.inventory[monster.heldItemId] || 0) + 1;
                
                // Remove from monster
                const oldItemId = monster.heldItemId;
                monster.heldItemId = null;
                
                saveGame();
                updatePlayersList();
                showToast(`‚úÖ ${itemName} removido de ${monster.name}!`);
            } catch (error) {
                console.error('Failed to unequip item:', error);
                showToast('Erro ao remover item');
            }
        }
        
        // PR12A: Make equipment functions globally available
        window.equipItem = equipItem;
        window.unequipItem = unequipItem;

        function updateSessionView() {
            try {
                const panel = document.getElementById('activeSessionPanel');
                if (!panel) return;
                
                if (!GameState.currentSession) {
                    hideEl(panel);
                    return;
                }
                
                showEl(panel);
                
                const session = GameState.currentSession;
                document.getElementById('activeSessionName').textContent = session.name || 'Unnamed';
                document.getElementById('sessionCreated').textContent = new Date(session.createdAt).toLocaleString();
                
                const turnList = document.getElementById('turnOrderList');
                if (turnList) {
                    let html = '<div class="flex">';
                    (session.turnOrder || []).forEach((playerId, index) => {
                        const player = GameState.players?.find(p => p?.id === playerId);
                        if (player) {
                            const isCurrent = index === (session.currentTurnIndex || 0);
                            html += `
                                <div class="stat-box" style="${isCurrent ? 'background: var(--success); color: white;' : ''}">
                                    ${isCurrent ? '‚ñ∂ ' : ''}${player.name}
                                </div>
                            `;
                        }
                    });
                    html += '</div>';
                    turnList.innerHTML = html;
                }
            } catch (error) {
                console.error('Failed to update session view:', error);
            }
        }

        function updateTherapyView() {
            try {
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    let html = '<h4>Current Objectives:</h4>';
                    (GameState.objectives || []).forEach(obj => {
                        if (!obj) return;
                        html += `
                            <div class="objective-item">
                                <strong>Weight ${obj.weight}:</strong> ${obj.text}
                            </div>
                        `;
                    });
                    objectivesList.innerHTML = html;
                }
                
                const therapyPlayersList = document.getElementById('therapyPlayersList');
                if (!therapyPlayersList) return;
                
                if (!GameState.currentSession) {
                    therapyPlayersList.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                let html = '';
                (GameState.players || []).forEach(player => {
                    if (!player) return;
                    
                    const therapy = GameState.currentSession.therapy?.perPlayer?.[player.id];
                    if (!therapy) return;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <p><strong>PM (Merit Points):</strong> ${therapy.pm || 0}</p>
                            <p><strong>Medals:</strong> 
                                ${(therapy.medals || []).map(m => {
                                    const emoji = { bronze: 'ü•â', silver: 'ü•à', gold: 'ü•á' }[m] || 'üèÖ';
                                    return `<span class="medal">${emoji}</span>`;
                                }).join('')}
                            </p>
                            
                            <h4>Objectives:</h4>
                            ${(GameState.objectives || []).map(obj => {
                                if (!obj) return '';
                                const completed = therapy.completedObjectives?.includes(obj.id);
                                return `
                                    <div class="objective-item">
                                        <input type="checkbox" 
                                               ${completed ? 'checked' : ''}
                                               onchange="toggleObjectiveForPlayer(${player.id}, ${obj.id})"
                                               class="small-icon">
                                        <span>${obj.text} (${obj.weight} PM)</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                });
                
                therapyPlayersList.innerHTML = html;
            } catch (error) {
                console.error('Failed to update therapy view:', error);
            }
        }

        function updateReportView() {
            try {
                const container = document.getElementById('reportContent');
                if (!container) return;
                
                if (!GameState.currentSession) {
                    container.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                const session = GameState.currentSession;
                
                let html = `
                    <div class="card">
                        <h3>Session: ${session.name}</h3>
                        <p>Started: ${new Date(session.createdAt).toLocaleString()}</p>
                        ${session.completedAt ? `<p>Ended: ${new Date(session.completedAt).toLocaleString()}</p>` : '<p>Status: Active</p>'}
                    </div>
                    
                    <div class="card">
                        <h3>Player Summary</h3>
                        ${(GameState.players || []).map(player => {
                            if (!player) return '';
                            const therapy = session.therapy?.perPlayer?.[player.id];
                            if (!therapy) return '';
                            
                            return `
                                <div class="my-15 p-15 bg-white border-radius-12">
                                    <h4>${player.name}</h4>
                                    <p>PM Earned: ${therapy.pm || 0}</p>
                                    <p>Medals: ${(therapy.medals || []).join(', ') || 'None yet'}</p>
                                    <p>Objectives Completed: ${therapy.completedObjectives?.length || 0}/${GameState.objectives?.length || 0}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update report view:', error);
            }
        }

        // DATA MANAGEMENT
        function exportData() {
            try {
                const data = JSON.stringify(GameState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                showError('Export failed', error.stack);
            }
        }

        function importData() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target?.files?.[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target?.result || '{}');
                            Object.assign(GameState, data);
                            saveToLocalStorage();
                            updateAllViews();
                            alert('Data imported successfully!');
                        } catch (error) {
                            showError('Import failed', error.stack);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError('Import failed', error.stack);
            }
        }

        function clearAllData() {
            try {
                if (confirm('Are you sure? This will delete ALL data!')) {
                    if (confirm('Really sure? This cannot be undone!')) {
                        StorageManager.remove(StorageManager.StorageKeys.STATE); // PR3
                        location.reload();
                    }
                }
            } catch (error) {
                showError('Clear data failed', error.stack);
            }
        }

        function toggleTherapistMode() {
            try {
                const checked = document.getElementById('therapistMode')?.checked;
                const success = mmSetTherapistMode(checked);
                
                // Mostrar feedback visual para o usu√°rio
                if (success) {
                    if (checked) {
                        showToast('üî¨ Modo Terapeuta ativado', 'success');
                    } else {
                        showToast('Modo Terapeuta desativado', 'info');
                    }
                } else {
                    // Falha silenciosa corrigida: informar o usu√°rio sobre o erro
                    showToast('‚ùå Falha ao alterar modo terapeuta', 'error');
                    console.error('[toggleTherapistMode] mmSetTherapistMode returned false');
                    // Reverter checkbox para o estado correto
                    const checkbox = document.getElementById('therapistMode');
                    if (checkbox) {
                        checkbox.checked = mmIsTherapistMode();
                    }
                }
                
                // Also update the old config panel if it exists
                const configPanel = document.getElementById('configPanel');
                if (configPanel) {
                    if (checked) {
                        showEl(configPanel);
                    } else {
                        hideEl(configPanel);
                    }
                }
            } catch (error) {
                console.error('[toggleTherapistMode] Failed to toggle therapist mode:', error);
                showToast('‚ùå Erro ao alterar modo terapeuta: ' + error.message, 'error');
            }
        }

        // Feature 4.4: Global click listener for button sounds
        document.addEventListener("click", (e) => {
            const btn = e.target.closest("button");
            if (!btn) return;
            // Avoid spam on disabled buttons
            if (btn.disabled) return;
            // Avoid double-sound on audio control buttons
            if (btn.id === "mmMuteBtn" || btn.textContent.includes("Testar som")) return;
            Audio.playSfx("ui_click");
        });

        // ===== Feature 4.0: Menu / Flow =====
        const MM_SAVE_KEY = "monstrinhomon_state"; // Using the same key as the existing save system

        function mmEl(id){ return document.getElementById(id); }

        function mmCloseAllOverlays(){
            ["mmIntro","mmMenu","mmNewGame","mmConfig","mmTherapist","mmSavesScreen","mmSlotPicker","mmStartChoice"].forEach(id => {
                const el = mmEl(id);
                if (el) {
                    el.classList.remove("show");
                    el.classList.add("is-hidden");
                }
            });
        }

        function mmShow(id){
            mmCloseAllOverlays();
            const el = mmEl(id);
            if (el) {
                el.classList.remove("is-hidden");
                el.classList.add("show");
            }
        }

        function mmHasSave(){
            // Check if any slot has a valid save
            try {
                for (let slot = 1; slot <= 3; slot++) {
                    const env = mmReadSlot(slot);
                    if (env && env.state) return true;
                }
                return false;
            } catch(e){ 
                return false; 
            }
        }

        function mmBoot(){
            // Show intro on boot
            mmShow("mmIntro");
        }

        function mmShowMainMenu(){
            mmShow("mmMenu");
            const btn = mmEl("mmBtnContinue");
            const ok = mmHasSave();
            if (btn) {
                btn.disabled = !ok;
                btn.textContent = ok ? "üìñ Continuar" : "üìñ Continuar (sem save)";
            }
            // Update therapist button visibility
            mmUpdateTherapistUI();
        }

        function mmShowConfig(){
            mmShow("mmConfig");
        }

        // Feature 4.6: Therapist Mode Panel Functions
        function mmOpenTherapistPanel() {
            if (!mmRequireGameOrAlert()) return;
            mmShow("mmTherapist");
            mmRenderTherapistPanel();
        }

        function mmRenderTherapistPanel() {
            const host = document.getElementById("mmTherapistBody");
            if (!host) return;
            
            if (!mmIsTherapistMode()) {
                host.innerHTML = `<div class="opacity-80">Ative o Therapist Mode nas Configura√ß√µes.</div>`;
                return;
            }
            
            if (!mmRequireGameOrAlert()) {
                host.innerHTML = "";
                return;
            }

            const players = GameState.players || [];
            
            // Build player options
            const playerOptions = players.map(p => `<option value="${p.id}">${escapeHtml(p.name)} (${escapeHtml(p.class || 'N/A')})</option>`).join("");

            // Build item options (ClasterOrbs + healing items)
            const itemOptions = `
                <option value="CLASTERORB_COMUM">‚ö™ ClasterOrb Comum</option>
                <option value="CLASTERORB_INCOMUM">üîµ ClasterOrb Incomum</option>
                <option value="CLASTERORB_RARA">üü£ ClasterOrb Rara</option>
                <option value="IT_HEAL_01">üíö Petisco de Cura</option>
            `;

            // Build monster options from catalog
            const monOptions = MONSTER_CATALOG.map(m => 
                `<option value="${m.id}">${escapeHtml(m.name)} [${escapeHtml(m.class)}] (${escapeHtml(m.rarity)})</option>`
            ).join("");

            host.innerHTML = `
                <div class="d-grid grid-gap-10">
                    <div>
                        <div class="therapist-field-title">Jogador alvo</div>
                        <select id="mmTherPlayer" class="mm-input">${playerOptions}</select>
                    </div>

                    <div class="therapist-mestre-box">
                        <div class="therapist-field-title">‚ú® Dar XP (monstro ativo)</div>
                        <div class="mm-row mb-8">
                            <button class="mm-btn flex-1" onclick="mmTherGiveXPQuick(10)">+10 XP</button>
                            <button class="mm-btn flex-1" onclick="mmTherGiveXPQuick(50)">+50 XP</button>
                        </div>
                        <div class="mm-row">
                            <input id="mmTherXp" class="mm-input flex-1" type="number" min="1" value="50">
                            <button class="mm-btn" onclick="mmTherGiveXP()">+ XP</button>
                        </div>
                        <div class="opacity-80 font-size-12 mt-6">Aplica no monstro ativo (player.activeIndex).</div>
                    </div>

                    <div class="therapist-mestre-box">
                        <div class="therapist-field-title">üéí Dar Item</div>
                        <div class="mm-row">
                            <select id="mmTherItem" class="mm-input flex-1">${itemOptions}</select>
                            <input id="mmTherItemQty" class="mm-input w-90" type="number" min="1" value="1">
                            <button class="mm-btn" onclick="mmTherGiveItem()">Adicionar</button>
                        </div>
                    </div>

                    <div class="therapist-mestre-box">
                        <div class="therapist-field-title">üéÅ Conceder Monstrinhomon</div>
                        <div class="mm-row mb-8">
                            <select id="mmTherMon" class="mm-input flex-1">${monOptions}</select>
                        </div>
                        <div class="mm-row mb-8">
                            <div class="flex-1">
                                <label class="therapist-label">N√≠vel (1-100)</label>
                                <input id="mmTherMonLv" class="mm-input" type="number" min="1" max="100" value="5">
                            </div>
                            <div class="flex-1">
                                <label class="therapist-label">Raridade</label>
                                <select id="mmTherMonRarity" class="mm-input">
                                    <option value="">Padr√£o do Template</option>
                                    <option value="Comum">Comum</option>
                                    <option value="Incomum">Incomum</option>
                                    <option value="Raro">Raro</option>
                                    <option value="M√≠stico">M√≠stico</option>
                                    <option value="Lend√°rio">Lend√°rio</option>
                                </select>
                            </div>
                        </div>
                        <div class="mm-row">
                            <select id="mmTherMonDest" class="mm-input flex-1">
                                <option value="auto">Auto (Time se &lt;6, sen√£o Caixa)</option>
                                <option value="team">For√ßar Time</option>
                                <option value="box">For√ßar Caixa</option>
                            </select>
                            <button class="mm-btn" onclick="mmTherGiveMonster()">Conceder</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Therapist action: Give XP
        /**
         * Clears the therapist log panel
         */
        function clearTherapistLog() {
            const logContainer = document.getElementById("therapistLog");
            if (logContainer) {
                logContainer.innerHTML = "";
                therapistLog("Log cleared");
            }
        }

        // Therapist action: Give XP (uses Award API)
        function mmTherGiveXP() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const amt = Math.max(1, parseInt(document.getElementById("mmTherXp")?.value || "0", 10));

            const player = GameState.players.find(p => p.id === pid);
            if (!player) {
                showToast("Jogador n√£o encontrado.", 'error');
                therapistLog("‚ùå awardXP failed: player not found");
                return;
            }

            // Validate team and activeIndex
            if (!player.team || !Array.isArray(player.team) || player.team.length === 0) {
                showToast("Jogador n√£o tem monstrinhos no time.", 'error');
                therapistLog("‚ùå awardXP failed: empty team");
                return;
            }

            // Ensure activeIndex is valid
            if (typeof player.activeIndex !== 'number' || player.activeIndex < 0) {
                player.activeIndex = 0;
            }

            const mon = player.team[player.activeIndex];
            if (!mon) {
                showToast("Monstrinho ativo n√£o encontrado.", 'error');
                therapistLog("‚ùå awardXP failed: active monster not found");
                return;
            }

            // Use Award API
            const success = awardXP(player.activeIndex, amt, player);
            
            if (success) {
                if (typeof renderEncounter === "function") renderEncounter();
                showToast(`‚ú® ${mon.name} recebeu +${amt} XP! (N√≠vel ${mon.level})`);
                therapistLog(`‚úÖ awardXP +${amt} ‚Üí ${mon.name} (Lv ${mon.level})`);
            } else {
                showToast("Falha ao dar XP.", 'error');
                therapistLog("‚ùå awardXP failed");
            }
        }

        // Quick XP buttons
        function mmTherGiveXPQuick(amount) {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const player = GameState.players.find(p => p.id === pid);
            
            if (!player) {
                showToast("Jogador n√£o encontrado.", 'error');
                therapistLog("‚ùå awardXP failed: player not found");
                return;
            }

            // Validate team and activeIndex
            if (!player.team || !Array.isArray(player.team) || player.team.length === 0) {
                showToast("Jogador n√£o tem monstrinhos no time.", 'error');
                therapistLog("‚ùå awardXP failed: empty team");
                return;
            }

            // Ensure activeIndex is valid
            if (typeof player.activeIndex !== 'number' || player.activeIndex < 0) {
                player.activeIndex = 0;
            }

            const mon = player.team[player.activeIndex];
            if (!mon) {
                showToast("Monstrinho ativo n√£o encontrado.", 'error');
                therapistLog("‚ùå awardXP failed: active monster not found");
                return;
            }

            // Use Award API
            const success = awardXP(player.activeIndex, amount, player);
            
            if (success) {
                if (typeof renderEncounter === "function") renderEncounter();
                showToast(`‚ú® ${mon.name} recebeu +${amount} XP! (N√≠vel ${mon.level})`);
                therapistLog(`‚úÖ awardXP +${amount} ‚Üí ${mon.name} (Lv ${mon.level})`);
            } else {
                showToast("Falha ao dar XP.", 'error');
                therapistLog("‚ùå awardXP failed");
            }
        }

        // Therapist action: Give Item (uses Award API)
        function mmTherGiveItem() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const itemId = document.getElementById("mmTherItem")?.value;
            const qty = Math.max(1, parseInt(document.getElementById("mmTherItemQty")?.value || "1", 10));

            const player = GameState.players.find(p => p.id === pid);
            if (!player) {
                showToast("Jogador n√£o encontrado.", 'error');
                therapistLog("‚ùå awardItem failed: player not found");
                return;
            }

            if (!itemId) {
                showToast("Selecione um item.", 'error');
                therapistLog("‚ùå awardItem failed: no item selected");
                return;
            }

            // Commit 12 (Wave C12.2): Validate itemId using catalog helper
            const itemDef = requireItemDef(itemId, 'therapist-UI');
            if (!itemDef) {
                showToast("Item inv√°lido.", 'error');
                therapistLog(`‚ùå awardItem failed: invalid itemId ${itemId}`);
                return;
            }

            // Use Award API
            const success = awardItem(itemId, qty, player);
            
            if (success) {
                if (typeof renderEncounter === "function") renderEncounter();
                
                // Use item name from catalog
                const itemName = itemDef.name || itemId;
                
                showToast(`üéí ${player.name} recebeu ${qty}x ${itemName}`);
                therapistLog(`‚úÖ awardItem ${itemId} x${qty} ‚Üí ${player.name}`);
            } else {
                showToast("Falha ao dar item.", 'error');
                therapistLog("‚ùå awardItem failed");
            }
        }

        // Therapist action: Give Monster
        function mmTherGiveMonster() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const monId = document.getElementById("mmTherMon")?.value;
            const lv = parseInt(document.getElementById("mmTherMonLv")?.value || "1", 10);
            const rarityInput = document.getElementById("mmTherMonRarity")?.value;
            const dest = document.getElementById("mmTherMonDest")?.value || "auto";

            const player = GameState.players.find(p => p.id === pid);
            if (!player) {
                showToast("Jogador n√£o encontrado.", 'error');
                therapistLog("‚ùå awardMonster failed: player not found");
                return;
            }

            // Commit 12 (Wave C12.2): Validate templateId using catalog helper
            const template = requireMonsterTemplate(monId, 'therapist-UI');
            if (!template) {
                showToast("Template de monstro inv√°lido.", 'error');
                therapistLog(`‚ùå awardMonster failed: invalid templateId ${monId}`);
                return;
            }

            // Clamp level between 1 and 100
            const clampedLevel = Math.max(1, Math.min(100, lv));

            // Use template rarity if not specified (empty string means use template default)
            const rarity = rarityInput || null;

            // Track team size before to detect if it went to box
            const teamSizeBefore = player.team?.length || 0;
            const requestedTeam = (dest === 'team' || dest === 'auto');

            // COMMIT 8 (Wave A): Use Award API for canonical monster creation
            const inst = awardMonster(
                monId,          // templateId
                clampedLevel,   // level (clamped)
                rarity,         // rarity (null = use template default)
                dest,           // destination ('auto', 'team', or 'box')
                player          // player object
            );
            
            if (!inst) {
                showToast("Falha ao conceder monstro.", 'error');
                therapistLog("‚ùå awardMonster failed: creation error");
                return;
            }

            if (typeof renderEncounter === "function") renderEncounter();
            
            // Determine where it actually went (Award API handles team limit)
            const inTeam = player.team.some(m => m.instanceId === inst.instanceId);
            const actualDest = inTeam ? "time" : "caixa";
            
            // Check if it was redirected to box due to team being full
            const wasRedirected = requestedTeam && !inTeam && teamSizeBefore >= 6;
            
            // Build toast message
            const rarityText = inst.rarity || 'Comum';
            let toastMsg = `üéÅ Concedido ${inst.name} Lv${clampedLevel} (${rarityText}) ‚Üí ${actualDest}`;
            if (wasRedirected) {
                toastMsg += ` (time cheio)`;
            }
            
            showToast(toastMsg, 'success');
            therapistLog(`‚úÖ awardMonster ${monId} Lv${clampedLevel} ${rarityText} ‚Üí ${actualDest}${wasRedirected ? ' (redirected from team)' : ''}`);
        }

        function mmContinue(){
            // Check if there's a last slot saved - if so, load from it
            try {
                const lastSlot = StorageManager.getLastSlot(); // PR3
                if (lastSlot) {
                    const slotNum = parseInt(lastSlot, 10);
                    if ([1, 2, 3].includes(slotNum)) {
                        // Load from slot - this will call mmPostGameStartFlow()
                        mmLoadFromSlot(slotNum);
                        return;
                    }
                }
            } catch (e) {
                console.warn("Failed to check last slot", e);
            }

            // Fallback: load from main localStorage
            try {
                // Load from the last used slot
                const lastSlot = mmGetLastSlot();
                const env = mmReadSlot(lastSlot);
                
                if (!env || !env.state) {
                    alert("Nenhum save encontrado para continuar.");
                    return;
                }
                
                // Load the save from the slot
                Object.assign(GameState, env.state);
                GameState.saveSlot = lastSlot;
                
                // Update views
                if (typeof updateAllViews === "function") updateAllViews();
                if (typeof renderEncounter === "function") renderEncounter();
                
                showToast(`üìÇ Carregado do Slot ${lastSlot}!`);
            } catch(e){
                console.warn("mmContinue failed", e);
                alert("Erro ao carregar o save: " + e.message);
                mmCloseAllOverlays();
                return;
            }
            mmCloseAllOverlays();
            // Feature 4.1.1: Show tutorial choice or go to game based on preference
            mmPostGameStartFlow();
        }

        function mmResetSaveConfirm(){
            const ok = confirm("Apagar o save do navegador? Isso n√£o pode ser desfeito.");
            if (!ok) return;
            try {
                StorageManager.remove(MM_SAVE_KEY); // PR3
                alert("Save apagado com sucesso!");
            } catch(e){
                alert("Erro ao apagar save: " + e.message);
            }
            mmShowMainMenu();
        }

        // ---- New Game Wizard (MVP) ----
        const MM_NEW = {
            step: 0,
            numPlayers: 1,
            difficulty: "medium",
            players: [] // {name, class}
        };

        // @deprecated - Use MM_TABLES.CLASSES instead
        // Kept for backward compatibility  
        const MM_CLASSES = MM_TABLES.CLASSES;

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function mmStartNewGame(){
            MM_NEW.step = 0;
            MM_NEW.numPlayers = 1;
            MM_NEW.difficulty = "medium";
            MM_NEW.players = [];
            mmShow("mmNewGame");
            mmRenderNewGameStep();
        }

        function mmRenderNewGameStep(){
            const host = mmEl("mmNewGameStep");
            if (!host) return;

            if (MM_NEW.step === 0) {
                host.innerHTML = `
                    <p class="mm-sub">Quantos jogadores?</p>
                    <div class="mm-field">
                        <label>N√∫mero de jogadores (1‚Äì6)</label>
                        <input id="mmNumPlayers" type="number" min="1" max="6" value="${MM_NEW.numPlayers}">
                        <div class="mm-hint">Dica: em grupo, cada jogador usa monstrinhos da pr√≥pria classe.</div>
                    </div>
                `;
                return;
            }

            if (MM_NEW.step === 1) {
                host.innerHTML = `
                    <p class="mm-sub">Selecione a dificuldade</p>
                    <div class="mm-field">
                        <label>Dificuldade</label>
                        <select id="mmDifficulty">
                            <option value="easy" ${MM_NEW.difficulty==="easy"?"selected":""}>F√°cil</option>
                            <option value="medium" ${MM_NEW.difficulty==="medium"?"selected":""}>M√©dio</option>
                            <option value="hard" ${MM_NEW.difficulty==="hard"?"selected":""}>Dif√≠cil</option>
                        </select>
                        <div class="mm-hint">MVP: afeta encontros futuros conforme seu sistema de difficulty.</div>
                    </div>
                `;
                return;
            }

            // Step 2: players
            if (MM_NEW.step === 2) {
                // garante array
                while (MM_NEW.players.length < MM_NEW.numPlayers) {
                    MM_NEW.players.push({ name: "", class: MM_CLASSES[0] });
                }
                while (MM_NEW.players.length > MM_NEW.numPlayers) {
                    MM_NEW.players.pop();
                }

                const rows = MM_NEW.players.map((p, i) => `
                    <div class="border-pale border-radius-14 p-10-12 my-10">
                        <div class="text-900 mb-8">Jogador ${i+1}</div>
                        <div class="mm-field">
                            <label>Nome</label>
                            <input id="mmPName_${i}" maxlength="14" placeholder="Ex.: Ana" value="${escapeHtml(p.name || "")}">
                        </div>
                        <div class="mm-field">
                            <label>Classe</label>
                            <select id="mmPClass_${i}">
                                ${MM_CLASSES.map(c => `<option value="${escapeHtml(c)}" ${p.class===c?"selected":""}>${escapeHtml(c)}</option>`).join("")}
                            </select>
                        </div>
                    </div>
                `).join("");

                host.innerHTML = `
                    <p class="mm-sub">Crie os jogadores</p>
                    ${rows}
                    <p class="mm-hint">O monstrinho inicial deve seguir a classe do jogador (MVP).</p>
                `;
                return;
            }

            // Step 3: confirm
            if (MM_NEW.step === 3) {
                host.innerHTML = `
                    <p class="mm-sub">Tudo pronto!</p>
                    <div class="opacity-90 line-height-145">
                        <div><b>Jogadores:</b> ${MM_NEW.numPlayers}</div>
                        <div><b>Dificuldade:</b> ${escapeHtml(MM_NEW.difficulty)}</div>
                        <div class="mt-8">
                            ${MM_NEW.players.map(p => `‚Ä¢ ${escapeHtml(p.name || "Sem nome")} ‚Äî ${escapeHtml(p.class)}`).join("<br/>")}
                        </div>
                    </div>
                    <button class="mm-btn" onclick="mmFinishNewGame()">üöÄ Come√ßar Aventura</button>
                    <p class="mm-hint">Isso criar√° uma nova sess√£o e sobrescrever√° o save atual.</p>
                `;
            }
        }

        function mmNewGameBack(){
            if (MM_NEW.step === 0) { mmShowMainMenu(); return; }
            MM_NEW.step = Math.max(0, MM_NEW.step - 1);
            mmRenderNewGameStep();
        }

        function mmNewGameNext(){
            // capturar inputs do step atual
            if (MM_NEW.step === 0) {
                const n = Number(mmEl("mmNumPlayers")?.value || 1);
                MM_NEW.numPlayers = Math.max(1, Math.min(6, n));
            }
            if (MM_NEW.step === 1) {
                MM_NEW.difficulty = String(mmEl("mmDifficulty")?.value || "medium");
            }
            if (MM_NEW.step === 2) {
                for (let i=0;i<MM_NEW.players.length;i++){
                    const name = String(mmEl(`mmPName_${i}`)?.value || "").trim();
                    const cls = String(mmEl(`mmPClass_${i}`)?.value || MM_CLASSES[0]);
                    MM_NEW.players[i] = { name, class: cls };
                }
            }

            MM_NEW.step = Math.min(3, MM_NEW.step + 1);
            mmRenderNewGameStep();
        }

        function mmFinishNewGame(){
            try {
                // valida nomes (MVP: auto-preenche)
                MM_NEW.players = MM_NEW.players.map((p, idx) => ({
                    name: p.name?.trim() ? p.name.trim() : `Jogador ${idx+1}`,
                    class: p.class || MM_CLASSES[0]
                }));

                // Clear existing state
                GameState.players = [];
                GameState.monsters = [];
                GameState.sessions = [];
                GameState.currentSession = null;
                GameState.currentEncounter = null;

                // Create players
                MM_NEW.players.forEach((p, idx) => {
                    const playerId = `p_${Date.now()}_${idx}`;
                    
                    // Find a starter monster of the same class
                    const starterTemplate = MONSTER_CATALOG.find(m => 
                        m.class && p.class && m.class.toLowerCase() === p.class.toLowerCase()
                    ) || MONSTER_CATALOG[0]; // Fallback to first monster if no match
                    
                    // Create player first (Award API needs player object)
                    // Recursos iniciais: mesmos valores que addPlayer() para consist√™ncia
                    const player = {
                        id: playerId,
                        name: p.name,
                        class: p.class,
                        money: 100,
                        afterlifeCurrency: 0,
                        team: [],
                        box: [],
                        inventory: {
                            'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                            'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                            'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                            'IT_HEAL_01': 3           // Petisco de Cura x3
                        }
                    };
                    
                    GameState.players.push(player);
                    
                    // COMMIT 8 (Wave A): Use Award API for canonical monster creation
                    const starterMonster = awardMonster(
                        starterTemplate.id,  // templateId
                        1,                   // level
                        null,                // rarity (use template default)
                        'party',             // destination
                        player               // player object
                    );
                    
                    if (!starterMonster) {
                        console.error('Failed to award starter monster to new player:', p.name);
                    }
                });

                // Save difficulty
                if (!GameState.config) GameState.config = {};
                GameState.config.difficulty = MM_NEW.difficulty;

                // Save to localStorage
                saveToLocalStorage();
                
                // Feature 4.3: Also save to chosen slot if specified
                if (GameState.saveSlot) {
                    const envelope = mmBuildSaveEnvelope();
                    const key = MM_SAVE_KEYS[GameState.saveSlot];
                    if (key) {
                        try {
                            // PR3: Save via StorageManager with auto-backup
                            StorageManager.saveSlot(GameState.saveSlot, envelope);
                        } catch (e) {
                            console.error("Failed to save to slot", e);
                            alert(`‚ö†Ô∏è Jogo criado, mas falhou ao salvar no Slot ${GameState.saveSlot}`);
                        }
                    }
                }
                
                // Update UI
                updateAllViews();
                
            } catch(e) {
                console.error("mmFinishNewGame failed", e);
                alert("Erro ao criar novo jogo: " + e.message);
                mmCloseAllOverlays();
                return;
            }

            // Feature 4.1.1: Show tutorial choice instead of going directly to game
            mmPostGameStartFlow();
        }

        // ===== Feature 4.3: Save Slots + Export/Import =====
        const MM_SAVE_KEYS = {
            1: "mm_save_slot_1",
            2: "mm_save_slot_2",
            3: "mm_save_slot_3",
        };
        const MM_LEGACY_KEYS = [
            "monstrinhomon_state", "mm_save", "GameState", "mm_state"
        ];
        const MM_MIGRATED_FLAG = "mm_slots_migrated_v1";

        function mmOpenSaves() {
            mmMigrateLegacySaveToSlot1();
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSavesScreen");
            mmRenderSavesScreen();
            
            // Bind import file input once
            const fileInput = document.getElementById("mmImportFile");
            if (fileInput && !fileInput._bound) {
                fileInput._bound = true;
                fileInput.addEventListener("change", (e) => mmHandleImportFile(e));
            }
        }

        function mmCloseSaves() {
            mmHideOverlay("mmSavesScreen");
            mmShowMainMenu();
        }

        function mmShowOverlay(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove("is-hidden");
                el.classList.add("show");
            }
        }

        function mmHideOverlay(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.add("is-hidden");
                el.classList.remove("show");
            }
        }

        function mmReadSlot(slot) {
            // PR3: Load via StorageManager
            const result = StorageManager.loadSlot(slot);
            return result.loaded ? result.data : null;
        }

        function mmWriteSlot(slot, saveObj) {
            // PR3: Save via StorageManager with auto-backup
            return StorageManager.saveSlot(slot, saveObj);
        }

        function mmBuildSaveEnvelope() {
            // Create snapshot of current state
            try {
                const payload = {
                    version: "mm_slot_v1",
                    timestamp: Date.now(),
                    sessionName: GameState?.currentSession?.name || "Sess√£o",
                    playersCount: Array.isArray(GameState?.players) ? GameState.players.length : 0,
                    state: JSON.parse(JSON.stringify(GameState)) // Deep copy (requires serializable state)
                };
                return payload;
            } catch (e) {
                console.error("Failed to create save envelope (state may have non-serializable values)", e);
                throw new Error("Falha ao criar envelope de save");
            }
        }

        function mmSaveToSlot(slot) {
            if (!confirm(`Salvar o jogo atual no Slot ${slot}? Isso vai sobrescrever.`)) return;
            const env = mmBuildSaveEnvelope();
            if (mmWriteSlot(slot, env)) {
                showToast(`üíæ Salvo no Slot ${slot}!`);
                mmRenderSavesScreen();
            } else {
                alert("Falha ao salvar no slot.");
            }
        }

        function mmLoadFromSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env || !env.state) {
                alert("Slot vazio ou inv√°lido.");
                return;
            }
            if (!confirm(`Carregar Slot ${slot}? Isso substitui o estado atual.`)) return;
            
            try {
                // Update GameState properties instead of reassigning
                Object.assign(GameState, env.state);
                
                // Update slot tracking
                GameState.saveSlot = slot;
                StorageManager.setLastSlot(slot); // PR3
                
                saveToLocalStorage();  // Update the main save too
                
                // Update all views
                if (typeof updateAllViews === "function") updateAllViews();
                if (typeof renderEncounter === "function") renderEncounter();
                
                showToast(`üìÇ Carregado do Slot ${slot}!`);
                mmCloseSaves();
                
                // Feature 4.1.1: Show tutorial choice or go to game based on preference
                mmPostGameStartFlow();
            } catch (e) {
                console.error("Failed to load from slot", e);
                alert("Erro ao carregar o slot.");
            }
        }

        function mmDeleteSlot(slot) {
            if (!confirm(`Apagar Slot ${slot}? Esta a√ß√£o n√£o pode ser desfeita.`)) return;
            StorageManager.deleteSlot(slot); // PR3
            showToast(`üóëÔ∏è Slot ${slot} apagado.`);
            mmRenderSavesScreen();
        }

        function mmExportSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env) { 
                alert("Slot vazio."); 
                return; 
            }
            
            try {
                const blob = new Blob([JSON.stringify(env, null, 2)], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `monstrinhomon_slot_${slot}_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(a.href); // Free memory
                showToast(`‚¨áÔ∏è Exportado Slot ${slot}.`);
            } catch (e) {
                console.error("Failed to export slot", e);
                alert("Erro ao exportar o slot.");
            }
        }

        function mmHandleImportFile(e) {
            const fileInput = e.target;
            const file = fileInput.files?.[0];
            if (!file) return;

            const slotPick = document.getElementById("mmImportSlotPick");
            const slot = Number(slotPick?.value || 1);

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const obj = JSON.parse(String(reader.result || ""));
                    if (!obj || !obj.state) {
                        throw new Error("JSON inv√°lido (sem state).");
                    }
                    
                    // Basic validation of state structure
                    if (typeof obj.state !== 'object') {
                        throw new Error("State inv√°lido.");
                    }
                    
                    if (mmWriteSlot(slot, obj)) {
                        showToast(`‚¨ÜÔ∏è Importado para Slot ${slot}!`);
                        mmRenderSavesScreen();
                    } else {
                        throw new Error("Falha ao gravar no slot.");
                    }
                } catch (err) {
                    console.error("Import failed", err);
                    const msg = err?.message || "Arquivo inv√°lido ou corrompido";
                    alert("Falha ao importar: " + msg);
                } finally {
                    fileInput.value = ""; // Allow re-import of same file
                }
            };
            reader.readAsText(file);
        }

        function mmRenderSavesScreen() {
            const host = document.getElementById("mmSavesSlots");
            if (!host) return;

            const slotHtml = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>Sess√£o:</b> ${escapeHtml(env.sessionName || "Sess√£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot">
                        <h3>Slot ${slot}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn w-auto" ${empty ? "disabled" : ""} onclick="mmLoadFromSlot(${slot})">üìÇ Carregar</button>
                            <button class="mm-btn w-auto" onclick="mmSaveToSlot(${slot})">üíæ Salvar aqui</button>
                            <button class="mm-btn w-auto" ${empty ? "disabled" : ""} onclick="mmExportSlot(${slot})">‚¨áÔ∏è Exportar</button>
                            <button class="mm-btn w-auto" ${empty ? "disabled" : ""} onclick="mmDeleteSlot(${slot})">üóëÔ∏è Apagar</button>
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = slotHtml;
        }

        // Slot Picker functions for New Game flow
        function mmGetLastSlot() {
            // PR3: Use StorageManager
            const slot = StorageManager.getLastSlot();
            return slot !== null ? slot : 1;
        }

        function mmOpenSlotPickerForNewGame() {
            mmMigrateLegacySaveToSlot1(); // Ensure migration happens first
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSlotPicker");
            mmRenderSlotPicker();
        }

        function mmCancelSlotPicker() {
            mmHideOverlay("mmSlotPicker");
            mmShowMainMenu();
        }

        function mmRenderSlotPicker() {
            const host = document.getElementById("mmSlotPickerList");
            if (!host) return;

            const last = mmGetLastSlot();
            const cards = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>Sess√£o:</b> ${escapeHtml(env.sessionName || "Sess√£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot ${slot === last ? "slot-outline" : ""}">
                        <h3 class="my-0 mb-6">Slot ${slot} ${slot === last ? "‚≠ê" : ""}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn w-auto"
                                onclick="mmChooseSlotAndStartNewGame(${slot})">
                                ${empty ? "‚úÖ Usar este slot" : "‚úÖ Usar (sobrescrever)"}
                            </button>
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = cards;
        }

        function mmChooseSlotAndStartNewGame(slot, force = false) {
            const env = mmReadSlot(slot);
            const occupied = !!(env && env.state);

            if (occupied && !force) {
                const ok = confirm(`Slot ${slot} j√° tem um save. Sobrescrever?`);
                if (!ok) return;
            }

            // Store chosen slot
            if (!window.GameState) window.GameState = {};
            GameState.saveSlot = slot;
            StorageManager.setLastSlot(slot); // PR3

            mmHideOverlay("mmSlotPicker");
            // Call existing wizard from Feature 4.0
            mmStartNewGame();
        }

        function mmMigrateLegacySaveToSlot1() {
            // PR3: Use StorageManager for migration flag
            if (StorageManager.isSlotsMigrated()) return;

            const slot1 = mmReadSlot(1);
            if (slot1 && slot1.state) {
                // Slot 1 already has data, mark as migrated
                StorageManager.markSlotsMigrated();
                return;
            }

            // Try to find legacy save
            for (const key of MM_LEGACY_KEYS) {
                const raw = StorageManager.loadJSON(key, null); // PR3
                if (!raw) continue;

                try {
                    const parsed = raw;
                    
                    // Check if it's already an envelope or raw GameState
                    const env = (parsed && parsed.state) ? parsed : {
                        version: "mm_slot_v1",
                        timestamp: Date.now(),
                        sessionName: parsed?.currentSession?.name || "Sess√£o",
                        playersCount: Array.isArray(parsed?.players) ? parsed.players.length : 0,
                        state: parsed
                    };
                    
                    if (mmWriteSlot(1, env)) {
                        showToast("‚úÖ Save antigo migrado para Slot 1!");
                        break;
                    }
                } catch (e) {
                    console.warn("Failed to migrate legacy save from key:", key, e);
                    // Continue to next key
                }
            }

            StorageManager.markSlotsMigrated();
        }

        // ===== Feature 4.2: Tutorial (Optional) =====
        const TUTORIAL_STEPS = [
            {
                id: "tut_attack",
                title: "Tutorial 1/3 ‚Äî Ataque b√°sico",
                instructions: "Clique em ATACAR 2 vezes para vencer.",
                required: { attack: 2 },
                lock: { attack:true, skill:false, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Attack()
            },
            {
                id: "tut_skill",
                title: "Tutorial 2/3 ‚Äî Habilidades",
                instructions: "Use 1 habilidade (gasta ENE) para vencer.",
                required: { skill: 1 },
                lock: { attack:true, skill:true, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Skill()
            },
            {
                id: "tut_capture",
                title: "Tutorial 3/3 ‚Äî Captura",
                instructions: "Abaixe o HP do inimigo at√© ficar baixo e capture com ClasterOrb.",
                required: { capture: 1 },
                lock: { attack:true, skill:true, item:false, capture:true, flee:false, pass:false },
                start: () => startTutorialEncounter_Capture()
            }
        ];

        function ensureTutorialState() {
            if (!window.GameState) window.GameState = {};
            if (!GameState.tutorial) GameState.tutorial = { active:false, stepIndex:0, done:{} };
            if (!GameState.tutorial.done) GameState.tutorial.done = {};
            return GameState.tutorial;
        }

        function getTutorialStep() {
            const tut = ensureTutorialState();
            if (!tut.active) return null;
            return TUTORIAL_STEPS[tut.stepIndex] || null;
        }

        function mmStartTutorial() {
            const tut = ensureTutorialState();
            
            // Se n√£o h√° jogadores, precisa criar um jogo primeiro
            if (!GameState.players || GameState.players.length === 0) {
                alert("Por favor, crie um novo jogo primeiro!");
                return;
            }
            
            const restart = !tut.active ? true : confirm("Continuar tutorial atual? (OK = continuar / Cancelar = reiniciar)");
            if (!restart) {
                tut.active = false;
                tut.stepIndex = 0;
                tut.done = {};
            }
            tut.active = true;
            
            // Inicia step atual
            const step = TUTORIAL_STEPS[tut.stepIndex] || TUTORIAL_STEPS[0];
            mmCloseAllOverlays();
            step.start();
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
        }

        function exitTutorial() {
            const tut = ensureTutorialState();
            tut.active = false;
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            showToast("üëã Tutorial encerrado!");
        }

        function renderTutorialBanner(enc) {
            const step = getTutorialStep();
            if (!step) return "";
            const tut = ensureTutorialState();
            const done = tut.done || {};
            const req = step.required || {};
            const lines = Object.keys(req).map(k => {
                const v = req[k];
                const cur = done[k] || 0;
                return `‚Ä¢ ${k}: ${cur}/${v}`;
            }).join("<br/>");

            return `
                <div class="tutorial-step-box">
                    <div class="tutorial-step-header">
                        <div class="tutorial-step-title">üéì ${step.title}</div>
                        <button class="btn w-auto m-0 py-8 px-10" onclick="exitTutorial()">Sair</button>
                    </div>
                    <div class="opacity-90 mt-6">${step.instructions}</div>
                    <div class="opacity-80 mt-6 font-size-12">${lines}</div>
                </div>
            `;
        }

        function tutorialAllows(actionKey) {
            const step = getTutorialStep();
            if (!step) return true;
            const lock = step.lock || {};
            // Se n√£o definido, permite
            if (typeof lock[actionKey] === "undefined") return true;
            return !!lock[actionKey];
        }

        function tutorialOnAction(type) {
            const step = getTutorialStep();
            if (!step) return;

            const tut = ensureTutorialState();
            tut.done[type] = (tut.done[type] || 0) + 1;

            // Checa se completou
            const req = step.required || {};
            const ok = Object.keys(req).every(k => (tut.done[k] || 0) >= req[k]);

            if (ok) {
                showToast("üéâ Passo conclu√≠do!");
                
                // Se √© o √∫ltimo step
                if (tut.stepIndex === TUTORIAL_STEPS.length - 1) {
                    tut.active = false;
                    showToast("üèÅ Tutorial completo!");
                    if (typeof saveToLocalStorage === "function") saveToLocalStorage();
                    return;
                }
                
                // Avan√ßa para pr√≥ximo step
                tut.stepIndex = Math.min(TUTORIAL_STEPS.length - 1, tut.stepIndex + 1);
                tut.done = {}; // Reseta contadores do pr√≥ximo step

                const next = getTutorialStep();
                if (next) {
                    setTimeout(() => {
                        next.start();
                    }, 1500); // Pequeno delay para o usu√°rio ver a mensagem
                }
            }

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
        }

        function createTutorialEnemy(level) {
            // Tenta pegar um template real do cat√°logo
            const cat = MONSTER_CATALOG || [];
            const t = cat[0];
            if (typeof createMonsterInstanceFromTemplate === "function" && t) {
                // Wave B (continuation): Use factory for tutorial enemy
                const m = createMonsterInstanceFromTemplate(t.id, level, null, {
                    id: 'tutorial_' + Date.now()
                });
                // Deixa mais f√°cil
                m.hpMax = Math.max(20, Math.floor(m.hpMax * 0.6));
                m.hp = m.hpMax;
                return m;
            }
            // Fallback m√≠nimo
            return { 
                id: Date.now() + Math.random(),
                name:"Treinomon", 
                level, 
                hpMax: 25+level*5, 
                hp: 25+level*5, 
                atk: 4+level, 
                def: 3+level, 
                spd: 5, 
                ene: 0, 
                eneMax: 0,
                class: "Guerreiro",
                rarity: "Comum",
                emoji: "üêæ",
                poder: 6
            };
        }

        function startTutorialEncounter_Attack() {
            const player = GameState.players?.[0];
            if (!player) {
                alert("Nenhum jogador dispon√≠vel para o tutorial!");
                return;
            }
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(1),
                log: ["üéì Tutorial: Encontro de Ataque", "Ataque 2 vezes para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Skill() {
            const player = GameState.players?.[0];
            if (!player) return;
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(2),
                log: ["üéì Tutorial: Encontro de Habilidades", "Use 1 habilidade para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Capture() {
            const player = GameState.players?.[0];
            if (!player) return;

            // Garante 1 orb no invent√°rio (para n√£o travar tutorial)
            player.inventory = player.inventory || {};
            const orbId = "CLASTERORB_COMUM";
            player.inventory[orbId] = Math.max(1, Number(player.inventory[orbId] || 0));

            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(3),
                log: ["üéì Tutorial: Encontro de Captura", "Abaixe o HP e capture o monstrinho!"],
                rewardsGranted: false,
                active: true
            };

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        // ===== Feature 4.1.1: Start Choice (Tutorial Selection) =====
        
        function mmGetSlotTutorialPref(slotNum){
            // PR3: Use StorageManager
            return StorageManager.getTutorialPrefSlot(slotNum);
        }

        function mmSetSlotTutorialPref(slotNum, pref){
            // PR3: Use StorageManager
            StorageManager.setTutorialPrefSlot(slotNum, pref);
        }

        // Helper to get the active slot from multiple possible sources
        function mmGetActiveSlot(){
            return (
                GameState?.ui?.activeSlot ??
                GameState?.activeSaveSlot ??
                GameState?.saveSlot ??
                GameState?.currentSaveSlot ??
                StorageManager.getLastSlot() ?? // PR3
                null
            );
        }

        // Decide what to do after loading/creating a game
        function mmPostGameStartFlow(){
            const slot = mmGetActiveSlot();

            // 1) Slot-specific preference
            const slotPref = slot ? mmGetSlotTutorialPref(slot) : null;
            if (slotPref === "always") return mmStartTutorial();
            if (slotPref === "never")  return mmEnterGameUI();

            // 2) Optional global fallback
            const globalPref = StorageManager.getTutorialPrefGlobal(); // PR3
            if (globalPref === "always") return mmStartTutorial();
            if (globalPref === "never")  return mmEnterGameUI();

            // 3) Default: ask
            return mmShowStartChoiceOverlay(true);
        }

        function mmShowStartChoiceOverlay(show){
            const el = document.getElementById("mmStartChoice");
            if (!el) return;
            if (show) {
                el.classList.add("show");
                el.classList.remove("is-hidden");
            } else {
                el.classList.remove("show");
                el.classList.add("is-hidden");
            }
        }

        function mmStartTutorialFromChoice(){
            mmPersistTutorialChoice("always");
            mmShowStartChoiceOverlay(false);
            mmStartTutorial();
        }

        function mmSkipTutorialFromChoice(){
            mmPersistTutorialChoice("never");
            mmShowStartChoiceOverlay(false);
            mmEnterGameUI();
        }

        function mmPersistTutorialChoice(pref){
            const remember = !!document.getElementById("mmRememberTutorialChoice")?.checked;
            if (!remember) return;

            const slot = mmGetActiveSlot();
            if (slot) {
                mmSetSlotTutorialPref(slot, pref);
                return;
            }
            // PR3: fallback to global via StorageManager
            StorageManager.setTutorialPrefGlobal(pref);
        }

        // Make sure this brings user to the normal tabs/game screen
        function mmEnterGameUI(){
            mmCloseAllOverlays();
            if (typeof updateAllViews === "function") updateAllViews();
            if (typeof renderEncounter === "function") renderEncounter();
        }

        // ===== EXPOSE FUNCTIONS TO GLOBAL SCOPE FOR ONCLICK HANDLERS =====
        // When using type="module", functions are scoped to the module.
        // We need to expose them to window for inline onclick handlers to work.
        window.dismissError = dismissError;
        window.copyError = copyError;
        window.mmShowMainMenu = mmShowMainMenu;
        window.switchTab = switchTab;
        window.createSession = createSession;
        window.nextTurn = nextTurn;
        window.endSession = endSession;
        window.addPlayer = addPlayer;
        window.buyItem = buyItem;
        window.startEncounter = startEncounter;
        window.addObjective = addObjective;
        window.clearTherapistLog = clearTherapistLog;
        window.therapistExportSave = therapistExportSave;
        window.therapistImportSave = therapistImportSave;
        window.therapistLoadJson = therapistLoadJson;
        window.therapistCancelImport = therapistCancelImport;
        window.exportData = exportData;
        window.importData = importData;
        window.clearAllData = clearAllData;
        window.attackWild = attackWild;
        window.useSkillWild = useSkillWild;
        window.mmEnterGameUI = mmEnterGameUI;
        window.mmCloseAllOverlays = mmCloseAllOverlays;
        window.mmOpenSlotPickerForNewGame = mmOpenSlotPickerForNewGame;
        window.mmChooseSlotAndStartNewGame = mmChooseSlotAndStartNewGame;
        window.mmCancelSlotPicker = mmCancelSlotPicker;
        window.mmNewGameBack = mmNewGameBack;
        window.mmNewGameNext = mmNewGameNext;
        window.mmFinishNewGame = mmFinishNewGame;
        window.mmSkipTutorialFromChoice = mmSkipTutorialFromChoice;
        window.mmStartTutorialFromChoice = mmStartTutorialFromChoice;
        window.mmStartTutorial = mmStartTutorial;
        window.mmOpenSaves = mmOpenSaves;
        window.mmCloseSaves = mmCloseSaves;
        window.mmSaveToSlot = mmSaveToSlot;
        window.hatchEggFromInventory = hatchEggFromInventory; // PR14B: Egg hatching modal
        window.renderPartyDexTab = renderPartyDexTab; // PR16B: PartyDex UI
        window.mmLoadFromSlot = mmLoadFromSlot;
        window.mmDeleteSlot = mmDeleteSlot;
        window.mmExportSlot = mmExportSlot;
        window.mmResetSaveConfirm = mmResetSaveConfirm;
        window.mmContinue = mmContinue;
        window.mmShowConfig = mmShowConfig;
        window.mmOpenTherapistPanel = mmOpenTherapistPanel;
        window.mmTherGiveMonster = mmTherGiveMonster;
        window.mmTherGiveItem = mmTherGiveItem;
        window.mmTherGiveXP = mmTherGiveXP;
        window.mmTherGiveXPQuick = mmTherGiveXPQuick;
        window.toggleTherapistMode = toggleTherapistMode;
        window.Audio = Audio;

        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            init(); // Call the existing init function
            mmBoot(); // Show the intro overlay
        });
    </script>
    <div id="mmToastHost"></div>
</body>
</html>
