<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Monstrinhomon - Therapeutic Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --fire-color: #ff6b35; --water-color: #4ecdc4; --plant-color: #95e06c; --electric-color: #ffe66d;
            --primary: #6c5ce7; --secondary: #fd79a8; --success: #00b894; --warning: #fdcb6e;
            --danger: #d63031; --dark: #2d3436; --light: #dfe6e9;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--dark); min-height: 100vh; overflow-x: hidden;
        }
        
        .app-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .error-panel {
            position: fixed; top: 0; left: 0; right: 0; background: #d63031; color: white;
            padding: 15px; z-index: 10000; display: none; font-family: monospace; font-size: 14px;
        }
        .error-panel.show { display: block; }
        .error-panel button {
            background: white; color: #d63031; border: none; padding: 8px 15px; margin: 5px;
            border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;
        }
        
        .header {
            background: white; border-radius: 20px; padding: 20px; margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header h1 { color: var(--primary); font-size: 2.5em; text-align: center; margin-bottom: 10px; }
        
        .tabs {
            display: flex; gap: 10px; overflow-x: auto; padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab-button {
            background: var(--light); border: none; padding: 15px 25px; border-radius: 15px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;
            white-space: nowrap; min-width: 100px; min-height: 44px;
        }
        .tab-button.active {
            background: var(--primary); color: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }
        
        .tab-content {
            display: none; background: white; border-radius: 20px; padding: 25px;
            min-height: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tab-content.active { display: block; animation: fadeIn 0.3s; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .btn {
            background: var(--primary); color: white; border: none; padding: 15px 30px;
            border-radius: 12px; font-size: 16px; font-weight: bold; cursor: pointer;
            transition: all 0.3s; min-height: 44px; min-width: 44px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-success { background: var(--success); }
        .btn-danger { background: var(--danger); }
        .btn-warning { background: var(--warning); color: var(--dark); }
        .btn-secondary { background: var(--secondary); }
        .btn-large { font-size: 20px; padding: 20px 40px; }
        
        input, select, textarea {
            width: 100%; padding: 12px; border: 2px solid var(--light); border-radius: 10px;
            font-size: 16px; margin: 8px 0; min-height: 44px;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        
        .card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px; padding: 20px; margin: 15px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .monster-card {
            display: inline-block; width: 150px; margin: 10px; padding: 15px;
            border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .monster-card:active { transform: scale(0.95); }
        .monster-card.fire { background: linear-gradient(135deg, #ff6b35 0%, #ff8c61 100%); }
        .monster-card.water { background: linear-gradient(135deg, #4ecdc4 0%, #7ee0d7 100%); }
        .monster-card.plant { background: linear-gradient(135deg, #95e06c 0%, #b3eb93 100%); }
        .monster-card.electric { background: linear-gradient(135deg, #ffe66d 0%, #fff09c 100%); }
        
        .progress-bar {
            width: 100%; height: 30px; background: var(--light); border-radius: 15px;
            overflow: hidden; position: relative; margin: 10px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--success) 0%, #00b894 100%);
            transition: width 0.5s; display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px;
        }
        .progress-fill.hp { background: linear-gradient(90deg, #d63031 0%, #ff7675 100%); }
        .progress-fill.xp { background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%); }
        
        .badge {
            display: inline-block; padding: 5px 12px; border-radius: 20px;
            font-size: 12px; font-weight: bold; margin: 2px;
        }
        .badge-common { background: #95a5a6; color: white; }
        .badge-rare { background: #3498db; color: white; }
        .badge-epic { background: #9b59b6; color: white; }
        .badge-legendary { background: #f39c12; color: white; }
        .badge-fire { background: var(--fire-color); color: white; }
        .badge-water { background: var(--water-color); color: white; }
        .badge-plant { background: var(--plant-color); color: white; }
        .badge-electric { background: var(--electric-color); color: var(--dark); }
        
        .encounter-panel {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-radius: 20px; padding: 25px; margin: 20px 0;
        }
        
        .combat-log {
            background: white; border-radius: 15px; padding: 15px; max-height: 300px;
            overflow-y: auto; font-family: monospace; font-size: 14px;
        }
        .combat-log div { padding: 5px 0; border-bottom: 1px solid var(--light); }
        
        .therapist-panel {
            border: 3px dashed var(--warning); border-radius: 20px; padding: 20px;
            margin: 20px 0; background: #fffbea;
        }
        
        .objective-item {
            display: flex; align-items: center; gap: 10px; padding: 15px;
            background: white; border-radius: 10px; margin: 10px 0;
        }
        
        .medal { font-size: 48px; display: inline-block; margin: 10px; }
        .hidden { display: none !important; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex-center { display: flex; justify-content: center; align-items: center; gap: 15px; }
        
        .stat-box {
            display: inline-block; padding: 10px 20px; background: var(--light);
            border-radius: 10px; margin: 5px; font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8em; }
            .tab-button { padding: 12px 20px; font-size: 14px; }
        }
        
        /* ===== Feature 4.0: Menu / Overlays ===== */
        .mm-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 30% 20%, rgba(120,80,255,0.25), transparent 45%),
                        radial-gradient(circle at 70% 70%, rgba(0,200,255,0.18), transparent 45%),
                        rgba(10,10,14,0.92);
            color: #fff;
            z-index: 9999;
            display: none;
        }

        .mm-overlay.show { display: flex; }

        .mm-overlay .mm-card {
            width: min(560px, calc(100vw - 24px));
            margin: auto;
            background: rgba(20,20,28,0.85);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.45);
        }

        .mm-title { font-size: 28px; font-weight: 900; margin: 6px 0 8px; }
        .mm-sub { opacity: 0.9; margin: 0 0 14px; line-height: 1.3; }

        .mm-btn {
            width: 100%;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-weight: 800;
            font-size: 16px;
            cursor: pointer;
            margin: 8px 0;
            min-height: 44px;
        }
        .mm-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .mm-row { display: flex; gap: 10px; }
        .mm-row .mm-btn { width: auto; flex: 1; }

        .mm-field { margin: 10px 0; }
        .mm-field label { display:block; font-size: 13px; opacity: 0.9; margin-bottom: 6px; }
        .mm-field input, .mm-field select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.25);
            color: #fff;
            outline: none;
        }

        .mm-hint { font-size: 12px; opacity: 0.75; margin-top: 6px; }
        
        /* Toast notifications */
        .mm-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10001;
            transform: translateX(400px);
            transition: transform 0.3s ease-out;
        }
        
        .mm-toast.show {
            transform: translateX(0);
        }
        
        /* Feature 4.3: Save Slots */
        .mm-overlay.hidden { 
            display: none; 
        }
        
        .mm-input { 
            border-radius:10px; 
            padding:10px 12px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.08); 
            color:#fff; 
        }
        
        .mm-slot { 
            border-radius:14px; 
            padding:14px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.06); 
        }
        
        .mm-slot h3 { 
            margin:0 0 8px 0; 
            font-size:18px;
        }
        
        .mm-slot-meta { 
            opacity:0.85; 
            font-size:13px; 
            line-height:1.4; 
        }
        
        .mm-slot-meta > div {
            margin:3px 0;
        }
        
        .mm-slot-actions { 
            display:flex; 
            gap:8px; 
            flex-wrap:wrap; 
            margin-top:12px; 
        }
    </style>
</head>
<body>
    <div id="errorPanel" class="error-panel">
        <div id="errorMessage"></div>
        <button onclick="copyError()">ğŸ“‹ Copy Error</button>
        <button onclick="dismissError()">âœ– Dismiss</button>
    </div>

    <div class="app-container">
        <div class="header">
            <h1>ğŸ® Monstrinhomon ğŸŒŸ</h1>
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">ğŸ  Home</button>
                <button class="tab-button" onclick="switchTab('session')">ğŸ“‹ Session</button>
                <button class="tab-button" onclick="switchTab('players')">ğŸ‘¥ Players</button>
                <button class="tab-button" onclick="switchTab('encounter')">âš”ï¸ Encounter</button>
                <button class="tab-button" onclick="switchTab('therapy')">ğŸ¯ Therapy</button>
                <button class="tab-button" onclick="switchTab('report')">ğŸ“Š Report</button>
                <button class="tab-button" onclick="switchTab('settings')">âš™ï¸ Settings</button>
            </div>
        </div>

        <div id="tabHome" class="tab-content active">
            <h2>Welcome to Monstrinhomon! ğŸ‰</h2>
            <p style="font-size: 18px; margin: 20px 0;">A therapeutic game for young trainers.</p>
            
            <div class="card">
                <h3>Quick Stats</h3>
                <div id="homeStats">
                    <div class="stat-box">Active Players: <span id="statPlayers">0</span></div>
                    <div class="stat-box">Total Monsters: <span id="statMonsters">0</span></div>
                    <div class="stat-box">Session Active: <span id="statSession">No</span></div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div class="flex">
                    <button class="btn btn-large btn-success" onclick="switchTab('session')">Start New Session</button>
                    <button class="btn btn-large" onclick="switchTab('players')">Manage Players</button>
                    <button class="btn btn-large btn-secondary" onclick="switchTab('encounter')">Start Encounter</button>
                </div>
            </div>
        </div>

        <div id="tabSession" class="tab-content">
            <h2>Session Management ğŸ“‹</h2>
            
            <div class="card">
                <h3>Create New Session</h3>
                <input type="text" id="sessionName" placeholder="Session Name (e.g., Therapy Session 2024-01-15)">
                <button class="btn btn-success" onclick="createSession()">Create Session</button>
            </div>

            <div id="activeSessionPanel" class="card hidden">
                <h3>Active Session: <span id="activeSessionName"></span></h3>
                <p>Created: <span id="sessionCreated"></span></p>
                
                <h4>Turn Order</h4>
                <div id="turnOrderList"></div>
                
                <button class="btn btn-warning" onclick="nextTurn()">Next Turn â–¶</button>
                <button class="btn btn-danger" onclick="endSession()">End Session</button>
            </div>
        </div>

        <div id="tabPlayers" class="tab-content">
            <h2>Player Management ğŸ‘¥</h2>
            
            <div class="card">
                <h3>Add New Player</h3>
                <input type="text" id="playerName" placeholder="Player Name">
                <select id="playerClass">
                    <option value="">Select Class</option>
                    <option value="Guerreiro">âš”ï¸ Guerreiro</option>
                    <option value="Mago">ğŸ”® Mago</option>
                    <option value="Curandeiro">ğŸ’š Curandeiro</option>
                    <option value="BÃ¡rbaro">ğŸ’ª BÃ¡rbaro</option>
                    <option value="Ladino">ğŸ—¡ï¸ Ladino</option>
                    <option value="Bardo">ğŸµ Bardo</option>
                    <option value="CaÃ§ador">ğŸ¹ CaÃ§ador</option>
                    <option value="Animalista">ğŸ¾ Animalista</option>
                </select>
                <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
            </div>

            <div id="playersList"></div>
        </div>

        <div id="tabEncounter" class="tab-content">
            <h2>Encounter âš”ï¸</h2>
            
            <div class="card">
                <h3>Start New Encounter</h3>
                <select id="encounterType" onchange="updateEncounterUI()">
                    <option value="wild">ğŸŒŸ Wild Monster (Individual Capture)</option>
                    <option value="trainer">ğŸ‘¤ Trainer Battle (Group)</option>
                    <option value="boss">ğŸ‘¹ Boss Battle (Group)</option>
                    <option value="event">ğŸ“– Narrative Event</option>
                </select>
                
                <!-- Para encontros individuais (wild) -->
                <div id="playerSelectDiv" style="margin-top: 15px;">
                    <label><strong>Select Player for Individual Encounter:</strong></label>
                    <select id="encounterPlayer">
                        <option value="">-- Select Player --</option>
                    </select>
                </div>
                
                <!-- Para encontros em grupo (trainer/boss) -->
                <div id="groupSelectDiv" class="hidden" style="margin-top: 15px;">
                    <label><strong>Select Participants (1-6):</strong></label>
                    <div id="groupParticipantsList" style="margin-top: 10px;"></div>
                    <div style="margin-top: 10px;">
                        <label><strong>Enemy Level:</strong></label>
                        <select id="enemyLevel">
                            <option value="1">1</option>
                            <option value="3">3</option>
                            <option value="5" selected>5</option>
                            <option value="7">7</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="startEncounter()">Start Encounter</button>
            </div>

            <div id="encounterPanel" class="hidden"></div>
        </div>

        <div id="tabTherapy" class="tab-content">
            <h2>Therapeutic Objectives ğŸ¯</h2>
            
            <div class="therapist-panel">
                <h3>âš•ï¸ Therapist Controls</h3>
                
                <div class="card">
                    <h4>Add Objective</h4>
                    <input type="text" id="newObjective" placeholder="Objective description">
                    <select id="objectiveWeight">
                        <option value="1">Low Weight (1)</option>
                        <option value="2">Medium Weight (2)</option>
                        <option value="3">High Weight (3)</option>
                    </select>
                    <button class="btn btn-success" onclick="addObjective()">Add Objective</button>
                </div>

                <div id="objectivesList"></div>
            </div>

            <div id="therapyPlayersList"></div>
        </div>

        <div id="tabReport" class="tab-content">
            <h2>Session Report ğŸ“Š</h2>
            <div id="reportContent"></div>
        </div>

        <div id="tabSettings" class="tab-content">
            <h2>Settings âš™ï¸</h2>
            
            <div class="card">
                <h3>Game Configuration</h3>
                <label>
                    <input type="checkbox" id="therapistMode" onchange="toggleTherapistMode()">
                    Therapist Mode (Show advanced controls)
                </label>
            </div>

            <div class="card">
                <h3>Data Management</h3>
                <button class="btn btn-success" onclick="exportData()">ğŸ“¥ Export All Data</button>
                <button class="btn btn-warning" onclick="importData()">ğŸ“¤ Import Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">ğŸ—‘ï¸ Clear All Data</button>
            </div>

            <div id="configPanel" class="card hidden">
                <h3>Advanced Configuration</h3>
                <div id="configEditor"></div>
            </div>
        </div>
    </div>

    <!-- ===== Feature 4.0 Overlays ===== -->
    <div id="mmIntro" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">ğŸ® Monstrinhomon</div>
            <p class="mm-sub">RPG terapÃªutico infantil (PokÃ©mon + RPG).<br/>Clique para comeÃ§ar.</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">âœ¨ Iniciar</button>
            <p class="mm-hint">Dica: o jogo salva automaticamente em seu navegador.</p>
        </div>
    </div>

    <div id="mmMenu" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Menu Principal</div>
            <button class="mm-btn" onclick="mmOpenSaves()">ğŸ“‚ Gerenciar Saves</button>
            <button class="mm-btn" onclick="mmOpenSlotPickerForNewGame()">ğŸ® Novo Jogo</button>
            <button class="mm-btn" onclick="mmStartTutorial()">ğŸ“ Tutorial</button>
            <button class="mm-btn" onclick="mmShowConfig()">âš™ï¸ ConfiguraÃ§Ãµes</button>
            <div class="mm-row">
                <button class="mm-btn" onclick="mmCloseAllOverlays()">Fechar</button>
                <button class="mm-btn" onclick="mmResetSaveConfirm()">ğŸ—‘ï¸ Apagar Save</button>
            </div>
        </div>
    </div>

    <div id="mmNewGame" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Novo Jogo</div>

            <div id="mmNewGameStep"></div>

            <div class="mm-row">
                <button class="mm-btn" onclick="mmNewGameBack()">â¬…ï¸ Voltar</button>
                <button class="mm-btn" onclick="mmNewGameNext()">â¡ï¸ PrÃ³ximo</button>
            </div>
        </div>
    </div>

    <!-- Feature 4.3: Slot Picker for New Game -->
    <div id="mmSlotPicker" class="mm-overlay hidden">
        <div class="mm-card" style="max-width:640px;">
            <div class="mm-title">ğŸ’¾ Escolher Slot</div>
            <div style="opacity:0.9; margin-bottom:12px;">
                Selecione onde salvar este <b>Novo Jogo</b>. (VocÃª pode exportar/importar depois.)
            </div>

            <div id="mmSlotPickerList" style="display:grid; gap:10px;"></div>

            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;">
                <button class="mm-btn" style="width:auto;" onclick="mmCancelSlotPicker()">â†©ï¸ Voltar</button>
            </div>
        </div>
    </div>

    <div id="mmConfig" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">ConfiguraÃ§Ãµes</div>
            <p class="mm-sub">MVP: placeholder. (Depois entra volume, modo terapeuta, etc.)</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">Voltar</button>
        </div>
    </div>

    <!-- Feature 4.3: Save Slots Screen -->
    <div id="mmSavesScreen" class="mm-overlay hidden">
        <div class="mm-card" style="max-width:820px;">
            <div class="mm-title">ğŸ“‚ Gerenciar Saves</div>
            <div id="mmSavesSlots" style="display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px;"></div>

            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:16px;">
                <label class="mm-btn" style="width:auto; display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
                    â¬†ï¸ Importar JSON
                    <input id="mmImportFile" type="file" accept="application/json" style="display:none;">
                </label>

                <select id="mmImportSlotPick" class="mm-input" style="min-width:160px;">
                    <option value="1">Importar para Slot 1</option>
                    <option value="2">Importar para Slot 2</option>
                    <option value="3">Importar para Slot 3</option>
                </select>

                <button class="mm-btn" style="width:auto;" onclick="mmCloseSaves()">â†©ï¸ Voltar</button>
            </div>

            <div style="opacity:0.75; font-size:12px; margin-top:10px;">
                Dica: Exportar/Importar Ã© ideal para backup e trocar de dispositivo (iPad).
            </div>
        </div>
    </div>

    <script>
        // GLOBAL ERROR HANDLER
        window.addEventListener('error', function(event) {
            showError(event.error || event.message, event.error?.stack || '');
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise Rejection: ' + event.reason, event.reason?.stack || '');
        });

        function showError(message, stack) {
            const panel = document.getElementById('errorPanel');
            const messageDiv = document.getElementById('errorMessage');
            messageDiv.innerHTML = `<strong>Error:</strong> ${message}<br><pre>${stack}</pre>`;
            panel.classList.add('show');
            console.error('Error caught:', message, stack);
        }

        function dismissError() {
            document.getElementById('errorPanel').classList.remove('show');
        }

        function copyError() {
            const text = document.getElementById('errorMessage').innerText;
            navigator.clipboard.writeText(text).catch(e => alert('Copy failed: ' + e));
        }

        // STATE MANAGEMENT
        const GameState = {
            players: [],
            monsters: [],
            sessions: [],
            currentSession: null,
            currentEncounter: null,
            objectives: [],
            config: {
                maxTeamSize: 6,
                maxLevel: 100,
                levelExpo: 1.5,
                battleXpBase: 15,
                captureModel: 'threshold_no_dice',
                // Vantagens de Classe (conforme GAME_RULES.md)
                classAdvantages: {
                    'Guerreiro': { strong: 'Ladino', weak: 'Curandeiro' },
                    'Ladino': { strong: 'Mago', weak: 'Guerreiro' },
                    'Mago': { strong: 'BÃ¡rbaro', weak: 'Ladino' },
                    'BÃ¡rbaro': { strong: 'CaÃ§ador', weak: 'Mago' },
                    'CaÃ§ador': { strong: 'Bardo', weak: 'BÃ¡rbaro' },
                    'Bardo': { strong: 'Curandeiro', weak: 'CaÃ§ador' },
                    'Curandeiro': { strong: 'Guerreiro', weak: 'Bardo' },
                    'Animalista': { strong: null, weak: null } // Neutro
                },
                // Thresholds de captura por raridade (sem dado)
                captureThreshold: {
                    'Comum': 0.35,
                    'Incomum': 0.30,
                    'Raro': 0.22,
                    'MÃ­stico': 0.15,
                    'LendÃ¡rio': 0.08
                },
                // Multiplicadores de raridade
                rarityPower: {
                    'Comum': 1.00,
                    'Incomum': 1.08,
                    'Raro': 1.18,
                    'MÃ­stico': 1.32,
                    'LendÃ¡rio': 1.50
                },
                rarityXP: {
                    'Comum': 1.00,
                    'Incomum': 1.05,
                    'Raro': 1.10,
                    'MÃ­stico': 1.15,
                    'LendÃ¡rio': 1.25
                },
                // Chance base de fuga por raridade
                fleeBase: {
                    'Comum': 10,
                    'Incomum': 12,
                    'Raro': 15,
                    'MÃ­stico': 18,
                    'LendÃ¡rio': 25
                },
                medalTiers: { bronze: 5, silver: 12, gold: 25 }
            }
        };

        // MONSTER CATALOG (baseado em MONSTROS.csv)
        const MONSTER_CATALOG = [
            { id: 'MON_001', name: 'Cantapau', class: 'Bardo', rarity: 'Comum', baseHp: 28, baseAtk: 6, baseDef: 4, baseSpd: 6, emoji: 'ğŸµ' },
            { id: 'MON_002', name: 'Pedrino', class: 'Guerreiro', rarity: 'Comum', baseHp: 32, baseAtk: 7, baseDef: 6, baseSpd: 5, emoji: 'âš”ï¸' },
            { id: 'MON_003', name: 'FaÃ­scari', class: 'Mago', rarity: 'Comum', baseHp: 26, baseAtk: 8, baseDef: 3, baseSpd: 7, emoji: 'ğŸ”®' },
            { id: 'MON_004', name: 'Ninfolha', class: 'Curandeiro', rarity: 'Comum', baseHp: 30, baseAtk: 4, baseDef: 4, baseSpd: 5, emoji: 'ğŸ’š' },
            { id: 'MON_005', name: 'Garruncho', class: 'CaÃ§ador', rarity: 'Comum', baseHp: 29, baseAtk: 7, baseDef: 3, baseSpd: 8, emoji: 'ğŸ¹' },
            { id: 'MON_100', name: 'Rato-de-Lama', class: 'Guerreiro', rarity: 'Comum', baseHp: 20, baseAtk: 5, baseDef: 3, baseSpd: 4, emoji: 'ğŸ€' }
        ];

        // ENE REGEN CONSTANTS por classe (fallback)
        const ENE_REGEN_BY_CLASS = {
            'Mago': { pct: 0.18, min: 3 },
            'Curandeiro': { pct: 0.18, min: 3 },
            'Bardo': { pct: 0.14, min: 2 },
            'CaÃ§ador': { pct: 0.14, min: 2 },
            'Ladino': { pct: 0.14, min: 2 },
            'Animalista': { pct: 0.12, min: 2 },
            'BÃ¡rbaro': { pct: 0.12, min: 2 },
            'Guerreiro': { pct: 0.10, min: 1 }
        };

        // POWER BÃSICO por classe (ataque sem habilidade)
        const BASIC_ATTACK_POWER = {
            'Guerreiro': 12,
            'Mago': 11,
            'Curandeiro': 10,
            'BÃ¡rbaro': 14,
            'Ladino': 12,
            'Bardo': 11,
            'CaÃ§ador': 13,
            'Animalista': 12
        };

        // SKILL DEFINITIONS (inline - por classe e estÃ¡gio)
        const SKILL_DEFS = {
            // GUERREIRO
            'Guerreiro': {
                'Golpe de Espada': [
                    { tier: 1, name: 'Golpe de Espada I', type: 'DAMAGE', cost: 4, power: 18, desc: 'Ataque com espada.' },
                    { tier: 2, name: 'Golpe de Espada II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque forte com espada.' },
                    { tier: 3, name: 'Golpe de Espada III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque devastador com espada.' }
                ],
                'Escudo': [
                    { tier: 1, name: 'Escudo I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF temporariamente.' },
                    { tier: 2, name: 'Escudo II', type: 'BUFF', cost: 6, power: 3, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta muito a DEF.' },
                    { tier: 3, name: 'Escudo III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'self', duration: 3, desc: 'Escudo poderoso.' }
                ],
                'Provocar': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Provocar I', type: 'TAUNT', cost: 4, power: 0, desc: 'Provoca o inimigo.' },
                    { tier: 3, name: 'Provocar II', type: 'TAUNT', cost: 6, power: 0, desc: 'Provoca intensamente.' }
                ]
            },
            // CURANDEIRO
            'Curandeiro': {
                'Cura': [
                    { tier: 1, name: 'Cura I', type: 'HEAL', cost: 5, power: 15, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Cura II', type: 'HEAL', cost: 7, power: 25, target: 'ally', desc: 'Cura moderada.' },
                    { tier: 3, name: 'Cura III', type: 'HEAL', cost: 10, power: 40, target: 'ally', desc: 'Cura poderosa.' }
                ],
                'BÃªnÃ§Ã£o': [
                    { tier: 1, name: 'BÃªnÃ§Ã£o I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK do aliado.' },
                    { tier: 2, name: 'BÃªnÃ§Ã£o II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'BÃªnÃ§Ã£o III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'ally', duration: 3, desc: 'BÃªnÃ§Ã£o poderosa (DEF).' }
                ]
            },
            // MAGO
            'Mago': {
                'Magia Elemental': [
                    { tier: 1, name: 'Magia Elemental I', type: 'DAMAGE', cost: 4, power: 20, desc: 'Magia elemental.' },
                    { tier: 2, name: 'Magia Elemental II', type: 'DAMAGE', cost: 6, power: 26, desc: 'Magia elemental forte.' },
                    { tier: 3, name: 'Magia Elemental III', type: 'DAMAGE', cost: 8, power: 32, desc: 'Magia elemental poderosa.' }
                ],
                'ExplosÃ£o Elemental': [
                    { tier: 1, name: 'ExplosÃ£o Elemental I', type: 'DAMAGE', cost: 6, power: 24, desc: 'ExplosÃ£o mÃ¡gica.' },
                    { tier: 2, name: 'ExplosÃ£o Elemental II', type: 'DAMAGE', cost: 8, power: 32, desc: 'ExplosÃ£o mÃ¡gica forte.' },
                    { tier: 3, name: 'ExplosÃ£o Elemental III', type: 'DAMAGE', cost: 12, power: 38, desc: 'ExplosÃ£o devastadora.' }
                ]
            },
            // BÃRBARO
            'BÃ¡rbaro': {
                'FÃºria': [
                    { tier: 1, name: 'FÃºria I', type: 'BUFF', cost: 4, power: 3, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -1, desc: 'Aumenta ATK, reduz DEF.' },
                    { tier: 2, name: 'FÃºria II', type: 'BUFF', cost: 6, power: 4, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -2, desc: 'FÃºria intensa.' },
                    { tier: 3, name: 'FÃºria III', type: 'BUFF', cost: 8, power: 6, buffType: 'ATK', target: 'self', duration: 3, debuffType: 'DEF', debuffPower: -2, desc: 'FÃºria selvagem.' }
                ],
                'Golpe Brutal': [
                    { tier: 1, name: 'Golpe Brutal I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Golpe brutal.' },
                    { tier: 2, name: 'Golpe Brutal II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Golpe muito brutal.' },
                    { tier: 3, name: 'Golpe Brutal III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Golpe devastador.' }
                ]
            },
            // LADINO
            'Ladino': {
                'Ataque Preciso': [
                    { tier: 1, name: 'Ataque Preciso I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Ataque preciso.' },
                    { tier: 2, name: 'Ataque Preciso II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque muito preciso.' },
                    { tier: 3, name: 'Ataque Preciso III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque extremamente preciso.' }
                ],
                'Enfraquecer': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Enfraquecer I', type: 'BUFF', cost: 4, power: -2, buffType: 'ATK', target: 'enemy', duration: 1, desc: 'Reduz ATK do inimigo.' },
                    { tier: 3, name: 'Enfraquecer II', type: 'BUFF', cost: 6, power: -3, buffType: 'ATK', target: 'enemy', duration: 2, desc: 'Enfraquece muito o inimigo.' }
                ]
            },
            // BARDO
            'Bardo': {
                'CanÃ§Ã£o de Coragem': [
                    { tier: 1, name: 'CanÃ§Ã£o de Coragem I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK.' },
                    { tier: 2, name: 'CanÃ§Ã£o de Coragem II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'CanÃ§Ã£o de Coragem III', type: 'BUFF', cost: 8, power: 4, buffType: 'ATK', target: 'ally', duration: 3, desc: 'CanÃ§Ã£o inspiradora.' }
                ],
                'CanÃ§Ã£o Calmante': [
                    { tier: 1, name: 'CanÃ§Ã£o Calmante I', type: 'HEAL', cost: 5, power: 12, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'CanÃ§Ã£o Calmante II', type: 'BUFF', cost: 6, power: 2, buffType: 'DEF', target: 'ally', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 3, name: 'CanÃ§Ã£o Calmante III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'ally', duration: 3, desc: 'CanÃ§Ã£o protetora.' }
                ]
            },
            // CAÃ‡ADOR
            'CaÃ§ador': {
                'Flecha Poderosa': [
                    { tier: 1, name: 'Flecha Poderosa I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Flecha poderosa.' },
                    { tier: 2, name: 'Flecha Poderosa II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Flecha muito poderosa.' },
                    { tier: 3, name: 'Flecha Poderosa III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Flecha devastadora.' }
                ],
                'Armadilha': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Armadilha I', type: 'BUFF', cost: 4, power: -2, buffType: 'SPD', target: 'enemy', duration: 1, desc: 'Reduz SPD do inimigo.' },
                    { tier: 3, name: 'Armadilha II', type: 'BUFF', cost: 6, power: -3, buffType: 'SPD', target: 'enemy', duration: 2, desc: 'Armadilha poderosa.' }
                ]
            },
            // ANIMALISTA
            'Animalista': {
                'Investida Bestial': [
                    { tier: 1, name: 'Investida Bestial I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Investida feroz.' },
                    { tier: 2, name: 'Investida Bestial II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Investida muito feroz.' },
                    { tier: 3, name: 'Investida Bestial III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Investida selvagem.' }
                ],
                'Instinto Selvagem': [
                    { tier: 1, name: 'Instinto Selvagem I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 2, name: 'Instinto Selvagem II', type: 'BUFF', cost: 6, power: 2, buffType: 'SPD', target: 'self', duration: 2, desc: 'Aumenta SPD.' },
                    { tier: 3, name: 'Instinto Selvagem III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'self', duration: 3, desc: 'Instinto aguÃ§ado.' }
                ]
            }
        };

        // CLASTERORB TIERS (Sistema de captura em tiers)
        const CLASTERORBS = {
            'CLASTERORB_COMUM': { id: 'CLASTERORB_COMUM', name: 'ClasterOrb Comum', type: 'CAPTURE', capture_bonus_pp: 0, emoji: 'âšª' },
            'CLASTERORB_INCOMUM': { id: 'CLASTERORB_INCOMUM', name: 'ClasterOrb Incomum', type: 'CAPTURE', capture_bonus_pp: 5, emoji: 'ğŸ”µ' },
            'CLASTERORB_RARA': { id: 'CLASTERORB_RARA', name: 'ClasterOrb Rara', type: 'CAPTURE', capture_bonus_pp: 10, emoji: 'ğŸŸ£' }
        };

        // SKILLS CATALOG (baseado em HABILIDADES.csv)
        const SKILLS_CATALOG = [
            { id: 'SK_WAR_01', name: 'Golpe de Escudo', class: 'Guerreiro', category: 'Controle', power: 6, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: 'Atordoado', desc: 'Ataque curto com chance de atordoar.' },
            { id: 'SK_WAR_02', name: 'Corte Pesado', class: 'Guerreiro', category: 'Ataque', power: 9, accuracy: 0.8, energy_cost: 3, target: 'Inimigo', status: '', desc: 'Dano alto, menos preciso.' },
            { id: 'SK_MAG_01', name: 'Raio MÃ­stico', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Dano mÃ¡gico Ã  distÃ¢ncia.' },
            { id: 'SK_MAG_02', name: 'NÃ©voa Lenta', class: 'Mago', category: 'Controle', power: 4, accuracy: 0.9, energy_cost: 3, target: 'Ãrea', status: 'Enraizado', desc: 'Reduz aÃ§Ã£o/movimento por 1 turno.' },
            { id: 'SK_HEA_01', name: 'Sopro Calmante', class: 'Curandeiro', category: 'Cura', power: 0, accuracy: 1, energy_cost: 4, target: 'Aliado', status: '', desc: 'Cura moderada.' },
            { id: 'SK_HEA_02', name: 'Barreira Suave', class: 'Curandeiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Aliado', status: 'Protegido', desc: 'Aumenta defesa por 2 turnos.' },
            { id: 'SK_HUN_01', name: 'Flecha RÃ¡pida', class: 'CaÃ§ador', category: 'Ataque', power: 8, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: '', desc: 'Dano consistente Ã  distÃ¢ncia.' },
            { id: 'SK_BRD_01', name: 'CanÃ§Ã£o de Coragem', class: 'Bardo', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Ãrea', status: 'Fortalecido', desc: 'Buff de ataque para aliados.' }
        ];

        // CLASS ENERGY REGEN (baseado em CLASSES.csv)
        const CLASS_ENERGY_REGEN = {
            'Guerreiro': { ene_regen_pct: 0.10, ene_regen_min: 2 },
            'Mago': { ene_regen_pct: 0.25, ene_regen_min: 1 },
            'Curandeiro': { ene_regen_pct: 0.20, ene_regen_min: 2 },
            'BÃ¡rbaro': { ene_regen_pct: 0.10, ene_regen_min: 1 },
            'Ladino': { ene_regen_pct: 0.15, ene_regen_min: 1 },
            'Bardo': { ene_regen_pct: 0.18, ene_regen_min: 2 },
            'CaÃ§ador': { ene_regen_pct: 0.12, ene_regen_min: 2 },
            'Animalista': { ene_regen_pct: 0.15, ene_regen_min: 2 }
        };

        // DEFAULT OBJECTIVES
        const DEFAULT_OBJECTIVES = [
            { id: 1, text: 'Followed group rules', weight: 2 },
            { id: 2, text: 'Waited for turn patiently', weight: 3 },
            { id: 3, text: 'Helped another player', weight: 3 },
            { id: 4, text: 'Used calm voice throughout', weight: 2 },
            { id: 5, text: 'Made good eye contact', weight: 1 },
            { id: 6, text: 'Shared materials/ideas', weight: 2 }
        ];

        // INITIALIZATION
        function init() {
            try {
                loadFromLocalStorage();
                if (!GameState.objectives || GameState.objectives.length === 0) {
                    GameState.objectives = [...DEFAULT_OBJECTIVES];
                }
                updateAllViews();
                console.log('Monstrinhomon initialized successfully');
            } catch (error) {
                showError('Initialization failed', error.stack);
            }
        }

        // LOCAL STORAGE
        function saveToLocalStorage() {
            try {
                const data = JSON.stringify(GameState);
                localStorage.setItem('monstrinhomon_state', data);
            } catch (error) {
                showError('Failed to save data', error.stack);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('monstrinhomon_state');
                if (data) {
                    const loaded = JSON.parse(data);
                    Object.assign(GameState, loaded);
                    
                    // Migrar inventÃ¡rios antigos
                    if (GameState.players) {
                        GameState.players.forEach(player => {
                            migrateInventory(player);
                            
                            // Garantir que monstros tenham ENE e campos de progressÃ£o (Feature 3.3)
                            if (player.team) {
                                player.team.forEach(monster => {
                                    // ENE (Sistema ENE)
                                    if (!monster.eneMax) {
                                        monster.eneMax = 10 + (monster.level || 1);
                                        monster.ene = monster.eneMax;
                                    }
                                    if (monster.ene === undefined) {
                                        monster.ene = monster.eneMax;
                                    }
                                    
                                    // ProgressÃ£o (Feature 3.3) - compatibilidade com saves antigos
                                    ensureMonsterProgressFields(monster);
                                });
                            }
                        });
                    }
                }
            } catch (error) {
                console.warn('Failed to load saved data:', error);
            }
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            try {
                const tabs = document.querySelectorAll('.tab-content');
                const buttons = document.querySelectorAll('.tab-button');
                
                tabs.forEach(tab => tab.classList.remove('active'));
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeTab = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                const activeButton = Array.from(buttons).find(btn => 
                    btn.textContent.toLowerCase().includes(tabName.toLowerCase())
                );
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                
                updateAllViews();
            } catch (error) {
                showError('Tab switching failed', error.stack);
            }
        }

        // PLAYER MANAGEMENT
        function addPlayer() {
            try {
                const name = document.getElementById('playerName')?.value?.trim();
                const playerClass = document.getElementById('playerClass')?.value;
                
                if (!name) {
                    alert('Please enter a player name');
                    return;
                }
                
                if (!playerClass) {
                    alert('Please select a class');
                    return;
                }
                
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    class: playerClass, // Armazena a classe diretamente
                    playerClassId: playerClass,
                    money: 100,
                    afterlifeCurrency: 0,
                    team: [],
                    box: [],
                    inventory: {
                        'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                        'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                        'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                        'IT_HEAL_01': 3           // Petisco de Cura x3
                    }
                };
                
                GameState.players = GameState.players || [];
                GameState.players.push(player);
                
                giveStarterMonster(player);
                
                document.getElementById('playerName').value = '';
                document.getElementById('playerClass').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add player', error.stack);
            }
        }

        function giveStarterMonster(player) {
            try {
                // Busca monstrinho inicial da mesma classe do jogador
                const classMonsters = MONSTER_CATALOG.filter(m => 
                    m?.class === player?.class && m?.rarity === 'Comum'
                );
                
                // Se nÃ£o encontrar da mesma classe, pega qualquer starter comum
                const starterTemplate = classMonsters.length > 0 ? classMonsters[0] : 
                    MONSTER_CATALOG.find(m => m?.rarity === 'Comum');
                
                if (!starterTemplate) return;
                
                const monster = createMonsterInstance(starterTemplate, player.id, 5);
                
                if (monster) {
                    player.team = player.team || [];
                    player.team.push(monster);
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                }
            } catch (error) {
                console.error('Failed to give starter monster:', error);
            }
        }

        function createMonsterInstance(template, ownerId, level = 1) {
            try {
                if (!template) return null;
                
                // Calcular stats baseados no nÃ­vel
                const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult); // SPD adicionado
                const poder = Math.floor(atk * 0.5); // PODER Ã© derivado de ATK
                
                // Calcular ENE (Sistema ENE)
                const baseEne = template.baseEne || 10; // Fallback se nÃ£o tiver no template
                const eneGrowth = 2; // growth_ene padrÃ£o
                const eneMax = Math.floor(baseEne + eneGrowth * (level - 1));
                
                // Determinar stage baseado no nÃ­vel (simplificado)
                // S0: nÃ­vel 1-9, S1: 10-24, S2: 25-44, S3: 45+
                let stage = 0;
                if (level >= 45) stage = 3;
                else if (level >= 25) stage = 2;
                else if (level >= 10) stage = 1;
                
                return {
                    id: Date.now() + Math.random(),
                    ownerId: ownerId,
                    monsterId: template.id,
                    name: template.name,
                    nickname: template.name, // Nickname padrÃ£o
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji,
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level), // Feature 3.3
                    hp: hpMax,
                    hpMax: hpMax,
                    atk: atk,
                    def: def,
                    spd: spd,           // SPD adicionado
                    poder: poder,
                    ene: eneMax,      // ENE atual (comeÃ§a cheio)
                    eneMax: eneMax,   // ENE mÃ¡ximo
                    stage: stage,     // EstÃ¡gio de evoluÃ§Ã£o (0-3)
                    status: 'healthy',
                    buffs: []         // Array para buffs temporÃ¡rios
                };
            } catch (error) {
                console.error('Failed to create monster instance:', error);
                return null;
            }
        }

        // FunÃ§Ã£o para obter habilidade do monstrinho
        // Obter habilidades do monstrinho baseado em classe e estÃ¡gio
        function getMonsterSkills(monster) {
            try {
                if (!monster || !monster.class) return [];
                
                const classSkills = SKILL_DEFS[monster.class];
                if (!classSkills) return [];
                
                const stage = monster.stage || 0;
                const skillList = [];
                
                // Pegar as duas primeiras skills sempre disponÃ­veis
                const skillNames = Object.keys(classSkills);
                for (let i = 0; i < Math.min(2, skillNames.length); i++) {
                    const skillTiers = classSkills[skillNames[i]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                // Terceira skill (se existir e stage >= 1)
                if (skillNames.length > 2 && stage >= 1) {
                    const skillTiers = classSkills[skillNames[2]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                return skillList;
            } catch (error) {
                console.error('Failed to get monster skills:', error);
                return [];
            }
        }

        // Aplicar regeneraÃ§Ã£o de ENE
        function applyEneRegen(monster, encounter) {
            try {
                if (!monster || !monster.class) return;
                
                const regenData = ENE_REGEN_BY_CLASS[monster.class] || { pct: 0.10, min: 1 };
                const eneGain = Math.max(regenData.min, Math.ceil(monster.eneMax * regenData.pct));
                
                monster.ene = Math.min(monster.eneMax, monster.ene + eneGain);
                
                if (encounter && encounter.log) {
                    encounter.log.push(`âš¡ ${monster.name} regenerou ${eneGain} ENE (${monster.ene}/${monster.eneMax})`);
                }
            } catch (error) {
                console.error('Failed to apply ENE regen:', error);
            }
        }

        // Usar habilidade
        function useSkill(attacker, skill, defender, encounter) {
            try {
                if (!attacker || !skill || !defender) return false;
                
                // Verificar se tem ENE suficiente
                if (attacker.ene < skill.cost) {
                    return false;
                }
                
                // Consumir ENE
                attacker.ene -= skill.cost;
                
                encounter.log = encounter.log || [];
                encounter.log.push(`âœ¨ ${attacker.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                
                // Aplicar efeito baseado no tipo
                switch (skill.type) {
                    case 'DAMAGE':
                        // Calcular dano da habilidade com nova fÃ³rmula
                        const atkMods = getBuffModifiers(attacker);
                        const effectiveAtk = Math.max(1, attacker.atk + atkMods.atk);
                        
                        const defMods = getBuffModifiers(defender);
                        const effectiveDef = Math.max(1, defender.def + defMods.def);
                        
                        // Vantagem de classe
                        const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                        let damageMult = 1.0;
                        if (classAdv?.strong === defender.class) {
                            damageMult = 1.10;
                        } else if (classAdv?.weak === defender.class) {
                            damageMult = 0.90;
                        }
                        
                        const skillDamage = calcDamage({
                            atk: effectiveAtk,
                            def: effectiveDef,
                            power: skill.power,
                            damageMult: damageMult
                        });
                        
                        defender.hp = Math.max(0, defender.hp - skillDamage);
                        encounter.log.push(`ğŸ’¥ ${defender.name} recebe ${skillDamage} de dano!`);
                        break;
                        
                    case 'HEAL':
                        // Curar (self ou ally)
                        const healAmount = skill.power;
                        const target = (skill.target === 'ally' || skill.target === 'self') ? attacker : defender;
                        target.hp = Math.min(target.hpMax, target.hp + healAmount);
                        encounter.log.push(`ğŸ’š ${target.name} recupera ${healAmount} HP!`);
                        break;
                        
                    case 'BUFF':
                        // Aplicar buff/debuff
                        const buffTarget = skill.target === 'enemy' ? defender : attacker;
                        buffTarget.buffs = buffTarget.buffs || [];
                        
                        const buff = {
                            type: skill.buffType,
                            power: skill.power,
                            duration: skill.duration || 1,
                            source: skill.name
                        };
                        buffTarget.buffs.push(buff);
                        
                        const buffDesc = skill.power > 0 ? `+${skill.power}` : skill.power;
                        encounter.log.push(`ğŸ”® ${buffTarget.name} recebe ${buff.type} ${buffDesc} por ${buff.duration} turnos!`);
                        
                        // Se for FÃºria (BÃ¡rbaro), aplicar tambÃ©m o debuff
                        if (skill.debuffType && skill.debuffPower) {
                            const debuff = {
                                type: skill.debuffType,
                                power: skill.debuffPower,
                                duration: skill.duration || 1,
                                source: skill.name
                            };
                            attacker.buffs.push(debuff);
                            encounter.log.push(`âš ï¸ ${attacker.name} recebe ${debuff.type} ${debuff.power} por ${debuff.duration} turnos!`);
                        }
                        break;
                        
                    case 'TAUNT':
                        // Marcar alvo como provocado (flag simples)
                        defender.taunted = true;
                        encounter.log.push(`ğŸ˜  ${defender.name} foi provocado!`);
                        break;
                }
                
                return true;
            } catch (error) {
                console.error('Failed to use skill:', error);
                return false;
            }
        }

        // Atualizar buffs (reduzir duraÃ§Ã£o, remover expirados)
        function updateBuffs(monster) {
            try {
                if (!monster || !monster.buffs) return;
                
                monster.buffs = monster.buffs.filter(buff => {
                    buff.duration--;
                    return buff.duration > 0;
                });
            } catch (error) {
                console.error('Failed to update buffs:', error);
            }
        }

        // Calcular modificadores de buffs
        function getBuffModifiers(monster) {
            try {
                if (!monster || !monster.buffs) return { atk: 0, def: 0, spd: 0 };
                
                const mods = { atk: 0, def: 0, spd: 0 };
                
                monster.buffs.forEach(buff => {
                    const type = buff.type.toLowerCase();
                    if (type === 'atk') mods.atk += buff.power;
                    else if (type === 'def') mods.def += buff.power;
                    else if (type === 'spd') mods.spd += buff.power;
                });
                
                return mods;
            } catch (error) {
                console.error('Failed to get buff modifiers:', error);
                return { atk: 0, def: 0, spd: 0 };
            }
        }

        // FunÃ§Ã£o antiga removida - usar getMonsterSkills acima

        // Migrar inventÃ¡rio antigo para novo sistema ClasterOrb
        function migrateInventory(player) {
            try {
                if (!player || !player.inventory) return;
                
                // Se tem IT_CAP_01 antigo, converter para CLASTERORB_COMUM
                if (player.inventory['IT_CAP_01']) {
                    const oldCount = player.inventory['IT_CAP_01'];
                    player.inventory['CLASTERORB_COMUM'] = (player.inventory['CLASTERORB_COMUM'] || 0) + oldCount;
                    delete player.inventory['IT_CAP_01'];
                }
                
                // Garantir que novos itens existam
                if (!player.inventory['CLASTERORB_COMUM']) player.inventory['CLASTERORB_COMUM'] = 0;
                if (!player.inventory['CLASTERORB_INCOMUM']) player.inventory['CLASTERORB_INCOMUM'] = 0;
                if (!player.inventory['CLASTERORB_RARA']) player.inventory['CLASTERORB_RARA'] = 0;
            } catch (error) {
                console.error('Failed to migrate inventory:', error);
            }
        }

        // SESSION MANAGEMENT
        function createSession() {
            try {
                const name = document.getElementById('sessionName')?.value?.trim();
                
                if (!name) {
                    alert('Please enter a session name');
                    return;
                }
                
                if (!GameState.players || GameState.players.length === 0) {
                    alert('Please add players first');
                    return;
                }
                
                const session = {
                    id: Date.now(),
                    name: name,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    players: GameState.players.map(p => p?.id).filter(id => id),
                    turnOrder: [...GameState.players.map(p => p?.id).filter(id => id)],
                    currentTurnIndex: 0,
                    encountersLog: [],
                    therapy: {
                        perPlayer: {}
                    }
                };
                
                GameState.players.forEach(player => {
                    if (player?.id) {
                        session.therapy.perPlayer[player.id] = {
                            pm: 0,
                            medals: [],
                            logs: [],
                            completedObjectives: []
                        };
                    }
                });
                
                GameState.sessions = GameState.sessions || [];
                GameState.sessions.push(session);
                GameState.currentSession = session;
                
                document.getElementById('sessionName').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to create session', error.stack);
            }
        }

        function nextTurn() {
            try {
                if (!GameState.currentSession) return;
                
                const session = GameState.currentSession;
                session.currentTurnIndex = ((session.currentTurnIndex || 0) + 1) % (session.turnOrder?.length || 1);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to advance turn', error.stack);
            }
        }

        function endSession() {
            try {
                if (!GameState.currentSession) return;
                
                if (confirm('End this session?')) {
                    GameState.currentSession.completedAt = new Date().toISOString();
                    GameState.currentSession = null;
                    
                    saveToLocalStorage();
                    updateAllViews();
                }
            } catch (error) {
                showError('Failed to end session', error.stack);
            }
        }

        // ENCOUNTER MANAGEMENT
        function startEncounter() {
            try {
                const type = document.getElementById('encounterType')?.value;
                
                if (!type) {
                    alert('Please select encounter type');
                    return;
                }
                
                if (!GameState.currentSession) {
                    alert('Please create a session first');
                    return;
                }
                
                // Para encontros em grupo (trainer/boss), usar sistema de grupo
                if (type === 'trainer' || type === 'boss') {
                    // Coletar participantes selecionados
                    const checkboxes = document.querySelectorAll('input[name="groupParticipant"]:checked');
                    const selectedPlayerIds = Array.from(checkboxes).map(cb => cb.value);
                    
                    if (selectedPlayerIds.length === 0) {
                        alert('Selecione pelo menos 1 jogador para a batalha em grupo');
                        return;
                    }
                    
                    if (selectedPlayerIds.length > 6) {
                        alert('MÃ¡ximo de 6 jogadores por batalha');
                        return;
                    }
                    
                    const enemyLevel = parseInt(document.getElementById('enemyLevel')?.value || '5');
                    startGroupEncounter(selectedPlayerIds, type, enemyLevel);
                    return;
                }
                
                // Para encontros individuais (captura), precisa selecionar jogador
                if (type === 'wild') {
                    const selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                    if (!selectedPlayerId) {
                        alert('Please select a player for individual encounter');
                        return;
                    }
                    
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (!player || !player.team || player.team.length === 0) {
                        alert('Selected player has no monsters in team');
                        return;
                    }
                    
                    // GAME_RULES.md: Em batalha, sÃ³ pode usar monstros da mesma classe do jogador
                    const validMonsters = player.team.filter(m => m.class === player.class && m.status !== 'fainted');
                    if (validMonsters.length === 0) {
                        alert(`âš ï¸ ${player.name} nÃ£o tem monstrinhos da classe ${player.class} disponÃ­veis!\n\nREGRA: Em batalha, vocÃª sÃ³ pode usar monstrinhos da SUA classe.\nTroque com outros jogadores para conseguir monstrinhos da sua classe!`);
                        return;
                    }
                }
                
                const encounter = {
                    id: Date.now(),
                    type: type,
                    active: true,
                    log: [],
                    selectedPlayerId: type === 'wild' ? document.getElementById('encounterPlayer')?.value : null,
                    rewardsGranted: false  // Previne duplicaÃ§Ã£o de XP
                };
                
                if (type === 'wild') {
                    const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                    const level = Math.floor(Math.random() * 10) + 1;
                    encounter.wildMonster = createMonsterInstance(randomMonster, null, level);
                    encounter.wildMonster.id = 'wild_' + Date.now();
                }
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start encounter', error.stack);
            }
        }

        // GROUP BATTLE FUNCTIONS (Feature 3.2)
        
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function startGroupEncounter(selectedPlayerIds, encounterType, enemyLevel) {
            try {
                // Criar inimigo
                const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                const enemy = createMonsterInstance(randomMonster, null, enemyLevel);
                enemy.id = 'enemy_1';
                
                // Criar encounter de grupo
                const encounter = {
                    id: Date.now(),
                    type: encounterType === 'boss' ? 'boss' : 'group_trainer',
                    active: true,
                    log: [],
                    participants: selectedPlayerIds,
                    enemies: [enemy],
                    turnOrder: [],
                    turnIndex: 0,
                    currentActor: null,
                    finished: false,
                    result: null,
                    rewardsGranted: false  // Previne duplicaÃ§Ã£o de XP
                };
                
                // Calcular ordem de turnos
                encounter.turnOrder = calculateGroupTurnOrder(encounter);
                encounter.turnIndex = 0;
                encounter.currentActor = getCurrentActor(encounter);
                
                encounter.log.push('ğŸ² Ordem de turnos calculada!');
                encounter.turnOrder.forEach((actor, idx) => {
                    const tieInfo = actor._tiebreak ? ` (d20: ${actor._tiebreak})` : '';
                    encounter.log.push(`   ${idx + 1}. ${actor.name} (${actor.side === 'player' ? 'Jogador' : 'Inimigo'}, SPD: ${actor.spd}${tieInfo})`);
                });
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start group encounter', error.stack);
            }
        }
        
        function calculateGroupTurnOrder(enc) {
            const order = [];
            
            // Adicionar jogadores participantes
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                if (!p) continue;
                
                const mon = p.team?.[0];
                if (!mon) continue;
                
                const hp = Number(mon.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "player",
                    id: pid,
                    name: p.name || p.nome || "Jogador",
                    spd: Number(mon.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Adicionar inimigos
            for (let i = 0; i < (enc.enemies || []).length; i++) {
                const e = enc.enemies[i];
                if (!e) continue;
                
                const hp = Number(e.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "enemy",
                    id: i,
                    name: e.name || e.nome || `Inimigo ${i + 1}`,
                    spd: Number(e.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Ordenar por SPD descendente
            order.sort((a, b) => (b.spd - a.spd));
            
            // Desempate por grupos de mesmo SPD
            let i = 0;
            while (i < order.length) {
                let j = i + 1;
                while (j < order.length && order[j].spd === order[i].spd) j++;
                
                // [i, j) Ã© o bloco empatado
                if (j - i > 1) {
                    for (let k = i; k < j; k++) {
                        order[k]._tiebreak = rollD20();
                    }
                    const sortedBlock = order.slice(i, j).sort((a, b) => (b._tiebreak - a._tiebreak));
                    for (let k = 0; k < sortedBlock.length; k++) {
                        order[i + k] = sortedBlock[k];
                    }
                }
                
                i = j;
            }
            
            return order;
        }
        
        function getCurrentActor(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return null;
            const idx = Number(enc.turnIndex) || 0;
            return enc.turnOrder[idx] || null;
        }
        
        function _hasAlivePlayers(enc) {
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                const mon = p?.team?.[0];
                if (mon && (Number(mon.hp) || 0) > 0) return true;
            }
            return false;
        }
        
        function _hasAliveEnemies(enc) {
            for (const e of (enc.enemies || [])) {
                if ((Number(e?.hp) || 0) > 0) return true;
            }
            return false;
        }
        
        function advanceTurn(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return;
            
            // Verificar condiÃ§Ãµes de fim
            const alivePlayers = _hasAlivePlayers(enc);
            const aliveEnemies = _hasAliveEnemies(enc);
            
            if (!aliveEnemies) {
                enc.finished = true;
                enc.result = "victory";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("ğŸ VitÃ³ria! Todos os inimigos foram derrotados.");
                
                // Distribuir recompensas (XP) com idempotÃªncia
                handleVictoryRewards(enc);
                
                return;
            }
            
            if (!alivePlayers) {
                enc.finished = true;
                enc.result = "defeat";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("ğŸ’€ Derrota... Todos os participantes foram derrotados.");
                return;
            }
            
            // AvanÃ§ar para prÃ³ximo ator vÃ¡lido
            const maxLoops = enc.turnOrder.length + 2;
            let loops = 0;
            
            do {
                enc.turnIndex = ((Number(enc.turnIndex) || 0) + 1) % enc.turnOrder.length;
                loops++;
                
                const actor = getCurrentActor(enc);
                if (!actor) break;
                
                // Validar se ator ainda estÃ¡ vivo
                if (actor.side === "player") {
                    const p = GameState.players.find(x => x.id === actor.id);
                    const mon = p?.team?.[0];
                    if (mon && (Number(mon.hp) || 0) > 0) break;
                } else {
                    const e = enc.enemies?.[actor.id];
                    if (e && (Number(e.hp) || 0) > 0) break;
                }
                
            } while (loops < maxLoops);
            
            // Atualizar currentActor
            enc.currentActor = getCurrentActor(enc);
            
            // Auto-trigger turno do inimigo
            const actorNow = getCurrentActor(enc);
            if (actorNow && actorNow.side === "enemy" && !enc.finished) {
                processEnemyTurnGroup(enc);
            } else if (actorNow) {
                enc.log = enc.log || [];
                enc.log.push(`âºï¸ Turno: ${actorNow.name}`);
            }
        }
        
        function groupPassTurn() {
            try {
                const enc = GameState.currentEncounter;
                if (!enc) return;
                
                const actor = getCurrentActor(enc);
                if (!actor) return;
                
                enc.log.push(`â–¶ï¸ ${actor.name} passou o turno`);
                
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to pass turn', error.stack);
            }
        }

        // ==================== FASE 3: Helper Functions ====================

        function _getGroupEncounter() {
            return GameState.currentEncounter;
        }

        function _getPlayerById(playerId) {
            return GameState.players.find(p => p.id === playerId) || null;
        }

        function _getActiveMonsterOfPlayer(player) {
            return player?.team?.[0] || null;
        }

        function _getEnemyByIndex(enc, idx) {
            return enc?.enemies?.[idx] || null;
        }

        function _clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }

        function _calcDamage(power, atk, def) {
            const A = Number(atk) || 0;
            const D = Number(def) || 0;
            const P = Number(power) || 0;
            const ratio = (A <= 0 && D <= 0) ? 0.5 : (A / (A + D));
            const base = Math.floor(P * ratio);
            return Math.max(1, base);
        }

        function _isAlive(entity) {
            return (Number(entity?.hp) || 0) > 0;
        }

        function _log(enc, msg) {
            enc.log = enc.log || [];
            enc.log.push(msg);
        }

        function _chooseTargetPlayerId(enc) {
            let best = null;
            for (const pid of (enc.participants || [])) {
                const p = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(p);
                if (!mon || !_isAlive(mon)) continue;

                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;
                const pct = hp / hpMax;

                if (!best || pct < best.pct) best = { pid, pct };
            }
            return best ? best.pid : null;
        }

        // ==================== FASE 3.A: Player Attack ====================

        function groupAttack() {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                if (!_isAlive(mon)) {
                    _log(enc, "âš ï¸ Seu monstrinho estÃ¡ desmaiado. NÃ£o pode atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;

                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) {
                    _log(enc, "â„¹ï¸ NÃ£o hÃ¡ inimigos vivos para atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const d20 = rollD20();
                const atk = Number(mon.atk) || 0;
                const def = Number(enemy.def) || 0;

                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (d20 + atk >= def);

                const attackerName = player.name || player.nome || actor.name || "Jogador";
                const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                const enemyName = enemy.name || enemy.nome || "Inimigo";

                if (!hit) {
                    _log(enc, `ğŸ² ${attackerName} (${monName}) rolou ${d20} e ERROU o ataque em ${enemyName}.`);
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER bÃ¡sico
                const basicPower = Number(mon.basicPower) || Number(mon.powerBasic) || 10;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `ğŸ’¥ CRIT 20! ${monName} ativou Poder Duplo!`);
                }

                const dmg = _calcDamage(powerUsed, atk, def);
                enemy.hp = _clamp((Number(enemy.hp) || 0) - dmg, 0, Number(enemy.hpMax) || 999999);

                _log(enc, `ğŸ² ${attackerName} (${monName}) rolou ${d20} e acertou ${enemyName} causando ${dmg} de dano!`);

                if (!_isAlive(enemy)) {
                    _log(enc, `ğŸ ${enemyName} foi derrotado!`);
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to attack', error.stack);
            }
        }

        // ==================== FASE 3.B: Enemy AI ====================

        function processEnemyTurnGroup(enc) {
            try {
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'enemy') return;

                const enemy = _getEnemyByIndex(enc, actor.id);
                if (!enemy || !_isAlive(enemy)) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Escolhe alvo (menor HP%)
                const targetPid = _chooseTargetPlayerId(enc);
                if (!targetPid) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const targetPlayer = _getPlayerById(targetPid);
                const targetMon = _getActiveMonsterOfPlayer(targetPlayer);

                const enemyName = enemy.name || actor.name || "Inimigo";
                const targetName = targetPlayer?.name || targetPlayer?.nome || "Jogador";
                const targetMonName = targetMon?.nickname || targetMon?.name || targetMon?.nome || "Monstrinho";

                const d20 = rollD20();
                const atk = Number(enemy.atk) || 0;
                const def = Number(targetMon?.def) || 0;

                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (d20 + atk >= def);

                if (!hit) {
                    _log(enc, `ğŸ² ${enemyName} rolou ${d20} e ERROU o ataque em ${targetName} (${targetMonName}).`);
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER bÃ¡sico do inimigo
                const basicPower = Number(enemy.basicPower) || Number(enemy.powerBasic) || 10;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `ğŸ’¥ CRIT 20! ${enemyName} ativou Poder Duplo!`);
                }

                const dmg = _calcDamage(powerUsed, atk, def);
                targetMon.hp = _clamp((Number(targetMon.hp) || 0) - dmg, 0, Number(targetMon.hpMax) || 999999);

                _log(enc, `ğŸ² ${enemyName} rolou ${d20} e acertou ${targetName} (${targetMonName}) causando ${dmg} de dano!`);

                if (!_isAlive(targetMon)) {
                    _log(enc, `ğŸ’€ ${targetName} (${targetMonName}) foi derrotado!`);
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to process enemy turn', error.stack);
            }
        }

        // ==================== FASE 3.C: Skills and Items ====================

        function groupUseSkill(skillIndex) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon || !_isAlive(mon)) return;

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;
                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) return;

                _log(enc, "â„¹ï¸ (Ajuste) Sistema de habilidades serÃ¡ integrado na Feature 3.3");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use skill', error.stack);
            }
        }

        function groupUseItem(itemId) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                // Reutiliza lÃ³gica do 3.1
                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;

                if (hp <= 0) {
                    _log(enc, "âš ï¸ Monstrinho estÃ¡ desmaiado.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (hp >= hpMax) {
                    _log(enc, "â„¹ï¸ HP jÃ¡ estÃ¡ cheio.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (!itemId || itemId === 'IT_HEAL_01') {
                    itemId = 'IT_HEAL_01';
                }

                const itemCount = Number(player.inventory?.[itemId]) || 0;
                if (itemCount <= 0) {
                    _log(enc, "âš ï¸ VocÃª nÃ£o tem esse item.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Consumir item
                player.inventory[itemId] = Math.max(0, itemCount - 1);

                // Aplicar cura (mesmo do 3.1)
                const healAmount = Math.max(30, Math.floor(hpMax * 0.30));
                const newHp = Math.min(hpMax, hp + healAmount);
                const healed = newHp - hp;
                mon.hp = newHp;

                const playerName = player.name || "Jogador";
                const monName = mon.nickname || mon.name || "Monstrinho";

                _log(enc, `ğŸ’š ${playerName} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                _log(enc, `âœ¨ ${monName} recuperou ${healed} HP! (${mon.hp}/${hpMax})`);

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use item', error.stack);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FEATURE 3.3 - SISTEMA DE XP E LEVEL UP (com idempotÃªncia)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Garante que um monstro tenha campos de progressÃ£o (compatibilidade com saves antigos)
         */
        function ensureMonsterProgressFields(mon) {
            if (!mon) return;
            mon.level = Math.max(1, Number(mon.level) || 1);
            mon.xp = Math.max(0, Number(mon.xp) || 0);
            mon.xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
            // Fallback hpMax/maxHp
            if (mon.hpMax == null && mon.maxHp != null) mon.hpMax = mon.maxHp;
            if (mon.hp == null && mon.hpMax != null) mon.hp = mon.hpMax;
        }
        
        /**
         * Calcula XP necessÃ¡rio para prÃ³ximo nÃ­vel (curva suave)
         */
        function calcXpNeeded(level) {
            const L = Math.max(1, Number(level) || 1);
            return Math.round(40 + 6 * L + 0.6 * (L * L));
        }
        
        // Alias para compatibilidade
        function calculateXPNeeded(level) {
            return calcXpNeeded(level);
        }
        
        /**
         * Calcula XP ganho de uma batalha
         * @param {Object} defeatedEnemy - Inimigo derrotado
         * @param {string} encounterType - Tipo do encontro ('wild', 'group_trainer', 'boss')
         * @returns {number} - XP calculado
         */
        function calculateBattleXP(defeatedEnemy, encounterType) {
            const base = 15;
            const level = Math.max(1, Number(defeatedEnemy?.level) || 1);
            const rarity = defeatedEnemy?.rarity || defeatedEnemy?.raridade || null;
            
            // Multiplicador de raridade (com fallback)
            const rarityMult = Number(GameState.config.rarityXP?.[rarity]) || 1.0;
            
            let xp = Math.floor((base + level * 2) * rarityMult);
            
            // Boss bonus
            if (String(encounterType).toLowerCase() === 'boss') {
                xp = Math.floor(xp * 1.5);
            }
            
            return Math.max(1, xp);
        }
        
        /**
         * DÃ¡ XP para um monstro e processa level ups
         * @param {Object} mon - Monstro que receberÃ¡ XP
         * @param {number} amount - Quantidade de XP
         * @param {Array} logArr - Array de log (opcional, usa encounter.log se nÃ£o fornecido)
         */
        function giveXP(mon, amount, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            const xpGain = Math.max(0, Number(amount) || 0);
            if (xpGain <= 0) return;
            
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            mon.xp += xpGain;
            
            // Logar no array fornecido ou no encounter atual
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            if (Array.isArray(log)) {
                log.push(`ğŸ§ª ${name} ganhou +${xpGain} XP.`);
            }
            
            // Loop de level ups (pode subir mÃºltiplos nÃ­veis de uma vez)
            while (mon.xp >= mon.xpNeeded) {
                mon.xp -= mon.xpNeeded;
                levelUpMonster(mon, log);
            }
        }
        
        /**
         * Processa um level up para o monstro
         * @param {Object} mon - Monstro que vai subir de nÃ­vel
         * @param {Array} logArr - Array de log (opcional)
         */
        function levelUpMonster(mon, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            mon.level++;
            
            // Aumentar HP Max (fÃ³rmula oficial: hpMax * 1.04 + 2)
            const hpMax = Number(mon.hpMax) || Number(mon.maxHp) || 1;
            mon.hpMax = Math.floor(hpMax * 1.04 + 2);
            
            // Curar completamente ao subir de nÃ­vel
            mon.hp = mon.hpMax;
            
            // Recalcular stats baseado no novo nÃ­vel
            recalculateStatsFromTemplate(mon);
            
            // PrÃ³ximo XP necessÃ¡rio
            mon.xpNeeded = calcXpNeeded(mon.level);
            
            // Log com emoji especial
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            if (Array.isArray(log)) {
                log.push(`âœ¨ ${name} subiu para o nÃ­vel ${mon.level}!`);
            }
        }
        
        // Alias para compatibilidade
        function levelUp(mon) {
            return levelUpMonster(mon, GameState.currentEncounter?.log);
        }
        
        /**
         * Recalcula stats do monstro baseado no nÃ­vel e raridade (com fallbacks)
         * @param {Object} mon - Monstro para recalcular
         */
        function recalculateStatsFromTemplate(mon) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Buscar template base do catÃ¡logo (com mÃºltiplos fallbacks)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            if (!template) return; // NÃ£o quebra se nÃ£o encontrar
            
            // Obter raridade (com fallback)
            const rarity = template.rarity || template.raridade || mon.rarity || mon.raridade;
            
            // Multiplicadores
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (Math.max(1, mon.level) - 1) * 0.1;
            
            // Base stats (com mÃºltiplos fallbacks)
            const baseAtk = Number(template.baseAtk ?? template.atkBase ?? template.atk) || 0;
            const baseDef = Number(template.baseDef ?? template.defBase ?? template.def) || 0;
            const baseSpd = Number(template.baseSpd ?? template.spdBase ?? template.spd) || 0;
            
            // Recalcular stats (HP Ã© tratado separadamente em levelUpMonster)
            mon.atk = Math.floor(baseAtk * levelMult * rarityMult);
            mon.def = Math.floor(baseDef * levelMult * rarityMult);
            mon.spd = Math.floor(baseSpd * levelMult * rarityMult);
        }
        
        // Alias para compatibilidade
        function recalculateStats(mon) {
            return recalculateStatsFromTemplate(mon);
        }
        
        /**
         * Distribui XP para todos participantes vivos de uma batalha em grupo
         * @param {Object} enc - Encounter de grupo
         */
        function distributeGroupXP(enc) {
            if (!enc || !enc.rewards || !enc.rewards.xp) return;
            
            const xp = enc.rewards.xp;
            
            enc.participants.forEach(pid => {
                const player = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(player);
                
                // SÃ³ ganha XP se estiver vivo
                if (!mon || mon.hp <= 0) return;
                
                giveXP(mon, xp);
            });
        }
        
        /**
         * Distribui XP para o jogador de uma batalha wild (1v1)
         * @param {Object} encounter - Encounter wild
         */
        function distributeWildXP(encounter) {
            if (!encounter || !encounter.rewards || !encounter.rewards.xp) return;
            
            const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
            const mon = player?.team?.[0];
            
            // SÃ³ ganha XP se estiver vivo
            if (!mon || mon.hp <= 0) return;
            
            giveXP(mon, encounter.rewards.xp);
        }
        
        /**
         * Distribui recompensas de vitÃ³ria de forma idempotente (XP + recompensas futuras)
         * Previne duplicaÃ§Ã£o via flag rewardsGranted
         * @param {Object} enc - Encounter (wild ou group)
         */
        function handleVictoryRewards(enc) {
            if (!enc || enc.rewardsGranted) return;
            enc.rewardsGranted = true;
            
            enc.log = enc.log || [];
            
            // Determinar inimigo derrotado principal (primeiro inimigo)
            const defeated = (enc.enemies && enc.enemies[0]) ? enc.enemies[0] : enc.wildMonster;
            if (!defeated) {
                enc.log.push("â„¹ï¸ (XP) NÃ£o foi possÃ­vel identificar inimigo derrotado.");
                return;
            }
            
            // Calcular XP
            const xp = calculateBattleXP(defeated, enc.type);
            enc.rewards = enc.rewards || {};
            enc.rewards.xp = xp;
            enc.log.push(`ğŸ… Recompensa: ${xp} XP.`);
            
            // Distribuir XP baseado no tipo de batalha
            const isGroup = String(enc.type || '').includes("group") || 
                           String(enc.type || '').toLowerCase() === "boss" ||
                           enc.participants?.length > 0;
            
            if (isGroup) {
                // Grupo: cada participante vivo recebe XP completo
                for (const pid of (enc.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    const mon = p?.team?.[0];
                    if (!mon || (Number(mon.hp) || 0) <= 0) continue;
                    giveXP(mon, xp, enc.log);
                }
            } else {
                // 1v1: jogador atual (ou primeiro se nÃ£o especificado)
                let player = null;
                if (enc.selectedPlayerId || enc.currentPlayerId) {
                    player = GameState.players.find(p => 
                        p.id === (enc.selectedPlayerId || enc.currentPlayerId)
                    );
                }
                if (!player) player = GameState.players?.[0] || null;
                
                const mon = player?.team?.[0];
                if (mon && (Number(mon.hp) || 0) > 0) {
                    giveXP(mon, xp, enc.log);
                }
            }
        }
        
        function renderGroupEncounter(panel, encounter) {
            try {
                if (!encounter) return;
                
                const actor = getCurrentActor(encounter);
                const isPlayerTurn = actor && actor.side === 'player';
                
                let html = '<div class="encounter-panel">';
                html += renderTutorialBanner(encounter);
                html += '<h3>âš”ï¸ Batalha em Grupo</h3>';
                
                // Indicador de turno atual
                if (actor) {
                    const sideColor = actor.side === 'player' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${sideColor}; color: white; padding: 10px; margin: 10px 0; border-radius: 4px;">`;
                    html += `<strong>âºï¸ Turno: ${actor.name}</strong> (${actor.side === 'player' ? 'Jogador' : 'Inimigo'})`;
                    html += `</div>`;
                }
                
                // Participantes (jogadores)
                html += '<div style="margin: 15px 0;">';
                html += '<h4>ğŸ‘¥ Participantes:</h4>';
                for (const pid of (encounter.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    if (!p) continue;
                    
                    const mon = p.team?.[0];
                    if (!mon) continue;
                    
                    const hp = Number(mon.hp) || 0;
                    const hpMax = Number(mon.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    const isCurrent = actor && actor.side === 'player' && actor.id === pid;
                    
                    const border = isCurrent ? '3px solid #4CAF50' : '1px solid #ddd';
                    html += `<div style="background: #f5f5f5; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border};">`;
                    html += `<strong>${p.name || p.nome}</strong> (${p.class})`;
                    html += `<br>${mon.name || mon.nome} - Nv ${mon.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // Inimigos
                html += '<div style="margin: 15px 0;">';
                html += '<h4>ğŸ‘¹ Inimigos:</h4>';
                for (let i = 0; i < (encounter.enemies || []).length; i++) {
                    const e = encounter.enemies[i];
                    if (!e) continue;
                    
                    const hp = Number(e.hp) || 0;
                    const hpMax = Number(e.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    const isCurrent = actor && actor.side === 'enemy' && actor.id === i;
                    
                    const border = isCurrent ? '3px solid #f44336' : '1px solid #ddd';
                    html += `<div style="background: #ffebee; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border};">`;
                    html += `<strong>${e.name || e.nome}</strong> - Nv ${e.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `<br>SPD: ${e.spd} | ATK: ${e.atk} | DEF: ${e.def}`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // AÃ§Ãµes (apenas para turno do jogador)
                if (isPlayerTurn && !encounter.finished) {
                    html += '<div style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 4px;">';
                    html += '<h4>AÃ§Ãµes:</h4>';
                    html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">';
                    html += '<button class="btn btn-danger" onclick="groupAttack()">âš”ï¸ Atacar</button>';
                    html += '<button class="btn btn-primary" onclick="groupPassTurn()">â­ï¸ Passar</button>';
                    html += '<button class="btn btn-info" onclick="groupUseSkill(0)" disabled title="Feature 3.3">âœ¨ Habilidade</button>';
                    html += '<button class="btn btn-success" onclick="groupUseItem(\'IT_HEAL_01\')" disabled title="Feature 3.3">ğŸ’š Item</button>';
                    html += '</div>';
                    html += '</div>';
                }
                
                // Mensagem de fim com recompensas
                if (encounter.finished) {
                    const resultColor = encounter.result === 'victory' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${resultColor}; color: white; padding: 15px; margin: 15px 0; border-radius: 4px;">`;
                    html += `<h3>${encounter.result === 'victory' ? 'ğŸ VITÃ“RIA!' : 'ğŸ’€ DERROTA'}</h3>`;
                    
                    // Recompensas na vitÃ³ria
                    if (encounter.result === 'victory') {
                        html += '<div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.2); border-radius: 4px;">';
                        html += '<strong>ğŸ’° Recompensas:</strong><br>';
                        
                        // Dinheiro dividido
                        const totalCoins = Math.floor(Math.random() * 31) + 30; // 30-60
                        const coinsPerPlayer = Math.floor(totalCoins / encounter.participants.length);
                        
                        for (const pid of encounter.participants) {
                            const p = GameState.players.find(pl => pl.id === pid);
                            if (p) {
                                p.coins = (p.coins || 0) + coinsPerPlayer;
                                html += `${p.name}: +${coinsPerPlayer} moedas<br>`;
                            }
                        }
                        
                        html += '<br><em>â„¹ï¸ XP serÃ¡ implementado na Feature 3.3</em>';
                        html += '</div>';
                        saveToLocalStorage();
                    }
                    
                    html += `</div>`;
                    html += '<button class="btn btn-secondary" onclick="GameState.currentEncounter = null; saveToLocalStorage(); renderEncounter();">Fechar</button>';
                }
                
                // Log de combate
                html += '<div style="margin-top: 20px;">';
                html += '<h4>ğŸ“œ Log de Combate:</h4>';
                html += '<div style="background: #f9f9f9; padding: 10px; border-radius: 4px; max-height: 300px; overflow-y: auto;">';
                const logs = encounter.log || [];
                for (let i = Math.max(0, logs.length - 20); i < logs.length; i++) {
                    html += `<div>${logs[i]}</div>`;
                }
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                panel.innerHTML = html;
            } catch (error) {
                showError('Failed to render group encounter', error.stack);
            }
        }

        function renderEncounter() {
            try {
                const panel = document.getElementById('encounterPanel');
                if (!panel) return;
                
                const encounter = GameState.currentEncounter;
                
                if (!encounter || !encounter.active) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                if (encounter.type === 'wild') {
                    renderWildEncounter(panel, encounter);
                } else if (encounter.type === 'group_trainer' || encounter.type === 'boss') {
                    renderGroupEncounter(panel, encounter);
                } else {
                    panel.innerHTML = '<div class="encounter-panel"><h3>Encounter type not yet implemented</h3></div>';
                }
            } catch (error) {
                showError('Failed to render encounter', error.stack);
            }
        }

        function renderWildEncounter(panel, encounter) {
            try {
                const monster = encounter.wildMonster;
                if (!monster) return;
                
                // Buscar jogador selecionado
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                const playerMonster = player?.team?.[0];
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const canCapture = hpPercent <= baseThreshold;
                
                const html = `
                    <div class="encounter-panel">
                        ${renderTutorialBanner(encounter)}
                        <h3>Wild ${monster.emoji} ${monster.name} appeared!</h3>
                        ${player ? `<p><strong>Jogador:</strong> ${player.name} (${player.class})</p>` : ''}
                        ${playerMonster ? `
                        <div style="margin: 10px 0; padding: 10px; background: #e8f5e9; border-radius: 8px;">
                            <p><strong>Seu Monstrinho:</strong> ${playerMonster.emoji} ${playerMonster.name} (Nv ${playerMonster.level})</p>
                            <div><strong>HP:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                            <div><strong>âš¡ ENE:</strong> ${playerMonster.ene || 0}/${playerMonster.eneMax || 0}</div>
                        </div>
                        ` : ''}
                        
                        <div class="monster-card ${monster.class}" style="display: inline-block; margin: 20px;">
                            <div style="font-size: 48px;">${monster.emoji}</div>
                            <strong>${monster.name}</strong>
                            <div class="badge badge-${monster.rarity}">${monster.rarity}</div>
                            <div><strong>Classe:</strong> ${monster.class}</div>
                            <div><strong>Level:</strong> ${monster.level}</div>
                            <div style="margin-top: 8px;">
                                <div><strong>ATK:</strong> ${monster.atk} | <strong>DEF:</strong> ${monster.def}</div>
                                <div><strong>PODER:</strong> ${monster.poder}</div>
                                <div><strong>âš¡ ENE:</strong> ${monster.ene || 0}/${monster.eneMax || 0}</div>
                            </div>
                            <div class="progress-bar" style="margin-top: 10px;">
                                <div class="progress-fill hp" style="width: ${(monster.hp / monster.hpMax) * 100}%">
                                    ${monster.hp}/${monster.hpMax} HP (${Math.floor(hpPercent * 100)}%)
                                </div>
                            </div>
                            ${canCapture ? 
                                '<div style="color: green; margin-top: 5px;">âœ… HP baixo! Pode tentar captura!</div>' : 
                                `<div style="color: orange; margin-top: 5px;">âš ï¸ Abaixe HP para ${Math.floor(baseThreshold * 100)}% para capturar</div>`
                            }
                        </div>
                        
                        <h4>Choose Action:</h4>
                        <div class="flex-center" style="flex-direction: column;">
                            <div style="margin: 10px 0;">
                                <label style="font-weight: bold; font-size: 18px;">ğŸ² Enter your d20 roll:</label>
                                <input type="number" id="diceRoll" min="1" max="20" placeholder="1-20" 
                                       style="width: 120px; text-align: center; font-size: 24px; font-weight: bold; height: 60px; margin: 10px;">
                            </div>
                            
                            ${player ? (() => {
                                const comum = player.inventory?.['CLASTERORB_COMUM'] || 0;
                                const incomum = player.inventory?.['CLASTERORB_INCOMUM'] || 0;
                                const rara = player.inventory?.['CLASTERORB_RARA'] || 0;
                                const hasAnyOrb = comum > 0 || incomum > 0 || rara > 0;
                                
                                return `
                                <div style="margin: 15px 0; background: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #1976d2;">
                                    <strong style="font-size: 16px;">ğŸ¯ Sistema de Captura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>HP% Selvagem:</strong> ${Math.floor(hpPercent * 100)}%</div>
                                        <div><strong>Base Threshold (${monster.rarity}):</strong> ${Math.floor(baseThreshold * 100)}%</div>
                                        <div><strong>BÃ´nus HP Baixo (â‰¤25%):</strong> ${hpPercent <= 0.25 ? '+10%' : '0%'}</div>
                                    </div>
                                    
                                    ${hasAnyOrb ? `
                                    <div style="margin-top: 10px;">
                                        <label style="font-weight: bold;">Escolha sua ClasterOrb:</label>
                                        <select id="captureOrbSelect" onchange="updateCaptureThreshold()" style="width: 100%; padding: 8px; margin: 5px 0; font-size: 14px;">
                                            ${comum > 0 ? `<option value="CLASTERORB_COMUM">âšª Comum (${comum}x) - +0% bonus</option>` : ''}
                                            ${incomum > 0 ? `<option value="CLASTERORB_INCOMUM">ğŸ”µ Incomum (${incomum}x) - +5% bonus</option>` : ''}
                                            ${rara > 0 ? `<option value="CLASTERORB_RARA">ğŸŸ£ Rara (${rara}x) - +10% bonus</option>` : ''}
                                        </select>
                                    </div>
                                    <div id="captureThresholdDisplay" style="margin-top: 10px; padding: 10px; background: #fff; border-radius: 5px;">
                                        <strong>Threshold Final:</strong> <span id="finalThresholdValue">Calculando...</span>
                                    </div>
                                    ` : `
                                    <div style="margin-top: 10px; padding: 10px; background: #ffebee; color: #c62828; border-radius: 5px;">
                                        <strong>âŒ Sem ClasterOrbs!</strong><br>
                                        VocÃª nÃ£o tem orbes de captura disponÃ­veis.
                                    </div>
                                    `}
                                    
                                    <div style="margin-top: 10px;">
                                        <strong>ğŸ“¦ InventÃ¡rio:</strong> 
                                        âšª ${comum} | ğŸ”µ ${incomum} | ğŸŸ£ ${rara} | 
                                        ğŸ’š Cura: ${player.inventory?.['IT_HEAL_01'] || 0}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                            
                            <div class="flex-center">
                                ${player && (player.inventory?.['CLASTERORB_COMUM'] > 0 || player.inventory?.['CLASTERORB_INCOMUM'] > 0 || player.inventory?.['CLASTERORB_RARA'] > 0) ? 
                                    `<button class="btn btn-success btn-large" onclick="attemptCapture()" ${tutorialAllows("capture") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>ğŸ¯ Tentar Capturar</button>` :
                                    `<button class="btn btn-success btn-large" disabled style="opacity: 0.5;">ğŸ¯ Sem Orbes</button>`
                                }
                                <button class="btn btn-danger btn-large" onclick="attackWild()" ${tutorialAllows("attack") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>âš”ï¸ Attack</button>
                                <button class="btn btn-warning btn-large" onclick="fleeEncounter()" ${tutorialAllows("flee") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>ğŸƒ Flee</button>
                            </div>
                            
                            ${playerMonster && player ? (() => {
                                const healItems = player.inventory?.['IT_HEAL_01'] || 0;
                                const canUseItem = healItems > 0 && playerMonster.hp > 0 && playerMonster.hp < playerMonster.hpMax;
                                
                                return `
                                <div style="margin: 15px 0; padding: 15px; background: #e8f5e9; border-radius: 8px; border: 2px solid #4caf50;">
                                    <strong style="font-size: 16px;">ğŸ’š Usar Item de Cura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>Petisco de Cura disponÃ­vel:</strong> ${healItems}x</div>
                                        <div><strong>HP atual:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                                        ${!canUseItem && healItems === 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">âŒ Sem itens de cura disponÃ­veis</div>` : 
                                            !canUseItem && playerMonster.hp <= 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">âŒ Monstrinho desmaiado, nÃ£o pode usar item</div>` :
                                            !canUseItem && playerMonster.hp >= playerMonster.hpMax ?
                                            `<div style="color: #f57c00; margin-top: 5px;">âš ï¸ HP jÃ¡ estÃ¡ cheio</div>` : ''
                                        }
                                    </div>
                                    <button class="btn btn-primary" 
                                            onclick="useItemInBattle('IT_HEAL_01')"
                                            ${!canUseItem || !tutorialAllows("item") ? 'disabled style="opacity: 0.5;"' : ''}
                                            ${!tutorialAllows("item") ? 'title="Tutorial: ainda nÃ£o liberado"' : ''}
                                            style="margin-top: 10px; width: 100%;">
                                        ğŸ’š Usar Petisco de Cura
                                    </button>
                                </div>
                                `;
                            })() : ''}
                            
                            ${playerMonster ? (() => {
                                const skills = getMonsterSkills(playerMonster);
                                if (!skills || skills.length === 0) return '';
                                
                                return `
                                <div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 8px;">
                                    <strong style="font-size: 16px;">âœ¨ Habilidades</strong>
                                    <div class="flex-center" style="margin-top: 10px; gap: 10px;">
                                        ${skills.map((skill, idx) => {
                                            if (!skill) return '';
                                            const canUse = (playerMonster.ene || 0) >= skill.cost;
                                            const tutAllows = tutorialAllows("skill");
                                            return `
                                            <button class="btn btn-primary" 
                                                    onclick="useSkillWild(${idx})" 
                                                    ${!canUse || !tutAllows ? 'disabled style="opacity: 0.5;"' : ''}
                                                    title="${!tutAllows ? 'Tutorial: ainda nÃ£o liberado' : skill.desc}">
                                                ${skill.name}<br>
                                                <small>(-${skill.cost} ENE)</small>
                                            </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                        </div>
                        
                        <div class="combat-log" id="combatLog" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px; max-height: 300px; overflow-y: auto;">
                            ${(encounter.log || []).map(entry => `<div style="margin: 5px 0; padding: 5px; border-bottom: 1px solid #ddd;">${entry}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                panel.innerHTML = html;
                
                // Atualizar threshold inicial
                setTimeout(() => updateCaptureThreshold(), 100);
            } catch (error) {
                showError('Failed to render wild encounter', error.stack);
            }
        }

        // Atualizar cÃ¡lculo de threshold de captura em tempo real
        function updateCaptureThreshold() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const select = document.getElementById('captureOrbSelect');
                const display = document.getElementById('finalThresholdValue');
                if (!select || !display) return;
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) return;
                
                // Calcular threshold
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const orbBonus = orbInfo.capture_bonus_pp / 100; // Converter pp para decimal
                const lowHpBonus = hpPercent <= 0.25 ? 0.10 : 0;
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                // Atualizar display
                display.innerHTML = `
                    <span style="font-size: 18px; color: ${hpPercent <= thresholdFinal ? '#2e7d32' : '#c62828'}; font-weight: bold;">
                        ${Math.floor(thresholdFinal * 100)}%
                    </span>
                    <br><small>
                        (Base ${Math.floor(baseThreshold * 100)}% + Orb ${orbInfo.capture_bonus_pp}% + HP ${Math.floor(lowHpBonus * 100)}%)
                        <br>${hpPercent <= thresholdFinal ? 'âœ… Captura provÃ¡vel!' : 'âŒ HP muito alto'}
                    </small>
                `;
            } catch (error) {
                console.error('Failed to update capture threshold:', error);
            }
        }

        function attemptCapture() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                // ValidaÃ§Ã£o: HP > 0 obrigatÃ³rio
                if (monster.hp <= 0) {
                    alert('âŒ NÃ£o pode capturar um monstrinho desmaiado! HP deve ser > 0.');
                    return;
                }
                
                // Obter ClasterOrb selecionada
                const select = document.getElementById('captureOrbSelect');
                if (!select) {
                    alert('âŒ Erro ao ler seleÃ§Ã£o de ClasterOrb.');
                    return;
                }
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) {
                    alert('âŒ ClasterOrb invÃ¡lida.');
                    return;
                }
                
                // ValidaÃ§Ã£o: precisa ter a orb selecionada
                player.inventory = player.inventory || {};
                const orbCount = player.inventory[selectedOrbId] || 0;
                
                if (orbCount <= 0) {
                    alert(`âŒ VocÃª nÃ£o tem ${orbInfo.name}!`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // SEMPRE CONSOME 1 item (mesmo se falhar)
                player.inventory[selectedOrbId]--;
                encounter.log.push(`${orbInfo.emoji} ${player.name} usou ${orbInfo.name}! (Restam: ${player.inventory[selectedOrbId]})`);
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                
                // BÃ´nus se HP <= 25%
                let lowHpBonus = 0;
                if (hpPercent <= 0.25) {
                    lowHpBonus = 0.10;
                    encounter.log.push(`âœ¨ HP crÃ­tico! BÃ´nus de +10% na captura!`);
                }
                
                // BÃ´nus da orb (em decimal: 0, 0.05, 0.10)
                const orbBonus = orbInfo.capture_bonus_pp / 100;
                
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                encounter.log.push(`HP: ${Math.floor(hpPercent * 100)}% | Base: ${Math.floor(baseThreshold * 100)}% | Orb: +${orbInfo.capture_bonus_pp}% | HP Bonus: +${Math.floor(lowHpBonus * 100)}%`);
                encounter.log.push(`ğŸ¯ Threshold Final: ${Math.floor(thresholdFinal * 100)}%`);
                
                // Captura determinÃ­stica: sucesso se HP% <= Threshold_final
                if (hpPercent <= thresholdFinal) {
                    encounter.log.push(`âœ… SUCESSO! ${monster.name} foi capturado!`);
                    
                    monster.ownerId = player.id;
                    
                    player.team = player.team || [];
                    player.box = player.box || [];
                    
                    if (player.team.length < (GameState.config?.maxTeamSize || 6)) {
                        player.team.push(monster);
                        encounter.log.push(`${monster.name} foi adicionado ao time de ${player.name}!`);
                    } else {
                        player.box.push(monster);
                        encounter.log.push(`${monster.name} foi enviado para a caixa de ${player.name}!`);
                    }
                    
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                    
                    // Feature 4.2: Tutorial hook
                    tutorialOnAction("capture");
                    
                    encounter.active = false;
                    GameState.currentEncounter = null;
                } else {
                    // FALHA: Monstrinho realiza 1 ataque bÃ¡sico IMEDIATO
                    encounter.log.push(`âŒ FALHA! ${monster.name} quebrou livre!`);
                    
                    const playerMonster = player.team?.[0];
                    if (playerMonster && playerMonster.hp > 0) {
                        encounter.log.push(`âš¡ ${monster.name} contra-ataca!`);
                        
                        // Monstrinho selvagem ataca imediatamente
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, monster, playerMonster);
                        encounter.log.push(`ğŸ² ${monster.name} rola ${enemyRoll} (ATK: ${monster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(monster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${monster.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${monster.name} erra o ataque!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Capture attempt failed', error.stack);
            }
        }

        // Feature 3.1: Usar Item em Batalha
        function useItemInBattle(itemId) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('Nenhum jogador selecionado para este encontro');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Jogador nÃ£o tem monstrinhos no time');
                    return;
                }
                
                // VALIDAÃ‡Ã•ES (GAME_RULES.md)
                
                // 1. Validar HP > 0 (monstrinho nÃ£o desmaiado)
                if (playerMonster.hp <= 0) {
                    alert('âŒ NÃ£o pode usar item! Monstrinho estÃ¡ desmaiado (HP = 0).');
                    return;
                }
                
                // 2. Validar HP < HPMax (nÃ£o usar se jÃ¡ estÃ¡ cheio)
                if (playerMonster.hp >= playerMonster.hpMax) {
                    alert('âš ï¸ HP jÃ¡ estÃ¡ no mÃ¡ximo! NÃ£o Ã© necessÃ¡rio usar item de cura.');
                    return;
                }
                
                // 3. Validar item disponÃ­vel no inventÃ¡rio
                player.inventory = player.inventory || {};
                const itemCount = player.inventory[itemId] || 0;
                
                if (itemCount <= 0) {
                    alert('âŒ VocÃª nÃ£o tem Petisco de Cura disponÃ­vel!');
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // CONSUMIR 1 unidade do item
                player.inventory[itemId]--;
                encounter.log.push(`ğŸ’š ${player.name} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                
                // APLICAR CURA
                // Petisco de Cura: restaura 30 HP ou 30% do HP mÃ¡ximo (o que for maior)
                const healAmount = Math.max(30, Math.floor(playerMonster.hpMax * 0.30));
                const hpBefore = playerMonster.hp;
                playerMonster.hp = Math.min(playerMonster.hpMax, playerMonster.hp + healAmount);
                const actualHeal = playerMonster.hp - hpBefore;
                
                encounter.log.push(`âœ¨ ${playerMonster.name} recuperou ${actualHeal} HP! (${playerMonster.hp}/${playerMonster.hpMax})`);
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("item");
                
                // SALVAR ESTADO
                saveToLocalStorage();
                
                // INIMIGO ATACA (contra-ataque automÃ¡tico apÃ³s usar item)
                if (encounter.wildMonster.hp > 0) {
                    encounter.log.push(`âš”ï¸ Vez do inimigo...`);
                    
                    const wildMonster = encounter.wildMonster;
                    
                    // Aplicar ENE regen do inimigo
                    applyEneRegen(wildMonster, encounter);
                    
                    // Atualizar buffs do inimigo
                    updateBuffs(wildMonster);
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const wildSkills = getMonsterSkills(wildMonster);
                    const canUseSkill = wildSkills && wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                    const shouldUseSkill = canUseSkill && Math.random() < 0.5;
                    
                    if (shouldUseSkill) {
                        const skill = wildSkills[0];
                        wildMonster.ene -= skill.cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                        
                        // Usar habilidade
                        useSkill(wildMonster, skill, playerMonster, encounter);
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, wildMonster, playerMonster));
                        
                        if (enemyHit) {
                            const power = BASIC_ATTACK_POWER[wildMonster.class] || 12;
                            
                            const atkMods = getBuffModifiers(wildMonster);
                            const effectiveAtk = Math.max(1, wildMonster.atk + atkMods.atk);
                            
                            const defMods = getBuffModifiers(playerMonster);
                            const effectiveDef = Math.max(1, playerMonster.def + defMods.def);
                            
                            const classAdv = GameState.config?.classAdvantages?.[wildMonster.class];
                            let damageMult = 1.0;
                            if (classAdv?.strong === playerMonster.class) {
                                damageMult = 1.10;
                            } else if (classAdv?.weak === playerMonster.class) {
                                damageMult = 0.90;
                            }
                            
                            const damage = calcDamage({
                                atk: effectiveAtk,
                                def: effectiveDef,
                                power: power,
                                damageMult: damageMult
                            });
                            
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Verificar se jogador perdeu
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ’€ ${playerMonster.name} fainted! Defeat!`);
                                encounter.active = false;
                                GameState.currentEncounter = null;
                                saveToLocalStorage();
                                renderEncounter();
                                return;
                            }
                        } else {
                            if (enemyRoll === 1) {
                                encounter.log.push(`ğŸ’€ FALHA CRÃTICA! ${wildMonster.name} erra!`);
                            } else {
                                encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                            }
                        }
                    }
                }
                
                // RENDER atualizado
                saveToLocalStorage();
                renderEncounter();
                
            } catch (error) {
                showError('Failed to use item in battle', error.stack);
            }
        }

        function attackWild() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Player has no monsters in team');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho Ã© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`âš ï¸ VocÃª sÃ³ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} Ã© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Get dice roll from input field
                const diceInput = document.getElementById('diceRoll');
                const playerRoll = parseInt(diceInput?.value || '0');
                
                if (playerRoll < 1 || playerRoll > 20) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                
                // Clear the input for next roll
                if (diceInput) diceInput.value = '';
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno do jogador
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs (reduzir duraÃ§Ã£o)
                updateBuffs(playerMonster);
                
                // CRIT 20 ou FALHA 1 (GAME_RULES.md)
                let isCrit20 = false;
                let isFail1 = false;
                let critBonus = null;
                
                if (playerRoll === 20) {
                    isCrit20 = true;
                    encounter.log.push(`â­ CRÃTICO 20! â­`);
                    // Escolher bÃ´nus aleatÃ³rio
                    const bonusRoll = Math.floor(Math.random() * 3);
                    if (bonusRoll === 0) {
                        critBonus = 'double_power';
                        encounter.log.push(`ğŸ’¥ Poder dobrado neste ataque!`);
                    } else if (bonusRoll === 1) {
                        critBonus = 'item';
                        player.inventory = player.inventory || {};
                        player.inventory['IT_HEAL_01'] = (player.inventory['IT_HEAL_01'] || 0) + 1;
                        encounter.log.push(`ğŸ Ganhou 1 Petisco de Cura!`);
                    } else {
                        critBonus = 'money';
                        const moneyGain = 20 + Math.floor(Math.random() * 31); // 20-50
                        player.money = (player.money || 0) + moneyGain;
                        encounter.log.push(`ğŸ’° Ganhou ${moneyGain} moedas!`);
                    }
                } else if (playerRoll === 1) {
                    isFail1 = true;
                }
                
                // Fase 1: Ataque do jogador
                encounter.log.push(`ğŸ² ${player.name}'s ${playerMonster.name} rolls ${playerRoll} (ATK: ${playerMonster.atk})`);
                
                // d20=1 sempre erra, d20=20 sempre acerta
                const playerHit = isFail1 ? false : (isCrit20 ? true : checkHit(playerRoll, playerMonster, encounter.wildMonster));
                
                if (playerHit) {
                    // Calcular dano com power modificado se CRIT 20
                    let power = BASIC_ATTACK_POWER[playerMonster.class] || 12;
                    if (isCrit20 && critBonus === 'double_power') {
                        power *= 2; // Dobrar POWER antes do cÃ¡lculo
                    }
                    
                    // Calcular dano com nova fÃ³rmula
                    const atkMods = getBuffModifiers(playerMonster);
                    const effectiveAtk = Math.max(1, playerMonster.atk + atkMods.atk);
                    
                    const defMods = getBuffModifiers(encounter.wildMonster);
                    const effectiveDef = Math.max(1, encounter.wildMonster.def + defMods.def);
                    
                    const classAdv = GameState.config?.classAdvantages?.[playerMonster.class];
                    let damageMult = 1.0;
                    if (classAdv?.strong === encounter.wildMonster.class) {
                        damageMult = 1.10;
                    } else if (classAdv?.weak === encounter.wildMonster.class) {
                        damageMult = 0.90;
                    }
                    
                    const damage = calcDamage({
                        atk: effectiveAtk,
                        def: effectiveDef,
                        power: power,
                        damageMult: damageMult
                    });
                    
                    encounter.wildMonster.hp = Math.max(0, encounter.wildMonster.hp - damage);
                    encounter.log.push(`ğŸ’¥ ${playerMonster.name} hits! Deals ${damage} damage!`);
                    
                    // Feature 4.2: Tutorial hook
                    tutorialOnAction("attack");
                    
                    if (encounter.wildMonster.hp <= 0) {
                        encounter.log.push(`ğŸ† ${encounter.wildMonster.name} fainted! Victory!`);
                        
                        // Feature 3.3: Distribuir recompensas (XP) com idempotÃªncia
                        handleVictoryRewards(encounter);
                        
                        encounter.active = false;
                        GameState.currentEncounter = null;
                        saveToLocalStorage();
                        renderEncounter();
                        return;
                    }
                } else {
                    if (isFail1) {
                        encounter.log.push(`ğŸ’€ FALHA CRÃTICA! Ataque erra automaticamente!`);
                    } else {
                        encounter.log.push(`âŒ ${playerMonster.name} misses!`);
                    }
                }
                
                // Fase 2: Contra-ataque do monstrinho selvagem (se ainda vivo)
                if (encounter.wildMonster.hp > 0) {
                    const wildMonster = encounter.wildMonster;
                    const wildSkill = wildMonster.skill;
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const useSkill = wildSkill && (wildMonster.ene || 0) >= wildSkill.energy_cost && Math.random() < 0.5;
                    
                    if (useSkill) {
                        wildMonster.ene -= wildSkill.energy_cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${wildSkill.name}! (-${wildSkill.energy_cost} ENE)`);
                        
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll}`);
                        
                        if (enemyHit) {
                            const baseDamage = wildMonster.atk + wildSkill.power - playerMonster.def;
                            const damage = Math.max(1, baseDamage);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildSkill.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildSkill.name} erra!`);
                        }
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² Wild ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(wildMonster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Attack failed', error.stack);
            }
        }

        // Usar habilidade contra o selvagem (por Ã­ndice 0, 1, 2)
        function useSkillWild(skillIndex) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('No monster available');
                    return;
                }
                
                // Obter habilidades disponÃ­veis
                const skills = getMonsterSkills(playerMonster);
                if (!skills || skillIndex >= skills.length || !skills[skillIndex]) {
                    alert('Skill not available');
                    return;
                }
                
                const skill = skills[skillIndex];
                
                // Validar ENE suficiente
                if ((playerMonster.ene || 0) < skill.cost) {
                    alert(`âŒ ENE insuficiente! Precisa de ${skill.cost} ENE.`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs
                updateBuffs(playerMonster);
                
                // Usar habilidade
                const success = useSkill(playerMonster, skill, encounter.wildMonster, encounter);
                
                if (!success) {
                    alert('Failed to use skill');
                    return;
                }
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("skill");
                
                // Verificar se o selvagem foi derrotado
                if (encounter.wildMonster.hp <= 0) {
                    encounter.log.push(`ğŸ† ${encounter.wildMonster.name} foi derrotado!`);
                    const xpGained = calculateBattleXP(encounter.wildMonster);
                    giveXp(playerMonster, xpGained);
                    encounter.log.push(`âœ¨ ${playerMonster.name} ganhou ${xpGained} XP!`);
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }
                
                // Fase 2: Contra-ataque do selvagem
                const wildMonster = encounter.wildMonster;
                
                // Atualizar buffs do selvagem
                updateBuffs(wildMonster);
                
                // IA: 50% chance de usar habilidade se tiver ENE
                const wildSkills = getMonsterSkills(wildMonster);
                const canUseSkill = wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                const useWildSkill = canUseSkill && Math.random() < 0.5;
                
                if (useWildSkill) {
                    // Selvagem usa habilidade
                    useSkill(wildMonster, wildSkills[0], playerMonster, encounter);
                    
                    if (playerMonster.hp <= 0) {
                        encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                        playerMonster.status = 'fainted';
                        encounter.active = false;
                        GameState.currentEncounter = null;
                    }
                } else {
                    // Ataque bÃ¡sico do selvagem
                    const enemyRoll = Math.floor(Math.random() * 20) + 1;
                    const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                    encounter.log.push(`ğŸ² ${wildMonster.name} rola ${enemyRoll} (ATK: ${wildMonster.atk})`);
                    
                    if (enemyHit) {
                        const mods = getBuffModifiers(wildMonster);
                        const effectiveAtk = wildMonster.atk + mods.atk;
                        const damage = calculateDamage(wildMonster, playerMonster);
                        playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                        encounter.log.push(`ğŸ’¥ ${wildMonster.name} acerta! Causa ${damage} de dano!`);
                        
                        if (playerMonster.hp <= 0) {
                            encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                            playerMonster.status = 'fainted';
                            encounter.active = false;
                            GameState.currentEncounter = null;
                        }
                    } else {
                        encounter.log.push(`âŒ ${wildMonster.name} erra!`);
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Skill use failed', error.stack);
            }
        }

        // Verifica acerto: d20 + ATK >= DEF
        function checkHit(d20Roll, attacker, defender) {
            try {
                if (!attacker || !defender) return false;
                
                const atkMod = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +2 ATK se forte, -2 ATK se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let atkBonus = 0;
                if (classAdv?.strong === defender.class) {
                    atkBonus = 2;
                } else if (classAdv?.weak === defender.class) {
                    atkBonus = -2;
                }
                
                const totalAtk = d20Roll + atkMod + atkBonus;
                return totalAtk >= defValue;
            } catch (error) {
                console.error('Hit check failed:', error);
                return false;
            }
        }

        // Calcula dano: max(1, ATK + PODER - DEF) com modificadores de classe
        // Nova fÃ³rmula de dano (v1)
        function calcDamage({ atk, def, power, damageMult = 1.0 }) {
            try {
                // ratio = ATK / (ATK + DEF)
                const ratio = atk / (atk + def);
                
                // danoBase = floor(POWER * ratio)
                const baseD = Math.floor(power * ratio);
                
                // Aplicar multiplicador de classe
                const finalD = Math.floor(baseD * damageMult);
                
                // Dano mÃ­nimo sempre 1
                return Math.max(1, finalD);
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        // Wrapper para compatibilidade - calcula dano com ataque bÃ¡sico
        function calculateDamage(attacker, defender) {
            try {
                if (!attacker || !defender) return 1;
                
                const atkValue = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // POWER bÃ¡sico por classe
                const basicPower = BASIC_ATTACK_POWER[attacker.class] || 12;
                
                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(attacker);
                const effectiveAtk = Math.max(1, atkValue + atkMods.atk);
                
                const defMods = getBuffModifiers(defender);
                const effectiveDef = Math.max(1, defValue + defMods.def);
                
                // Vantagem de classe: +10% dano se forte, -10% dano se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let damageMult = 1.0;
                if (classAdv?.strong === defender.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === defender.class) {
                    damageMult = 0.90;
                }
                
                return calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: basicPower,
                    damageMult: damageMult
                });
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        // Calcula XP de batalha
        function calculateBattleXP(defeatedMonster) {
            try {
                const baseXP = GameState.config?.battleXpBase || 15;
                const levelMod = (defeatedMonster.level || 1) * 2;
                const rarityMod = GameState.config?.rarityXP?.[defeatedMonster.rarity] || 1.0;
                
                return Math.floor((baseXP + levelMod) * rarityMod);
            } catch (error) {
                console.error('XP calculation failed:', error);
                return 15;
            }
        }

        function giveXp(monster, amount) {
            try {
                if (!monster) return;
                
                monster.xp = (monster.xp || 0) + amount;
                
                // FÃ³rmula de XP por nÃ­vel conforme AGENTS.md: Math.round(40 + 6*L + 0.6*(L*L))
                const xpNeeded = Math.round(40 + 6 * monster.level + 0.6 * (monster.level * monster.level));
                
                while (monster.xp >= xpNeeded && monster.level < (GameState.config?.maxLevel || 100)) {
                    monster.xp -= xpNeeded;
                    monster.level++;
                    
                    // Recalcula stats baseado no novo nÃ­vel
                    const template = MONSTER_CATALOG.find(m => m?.id === monster.monsterId);
                    if (template) {
                        const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                        const levelMult = (1 + (monster.level - 1) * 0.1);
                        
                        // HP aumenta: hpMax * 1.04 + 2 conforme AGENTS.md
                        const oldHpMax = monster.hpMax;
                        monster.hpMax = Math.floor(monster.hpMax * 1.04 + 2);
                        // HP atual aumenta proporcionalmente
                        const hpRatio = monster.hp / oldHpMax;
                        monster.hp = Math.floor(monster.hpMax * hpRatio);
                        
                        // Recalcula ATK, DEF, PODER
                        monster.atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                        monster.def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                        monster.poder = Math.floor(monster.atk * 0.5);
                    }
                }
                
                saveToLocalStorage();
            } catch (error) {
                console.error('Failed to give XP:', error);
            }
        }

        function fleeEncounter() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter) return;
                
                if (confirm('Flee from this encounter?')) {
                    encounter.log = encounter.log || [];
                    encounter.log.push('ğŸƒ Fled from encounter');
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    
                    saveToLocalStorage();
                    renderEncounter();
                }
            } catch (error) {
                showError('Flee failed', error.stack);
            }
        }

        function getCurrentPlayer() {
            try {
                if (!GameState.currentSession) return null;
                
                const turnIndex = GameState.currentSession.currentTurnIndex || 0;
                const playerId = GameState.currentSession.turnOrder?.[turnIndex];
                
                return GameState.players?.find(p => p?.id === playerId) || null;
            } catch (error) {
                console.error('Failed to get current player:', error);
                return null;
            }
        }

        // THERAPY MANAGEMENT
        function addObjective() {
            try {
                const text = document.getElementById('newObjective')?.value?.trim();
                const weight = parseInt(document.getElementById('objectiveWeight')?.value || '1');
                
                if (!text) {
                    alert('Please enter objective description');
                    return;
                }
                
                const objective = {
                    id: Date.now(),
                    text: text,
                    weight: weight
                };
                
                GameState.objectives = GameState.objectives || [];
                GameState.objectives.push(objective);
                
                document.getElementById('newObjective').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add objective', error.stack);
            }
        }

        function toggleObjectiveForPlayer(playerId, objectiveId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                therapy.completedObjectives = therapy.completedObjectives || [];
                
                const index = therapy.completedObjectives.indexOf(objectiveId);
                if (index > -1) {
                    therapy.completedObjectives.splice(index, 1);
                } else {
                    therapy.completedObjectives.push(objectiveId);
                }
                
                therapy.pm = 0;
                therapy.completedObjectives.forEach(objId => {
                    const obj = GameState.objectives?.find(o => o?.id === objId);
                    if (obj) {
                        therapy.pm += obj.weight || 0;
                    }
                });
                
                updateMedals(playerId);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to toggle objective', error.stack);
            }
        }

        function updateMedals(playerId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                const pm = therapy.pm || 0;
                const tiers = GameState.config?.medalTiers || { bronze: 10, silver: 25, gold: 50 };
                
                therapy.medals = therapy.medals || [];
                
                if (pm >= tiers.gold && !therapy.medals.includes('gold')) {
                    therapy.medals.push('gold');
                } else if (pm >= tiers.silver && !therapy.medals.includes('silver')) {
                    therapy.medals.push('silver');
                } else if (pm >= tiers.bronze && !therapy.medals.includes('bronze')) {
                    therapy.medals.push('bronze');
                }
            } catch (error) {
                console.error('Failed to update medals:', error);
            }
        }

        // UI UPDATE FUNCTIONS
        function updateAllViews() {
            try {
                updateHomeStats();
                updatePlayersList();
                updateSessionView();
                updateTherapyView();
                updateReportView();
                updateEncounterPlayerDropdown();
                updateEncounterUI();
                renderEncounter();
            } catch (error) {
                console.error('Failed to update views:', error);
            }
        }

        function updateEncounterPlayerDropdown() {
            try {
                const select = document.getElementById('encounterPlayer');
                if (!select) return;
                
                select.innerHTML = '<option value="">-- Select Player --</option>';
                
                if (GameState.players && GameState.players.length > 0) {
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.name} (${player.class || 'No class'})`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to update encounter player dropdown:', error);
            }
        }
        
        function updateEncounterUI() {
            try {
                const type = document.getElementById('encounterType')?.value;
                const playerSelectDiv = document.getElementById('playerSelectDiv');
                const groupSelectDiv = document.getElementById('groupSelectDiv');
                
                if (!playerSelectDiv || !groupSelectDiv) return;
                
                if (type === 'wild') {
                    playerSelectDiv.classList.remove('hidden');
                    groupSelectDiv.classList.add('hidden');
                } else if (type === 'trainer' || type === 'boss') {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.remove('hidden');
                    updateGroupParticipantsList();
                } else {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.add('hidden');
                }
            } catch (error) {
                console.error('Failed to update encounter UI:', error);
            }
        }
        
        function updateGroupParticipantsList() {
            try {
                const container = document.getElementById('groupParticipantsList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p style="color: #666;">No players available. Add players first.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const mon = player.team?.[0];
                    const monName = mon ? (mon.name || mon.nome || 'No monster') : 'No monster';
                    const hasValidMonster = mon && mon.hp > 0;
                    
                    html += `<div style="padding: 5px;">`;
                    html += `<label style="cursor: pointer; display: flex; align-items: center;">`;
                    html += `<input type="checkbox" name="groupParticipant" value="${player.id}" ${!hasValidMonster ? 'disabled' : ''}>`;
                    html += `<span style="margin-left: 8px;">${player.name} (${player.class})`;
                    if (hasValidMonster) {
                        html += ` - ${monName} Nv${mon.level}`;
                    } else {
                        html += ` - <span style="color: #999;">No valid monster</span>`;
                    }
                    html += `</span>`;
                    html += `</label>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update group participants list:', error);
            }
        }

        function updateHomeStats() {
            try {
                const statPlayers = document.getElementById('statPlayers');
                const statMonsters = document.getElementById('statMonsters');
                const statSession = document.getElementById('statSession');
                
                if (statPlayers) statPlayers.textContent = GameState.players?.length || 0;
                if (statMonsters) statMonsters.textContent = GameState.monsters?.length || 0;
                if (statSession) statSession.textContent = GameState.currentSession ? 'Yes' : 'No';
            } catch (error) {
                console.error('Failed to update home stats:', error);
            }
        }

        function updatePlayersList() {
            try {
                const container = document.getElementById('playersList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<div class="card"><p>No players yet. Add one above!</p></div>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const teamCount = player.team?.length || 0;
                    const boxCount = player.box?.length || 0;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <div class="badge badge-${player.playerClassId}">${player.playerClassId}</div>
                            <p>ğŸ’° Money: ${player.money || 0} | â­ Afterlife: ${player.afterlifeCurrency || 0}</p>
                            <p>ğŸ‘¥ Team: ${teamCount}/${GameState.config?.maxTeamSize || 6} | ğŸ“¦ Box: ${boxCount}</p>
                            
                            <h4>Team:</h4>
                            <div class="flex">
                                ${(player.team || []).map(m => renderMonsterCard(m)).join('')}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update players list:', error);
            }
        }

        function renderMonsterCard(monster) {
            try {
                if (!monster) return '';
                
                const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                const xpNeeded = (monster.level || 1) * 100;
                const xpPercent = ((monster.xp || 0) / xpNeeded) * 100;
                
                return `
                    <div class="monster-card ${monster.class || 'common'}">
                        <div style="font-size: 36px;">${monster.emoji || 'ğŸ”®'}</div>
                        <strong>${monster.name || 'Unknown'}</strong>
                        <div class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'common'}</div>
                        <div>Lv ${monster.level || 1}</div>
                        <div class="progress-bar" style="height: 20px;">
                            <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                        </div>
                        <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                        <div class="progress-bar" style="height: 15px;">
                            <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                        </div>
                        <small>${monster.xp || 0}/${xpNeeded} XP</small>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to render monster card:', error);
                return '<div class="monster-card">Error</div>';
            }
        }

        function updateSessionView() {
            try {
                const panel = document.getElementById('activeSessionPanel');
                if (!panel) return;
                
                if (!GameState.currentSession) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                const session = GameState.currentSession;
                document.getElementById('activeSessionName').textContent = session.name || 'Unnamed';
                document.getElementById('sessionCreated').textContent = new Date(session.createdAt).toLocaleString();
                
                const turnList = document.getElementById('turnOrderList');
                if (turnList) {
                    let html = '<div class="flex">';
                    (session.turnOrder || []).forEach((playerId, index) => {
                        const player = GameState.players?.find(p => p?.id === playerId);
                        if (player) {
                            const isCurrent = index === (session.currentTurnIndex || 0);
                            html += `
                                <div class="stat-box" style="${isCurrent ? 'background: var(--success); color: white;' : ''}">
                                    ${isCurrent ? 'â–¶ ' : ''}${player.name}
                                </div>
                            `;
                        }
                    });
                    html += '</div>';
                    turnList.innerHTML = html;
                }
            } catch (error) {
                console.error('Failed to update session view:', error);
            }
        }

        function updateTherapyView() {
            try {
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    let html = '<h4>Current Objectives:</h4>';
                    (GameState.objectives || []).forEach(obj => {
                        if (!obj) return;
                        html += `
                            <div class="objective-item">
                                <strong>Weight ${obj.weight}:</strong> ${obj.text}
                            </div>
                        `;
                    });
                    objectivesList.innerHTML = html;
                }
                
                const therapyPlayersList = document.getElementById('therapyPlayersList');
                if (!therapyPlayersList) return;
                
                if (!GameState.currentSession) {
                    therapyPlayersList.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                let html = '';
                (GameState.players || []).forEach(player => {
                    if (!player) return;
                    
                    const therapy = GameState.currentSession.therapy?.perPlayer?.[player.id];
                    if (!therapy) return;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <p><strong>PM (Merit Points):</strong> ${therapy.pm || 0}</p>
                            <p><strong>Medals:</strong> 
                                ${(therapy.medals || []).map(m => {
                                    const emoji = { bronze: 'ğŸ¥‰', silver: 'ğŸ¥ˆ', gold: 'ğŸ¥‡' }[m] || 'ğŸ…';
                                    return `<span class="medal">${emoji}</span>`;
                                }).join('')}
                            </p>
                            
                            <h4>Objectives:</h4>
                            ${(GameState.objectives || []).map(obj => {
                                if (!obj) return '';
                                const completed = therapy.completedObjectives?.includes(obj.id);
                                return `
                                    <div class="objective-item">
                                        <input type="checkbox" 
                                               ${completed ? 'checked' : ''}
                                               onchange="toggleObjectiveForPlayer(${player.id}, ${obj.id})"
                                               style="width: 30px; height: 30px; cursor: pointer;">
                                        <span>${obj.text} (${obj.weight} PM)</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                });
                
                therapyPlayersList.innerHTML = html;
            } catch (error) {
                console.error('Failed to update therapy view:', error);
            }
        }

        function updateReportView() {
            try {
                const container = document.getElementById('reportContent');
                if (!container) return;
                
                if (!GameState.currentSession) {
                    container.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                const session = GameState.currentSession;
                
                let html = `
                    <div class="card">
                        <h3>Session: ${session.name}</h3>
                        <p>Started: ${new Date(session.createdAt).toLocaleString()}</p>
                        ${session.completedAt ? `<p>Ended: ${new Date(session.completedAt).toLocaleString()}</p>` : '<p>Status: Active</p>'}
                    </div>
                    
                    <div class="card">
                        <h3>Player Summary</h3>
                        ${(GameState.players || []).map(player => {
                            if (!player) return '';
                            const therapy = session.therapy?.perPlayer?.[player.id];
                            if (!therapy) return '';
                            
                            return `
                                <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 10px;">
                                    <h4>${player.name}</h4>
                                    <p>PM Earned: ${therapy.pm || 0}</p>
                                    <p>Medals: ${(therapy.medals || []).join(', ') || 'None yet'}</p>
                                    <p>Objectives Completed: ${therapy.completedObjectives?.length || 0}/${GameState.objectives?.length || 0}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update report view:', error);
            }
        }

        // DATA MANAGEMENT
        function exportData() {
            try {
                const data = JSON.stringify(GameState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                showError('Export failed', error.stack);
            }
        }

        function importData() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target?.files?.[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target?.result || '{}');
                            Object.assign(GameState, data);
                            saveToLocalStorage();
                            updateAllViews();
                            alert('Data imported successfully!');
                        } catch (error) {
                            showError('Import failed', error.stack);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError('Import failed', error.stack);
            }
        }

        function clearAllData() {
            try {
                if (confirm('Are you sure? This will delete ALL data!')) {
                    if (confirm('Really sure? This cannot be undone!')) {
                        localStorage.removeItem('monstrinhomon_state');
                        location.reload();
                    }
                }
            } catch (error) {
                showError('Clear data failed', error.stack);
            }
        }

        function toggleTherapistMode() {
            try {
                const checked = document.getElementById('therapistMode')?.checked;
                const configPanel = document.getElementById('configPanel');
                if (configPanel) {
                    if (checked) {
                        configPanel.classList.remove('hidden');
                    } else {
                        configPanel.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle therapist mode:', error);
            }
        }

        // ===== Feature 4.0: Menu / Flow =====
        const MM_SAVE_KEY = "monstrinhomon_state"; // Using the same key as the existing save system
        const MM_MIN_PLAYERS = 1;
        const MM_MAX_PLAYERS = 6;
        const MM_MAX_PLAYER_NAME_LENGTH = 14;

        function mmEl(id){ return document.getElementById(id); }

        function mmCloseAllOverlays(){
            ["mmIntro","mmMenu","mmNewGame","mmConfig"].forEach(id => mmEl(id)?.classList.remove("show"));
        }

        function mmShow(id){
            mmCloseAllOverlays();
            mmEl(id)?.classList.add("show");
        }

        function mmHasSave(){
            try {
                const data = localStorage.getItem(MM_SAVE_KEY);
                if (!data) return false;
                const parsed = JSON.parse(data);
                // Consider it a valid save if it has players or sessions
                return (parsed.players && parsed.players.length > 0) || 
                       (parsed.sessions && parsed.sessions.length > 0);
            } catch(e){ 
                return false; 
            }
        }

        function mmBoot(){
            // Show intro on boot
            mmShow("mmIntro");
        }

        function mmShowMainMenu(){
            mmShow("mmMenu");
            const btn = mmEl("mmBtnContinue");
            const ok = mmHasSave();
            if (btn) {
                btn.disabled = !ok;
                btn.textContent = ok ? "ğŸ“– Continuar" : "ğŸ“– Continuar (sem save)";
            }
        }

        function mmShowConfig(){
            mmShow("mmConfig");
        }

        function mmContinue(){
            try {
                loadFromLocalStorage();
                updateAllViews();
            } catch(e){
                console.warn("mmContinue failed", e);
                alert("NÃ£o foi possÃ­vel carregar o jogo salvo. Por favor, tente novamente ou comece um novo jogo.");
            }
            mmCloseAllOverlays();
        }

        function mmResetSaveConfirm(){
            const ok = confirm("Apagar o save do navegador? Isso nÃ£o pode ser desfeito.");
            if (!ok) return;
            try {
                localStorage.removeItem(MM_SAVE_KEY);
                alert("Save apagado com sucesso!");
            } catch(e){
                alert("NÃ£o foi possÃ­vel apagar o save. Por favor, tente novamente.");
            }
            mmShowMainMenu();
        }

        // ---- New Game Wizard (MVP) ----
        const MM_NEW = {
            step: 0,
            numPlayers: 1,
            difficulty: "medium",
            players: [] // {name, class}
        };

        const MM_CLASSES = ["Guerreiro","Mago","Curandeiro","BÃ¡rbaro","Ladino","Bardo","CaÃ§ador","Animalista"];

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function mmStartNewGame(){
            MM_NEW.step = 0;
            MM_NEW.numPlayers = 1;
            MM_NEW.difficulty = "medium";
            MM_NEW.players = [];
            mmShow("mmNewGame");
            mmRenderNewGameStep();
        }

        function mmRenderNewGameStep(){
            const host = mmEl("mmNewGameStep");
            if (!host) return;

            if (MM_NEW.step === 0) {
                host.innerHTML = `
                    <p class="mm-sub">Quantos jogadores?</p>
                    <div class="mm-field">
                        <label>NÃºmero de jogadores (1â€“6)</label>
                        <input id="mmNumPlayers" type="number" min="1" max="6" value="${MM_NEW.numPlayers}">
                        <div class="mm-hint">Dica: em grupo, cada jogador usa monstrinhos da prÃ³pria classe.</div>
                    </div>
                `;
                return;
            }

            if (MM_NEW.step === 1) {
                host.innerHTML = `
                    <p class="mm-sub">Selecione a dificuldade</p>
                    <div class="mm-field">
                        <label>Dificuldade</label>
                        <select id="mmDifficulty">
                            <option value="easy" ${MM_NEW.difficulty==="easy"?"selected":""}>FÃ¡cil</option>
                            <option value="medium" ${MM_NEW.difficulty==="medium"?"selected":""}>MÃ©dio</option>
                            <option value="hard" ${MM_NEW.difficulty==="hard"?"selected":""}>DifÃ­cil</option>
                        </select>
                        <div class="mm-hint">MVP: afeta encontros futuros conforme seu sistema de difficulty.</div>
                    </div>
                `;
                return;
            }

            // Step 2: players
            if (MM_NEW.step === 2) {
                // Ajusta o array de jogadores para corresponder ao nÃºmero selecionado
                while (MM_NEW.players.length < MM_NEW.numPlayers) {
                    MM_NEW.players.push({ name: "", class: MM_CLASSES[0] });
                }
                while (MM_NEW.players.length > MM_NEW.numPlayers) {
                    MM_NEW.players.pop();
                }

                const rows = MM_NEW.players.map((p, i) => `
                    <div style="border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:12px; margin:10px 0;">
                        <div style="font-weight:900; margin-bottom:8px;">Jogador ${i+1}</div>
                        <div class="mm-field">
                            <label>Nome</label>
                            <input id="mmPName_${i}" maxlength="${MM_MAX_PLAYER_NAME_LENGTH}" placeholder="Ex.: Ana" value="${escapeHtml(p.name || "")}">
                        </div>
                        <div class="mm-field">
                            <label>Classe</label>
                            <select id="mmPClass_${i}">
                                ${MM_CLASSES.map(c => `<option value="${escapeHtml(c)}" ${p.class===c?"selected":""}>${escapeHtml(c)}</option>`).join("")}
                            </select>
                        </div>
                    </div>
                `).join("");

                host.innerHTML = `
                    <p class="mm-sub">Crie os jogadores</p>
                    ${rows}
                    <p class="mm-hint">O monstrinho inicial deve seguir a classe do jogador (MVP).</p>
                `;
                return;
            }

            // Step 3: confirm
            if (MM_NEW.step === 3) {
                host.innerHTML = `
                    <p class="mm-sub">Tudo pronto!</p>
                    <div style="opacity:0.9; line-height:1.45;">
                        <div><b>Jogadores:</b> ${MM_NEW.numPlayers}</div>
                        <div><b>Dificuldade:</b> ${escapeHtml(MM_NEW.difficulty)}</div>
                        <div style="margin-top:8px;">
                            ${MM_NEW.players.map(p => `â€¢ ${escapeHtml(p.name || "Sem nome")} â€” ${escapeHtml(p.class)}`).join("<br/>")}
                        </div>
                    </div>
                    <button class="mm-btn" onclick="mmFinishNewGame()">ğŸš€ ComeÃ§ar Aventura</button>
                    <p class="mm-hint">Isso criarÃ¡ uma nova sessÃ£o e sobrescreverÃ¡ o save atual.</p>
                `;
            }
        }

        function mmNewGameBack(){
            if (MM_NEW.step === 0) { mmShowMainMenu(); return; }
            MM_NEW.step = Math.max(0, MM_NEW.step - 1);
            mmRenderNewGameStep();
        }

        function mmNewGameNext(){
            // Captura inputs do passo atual
            if (MM_NEW.step === 0) {
                const n = Number(mmEl("mmNumPlayers")?.value || MM_MIN_PLAYERS);
                MM_NEW.numPlayers = Math.max(MM_MIN_PLAYERS, Math.min(MM_MAX_PLAYERS, n));
            }
            if (MM_NEW.step === 1) {
                MM_NEW.difficulty = String(mmEl("mmDifficulty")?.value || "medium");
            }
            if (MM_NEW.step === 2) {
                for (let i=0;i<MM_NEW.players.length;i++){
                    const name = String(mmEl(`mmPName_${i}`)?.value || "").trim();
                    const playerClass = String(mmEl(`mmPClass_${i}`)?.value || MM_CLASSES[0]);
                    MM_NEW.players[i] = { name, class: playerClass };
                }
            }

            MM_NEW.step = Math.min(3, MM_NEW.step + 1);
            mmRenderNewGameStep();
        }

        function mmFinishNewGame(){
            try {
                // Valida e auto-preenche nomes vazios com padrÃ£o 'Jogador N'
                MM_NEW.players = MM_NEW.players.map((p, idx) => ({
                    name: p.name?.trim() ? p.name.trim() : `Jogador ${idx+1}`,
                    class: p.class || MM_CLASSES[0]
                }));

                // Clear existing state
                GameState.players = [];
                GameState.monsters = [];
                GameState.sessions = [];
                GameState.currentSession = null;
                GameState.currentEncounter = null;

                // Create players
                MM_NEW.players.forEach((p, idx) => {
                    const playerId = `p_${Date.now()}_${idx}`;
                    
                    // Busca monstrinho inicial da mesma classe do jogador
                    // Fallback: usa o primeiro monstrinho do catÃ¡logo se nÃ£o encontrar match
                    const starterTemplate = MONSTER_CATALOG.find(m => 
                        m.class && p.class && m.class.toLowerCase() === p.class.toLowerCase()
                    ) || MONSTER_CATALOG[0];
                    
                    if (!starterTemplate) {
                        console.warn(`No starter monster found for player ${p.name} (${p.class})`);
                    }
                    
                    // Create the starter monster instance
                    const starterMonster = createMonsterInstance(starterTemplate, playerId, 1);
                    
                    const player = {
                        id: playerId,
                        name: p.name,
                        class: p.class,
                        team: starterMonster ? [starterMonster] : [],
                        box: [],
                        inventory: {
                            'Monstribola': 5,
                            'PoÃ§Ã£o': 3
                        }
                    };
                    
                    GameState.players.push(player);
                    
                    // Also add to GameState.monsters for compatibility
                    if (starterMonster) {
                        GameState.monsters.push(starterMonster);
                    }
                });

                // Save difficulty
                if (!GameState.config) GameState.config = {};
                GameState.config.difficulty = MM_NEW.difficulty;

                // Save to localStorage (main save system)
                saveToLocalStorage();
                
                // Feature 4.3: Auto-save to chosen slot
                const slot = Number(GameState?.saveSlot || localStorage.getItem("mm_last_slot") || 1);
                if (typeof mmWriteSlot === "function" && typeof mmBuildSaveEnvelope === "function") {
                    mmWriteSlot(slot, mmBuildSaveEnvelope());
                    showToast(`ğŸ’¾ Novo jogo salvo no Slot ${slot}!`);
                } else {
                    showToast("âœ… Novo jogo criado!");
                }
                
                // Update UI
                updateAllViews();
                
                console.log('New game created successfully!', GameState);
                
            } catch(e) {
                console.error("mmFinishNewGame failed", e);
                alert("NÃ£o foi possÃ­vel criar o jogo. Por favor, tente novamente.");
            }

            mmCloseAllOverlays();
        }

        // ===== Feature 4.2: Tutorial (Optional) =====
        const TUTORIAL_STEPS = [
            {
                id: "tut_attack",
                title: "Tutorial 1/3 â€” Ataque bÃ¡sico",
                instructions: "Clique em ATACAR 2 vezes para vencer.",
                required: { attack: 2 },
                lock: { attack:true, skill:false, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Attack()
            },
            {
                id: "tut_skill",
                title: "Tutorial 2/3 â€” Habilidades",
                instructions: "Use 1 habilidade (gasta ENE) para vencer.",
                required: { skill: 1 },
                lock: { attack:true, skill:true, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Skill()
            },
            {
                id: "tut_capture",
                title: "Tutorial 3/3 â€” Captura",
                instructions: "Abaixe o HP do inimigo atÃ© ficar baixo e capture com ClasterOrb.",
                required: { capture: 1 },
                lock: { attack:true, skill:true, item:false, capture:true, flee:false, pass:false },
                start: () => startTutorialEncounter_Capture()
            }
        ];

        function ensureTutorialState() {
            if (!window.GameState) window.GameState = {};
            if (!GameState.tutorial) GameState.tutorial = { active:false, stepIndex:0, done:{} };
            if (!GameState.tutorial.done) GameState.tutorial.done = {};
            return GameState.tutorial;
        }

        function getTutorialStep() {
            const tut = ensureTutorialState();
            if (!tut.active) return null;
            return TUTORIAL_STEPS[tut.stepIndex] || null;
        }

        function mmStartTutorial() {
            const tut = ensureTutorialState();
            
            // Se nÃ£o hÃ¡ jogadores, precisa criar um jogo primeiro
            if (!GameState.players || GameState.players.length === 0) {
                alert("Por favor, crie um novo jogo primeiro!");
                return;
            }
            
            const restart = !tut.active ? true : confirm("Continuar tutorial atual? (OK = continuar / Cancelar = reiniciar)");
            if (!restart) {
                tut.active = false;
                tut.stepIndex = 0;
                tut.done = {};
            }
            tut.active = true;
            
            // Inicia step atual
            const step = TUTORIAL_STEPS[tut.stepIndex] || TUTORIAL_STEPS[0];
            mmCloseAllOverlays();
            step.start();
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
        }

        function exitTutorial() {
            const tut = ensureTutorialState();
            tut.active = false;
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            showToast("ğŸ‘‹ Tutorial encerrado!");
        }

        function renderTutorialBanner(enc) {
            const step = getTutorialStep();
            if (!step) return "";
            const tut = ensureTutorialState();
            const done = tut.done || {};
            const req = step.required || {};
            const lines = Object.keys(req).map(k => {
                const v = req[k];
                const cur = done[k] || 0;
                return `â€¢ ${k}: ${cur}/${v}`;
            }).join("<br/>");

            return `
                <div style="padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.15); background:rgba(255,255,255,0.06); margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                        <div style="font-weight:900;">ğŸ“ ${step.title}</div>
                        <button class="btn" style="width:auto; margin:0; padding:8px 10px;" onclick="exitTutorial()">Sair</button>
                    </div>
                    <div style="opacity:0.9; margin-top:6px;">${step.instructions}</div>
                    <div style="opacity:0.8; margin-top:6px; font-size:12px;">${lines}</div>
                </div>
            `;
        }

        function tutorialAllows(actionKey) {
            const step = getTutorialStep();
            if (!step) return true;
            const lock = step.lock || {};
            // Se nÃ£o definido, permite
            if (typeof lock[actionKey] === "undefined") return true;
            return !!lock[actionKey];
        }

        function tutorialOnAction(type) {
            const step = getTutorialStep();
            if (!step) return;

            const tut = ensureTutorialState();
            tut.done[type] = (tut.done[type] || 0) + 1;

            // Checa se completou
            const req = step.required || {};
            const ok = Object.keys(req).every(k => (tut.done[k] || 0) >= req[k]);

            if (ok) {
                showToast("ğŸ‰ Passo concluÃ­do!");
                
                // Se Ã© o Ãºltimo step
                if (tut.stepIndex === TUTORIAL_STEPS.length - 1) {
                    tut.active = false;
                    showToast("ğŸ Tutorial completo!");
                    if (typeof saveToLocalStorage === "function") saveToLocalStorage();
                    return;
                }
                
                // AvanÃ§a para prÃ³ximo step
                tut.stepIndex = Math.min(TUTORIAL_STEPS.length - 1, tut.stepIndex + 1);
                tut.done = {}; // Reseta contadores do prÃ³ximo step

                const next = getTutorialStep();
                if (next) {
                    setTimeout(() => {
                        next.start();
                    }, 1500); // Pequeno delay para o usuÃ¡rio ver a mensagem
                }
            }

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
        }

        function createTutorialEnemy(level) {
            // Tenta pegar um template real do catÃ¡logo
            const cat = MONSTER_CATALOG || [];
            const t = cat[0];
            if (typeof createMonsterInstance === "function" && t) {
                const m = createMonsterInstance(t, null, level);
                // Deixa mais fÃ¡cil
                m.hpMax = Math.max(20, Math.floor(m.hpMax * 0.6));
                m.hp = m.hpMax;
                return m;
            }
            // Fallback mÃ­nimo
            return { 
                id: Date.now() + Math.random(),
                name:"Treinomon", 
                level, 
                hpMax: 25+level*5, 
                hp: 25+level*5, 
                atk: 4+level, 
                def: 3+level, 
                spd: 5, 
                ene: 0, 
                eneMax: 0,
                class: "Guerreiro",
                rarity: "Comum",
                emoji: "ğŸ¾",
                poder: 6
            };
        }

        function startTutorialEncounter_Attack() {
            const player = GameState.players?.[0];
            if (!player) {
                alert("Nenhum jogador disponÃ­vel para o tutorial!");
                return;
            }
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(1),
                log: ["ğŸ“ Tutorial: Encontro de Ataque", "Ataque 2 vezes para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Skill() {
            const player = GameState.players?.[0];
            if (!player) return;
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(2),
                log: ["ğŸ“ Tutorial: Encontro de Habilidades", "Use 1 habilidade para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Capture() {
            const player = GameState.players?.[0];
            if (!player) return;

            // Garante 1 orb no inventÃ¡rio (para nÃ£o travar tutorial)
            player.inventory = player.inventory || {};
            const orbId = "CLASTERORB_COMUM";
            player.inventory[orbId] = Math.max(1, Number(player.inventory[orbId] || 0));

            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(3),
                log: ["ğŸ“ Tutorial: Encontro de Captura", "Abaixe o HP e capture o monstrinho!"],
                rewardsGranted: false,
                active: true
            };

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        // Toast notification system
        function showToast(message, duration = 3000) {
            // Remove existing toasts
            const existing = document.querySelectorAll('.mm-toast');
            existing.forEach(t => t.remove());
            
            const toast = document.createElement('div');
            toast.className = 'mm-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ===== Feature 4.3: Save Slots + Export/Import =====
        const MM_SAVE_KEYS = {
            1: "mm_save_slot_1",
            2: "mm_save_slot_2",
            3: "mm_save_slot_3",
        };
        const MM_LEGACY_KEYS = [
            "monstrinhomon_state", "mm_save", "GameState", "mm_state"
        ];
        const MM_MIGRATED_FLAG = "mm_slots_migrated_v1";

        function mmOpenSaves() {
            mmMigrateLegacySaveToSlot1();
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSavesScreen");
            mmRenderSavesScreen();
            
            // Bind import file input once
            const fileInput = document.getElementById("mmImportFile");
            if (fileInput && !fileInput._bound) {
                fileInput._bound = true;
                fileInput.addEventListener("change", (e) => mmHandleImportFile(e));
            }
        }

        function mmCloseSaves() {
            mmHideOverlay("mmSavesScreen");
            mmShowMainMenu();
        }

        function mmShowOverlay(id) {
            const el = document.getElementById(id);
            if (el) el.classList.remove("hidden");
        }

        function mmHideOverlay(id) {
            const el = document.getElementById(id);
            if (el) el.classList.add("hidden");
        }

        function mmReadSlot(slot) {
            const key = MM_SAVE_KEYS[slot];
            if (!key) return null;
            const raw = localStorage.getItem(key);
            if (!raw) return null;
            try { 
                return JSON.parse(raw); 
            } catch { 
                return null; 
            }
        }

        function mmWriteSlot(slot, saveObj) {
            const key = MM_SAVE_KEYS[slot];
            if (!key) return false;
            try {
                localStorage.setItem(key, JSON.stringify(saveObj));
                return true;
            } catch (e) {
                console.error("Failed to write slot", slot, e);
                return false;
            }
        }

        function mmBuildSaveEnvelope() {
            // Create snapshot of current state
            const payload = {
                version: "mm_slot_v1",
                timestamp: Date.now(),
                sessionName: GameState?.currentSession?.name || "SessÃ£o",
                playersCount: Array.isArray(GameState?.players) ? GameState.players.length : 0,
                state: JSON.parse(JSON.stringify(GameState)) // Deep copy
            };
            return payload;
        }

        function mmSaveToSlot(slot) {
            if (!confirm(`Salvar o jogo atual no Slot ${slot}? Isso vai sobrescrever.`)) return;
            const env = mmBuildSaveEnvelope();
            if (mmWriteSlot(slot, env)) {
                showToast(`ğŸ’¾ Salvo no Slot ${slot}!`);
                mmRenderSavesScreen();
            } else {
                alert("Falha ao salvar no slot.");
            }
        }

        function mmLoadFromSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env || !env.state) {
                alert("Slot vazio ou invÃ¡lido.");
                return;
            }
            if (!confirm(`Carregar Slot ${slot}? Isso substitui o estado atual.`)) return;
            
            try {
                GameState = env.state;
                saveToLocalStorage();  // Update the main save too
                
                // Update all views
                if (typeof updateAllViews === "function") updateAllViews();
                if (typeof renderEncounter === "function") renderEncounter();
                
                showToast(`ğŸ“‚ Carregado do Slot ${slot}!`);
                mmCloseSaves();
                mmCloseAllOverlays();
            } catch (e) {
                console.error("Failed to load from slot", e);
                alert("Erro ao carregar o slot.");
            }
        }

        function mmDeleteSlot(slot) {
            if (!confirm(`Deletar Slot ${slot}? Esta aÃ§Ã£o nÃ£o pode ser desfeita.`)) return;
            localStorage.removeItem(MM_SAVE_KEYS[slot]);
            showToast(`ğŸ—‘ï¸ Slot ${slot} deletado.`);
            mmRenderSavesScreen();
        }

        function mmExportSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env) { 
                alert("Slot vazio."); 
                return; 
            }
            
            try {
                const blob = new Blob([JSON.stringify(env, null, 2)], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `monstrinhomon_slot_${slot}_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                showToast(`â¬‡ï¸ Exportado Slot ${slot}.`);
            } catch (e) {
                console.error("Failed to export slot", e);
                alert("Erro ao exportar o slot.");
            }
        }

        function mmHandleImportFile(e) {
            const fileInput = e.target;
            const file = fileInput.files?.[0];
            if (!file) return;

            const slotPick = document.getElementById("mmImportSlotPick");
            const slot = Number(slotPick?.value || 1);

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const obj = JSON.parse(String(reader.result || ""));
                    if (!obj || !obj.state) {
                        throw new Error("JSON invÃ¡lido (sem state).");
                    }
                    
                    if (mmWriteSlot(slot, obj)) {
                        showToast(`â¬†ï¸ Importado para Slot ${slot}!`);
                        mmRenderSavesScreen();
                    } else {
                        throw new Error("Falha ao gravar no slot.");
                    }
                } catch (err) {
                    console.error("Import failed", err);
                    alert("Falha ao importar: " + (err?.message || err));
                } finally {
                    fileInput.value = ""; // Reset file input
                }
            };
            reader.readAsText(file);
        }

        function mmRenderSavesScreen() {
            const host = document.getElementById("mmSavesSlots");
            if (!host) return;

            const slotHtml = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>SessÃ£o:</b> ${escapeHtml(env.sessionName || "SessÃ£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot">
                        <h3>Slot ${slot}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmLoadFromSlot(${slot})">ğŸ“‚ Carregar</button>
                            <button class="mm-btn" style="width:auto;" onclick="mmSaveToSlot(${slot})">ğŸ’¾ Salvar aqui</button>
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmExportSlot(${slot})">â¬‡ï¸ Exportar</button>
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmDeleteSlot(${slot})">ğŸ—‘ï¸ Deletar</button>
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = slotHtml;
        }

        // Slot Picker functions for New Game flow
        function mmGetLastSlot() {
            const n = Number(localStorage.getItem("mm_last_slot") || "1");
            return [1, 2, 3].includes(n) ? n : 1;
        }

        function mmOpenSlotPickerForNewGame() {
            mmMigrateLegacySaveToSlot1(); // Ensure migration happens first
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSlotPicker");
            mmRenderSlotPicker();
        }

        function mmCancelSlotPicker() {
            mmHideOverlay("mmSlotPicker");
            mmShowMainMenu();
        }

        function mmRenderSlotPicker() {
            const host = document.getElementById("mmSlotPickerList");
            if (!host) return;

            const last = mmGetLastSlot();
            const cards = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>SessÃ£o:</b> ${escapeHtml(env.sessionName || "SessÃ£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot" style="${slot === last ? "outline:2px solid rgba(160,120,255,0.8);" : ""}">
                        <h3 style="margin:0 0 6px 0;">Slot ${slot} ${slot === last ? "â­" : ""}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn" style="width:auto;"
                                onclick="mmChooseSlotAndStartNewGame(${slot})">
                                âœ… Usar este slot
                            </button>
                            ${empty ? "" : `
                                <button class="mm-btn" style="width:auto;"
                                    onclick="mmChooseSlotAndStartNewGame(${slot}, true)">
                                    ğŸ§¨ Sobrescrever
                                </button>
                            `}
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = cards;
        }

        function mmChooseSlotAndStartNewGame(slot, force = false) {
            const env = mmReadSlot(slot);
            const occupied = !!(env && env.state);

            if (occupied && !force) {
                alert("Este slot jÃ¡ tem um save. Clique em 'Sobrescrever' ou escolha outro slot.");
                return;
            }
            if (occupied && force) {
                const ok = confirm(`Sobrescrever o Slot ${slot}?`);
                if (!ok) return;
            }

            // Store chosen slot
            if (!window.GameState) window.GameState = {};
            GameState.saveSlot = slot;
            localStorage.setItem("mm_last_slot", String(slot));

            mmHideOverlay("mmSlotPicker");
            // Call existing wizard from Feature 4.0
            mmStartNewGame();
        }

        function mmMigrateLegacySaveToSlot1() {
            // Migrate once: legacy save -> slot1 if slot1 is empty
            if (localStorage.getItem(MM_MIGRATED_FLAG) === "1") return;

            const slot1 = mmReadSlot(1);
            if (slot1 && slot1.state) {
                // Slot 1 already has data, mark as migrated
                localStorage.setItem(MM_MIGRATED_FLAG, "1");
                return;
            }

            // Try to find legacy save
            for (const key of MM_LEGACY_KEYS) {
                const raw = localStorage.getItem(key);
                if (!raw) continue;

                try {
                    const parsed = JSON.parse(raw);
                    
                    // Check if it's already an envelope or raw GameState
                    const env = (parsed && parsed.state) ? parsed : {
                        version: "mm_slot_v1",
                        timestamp: Date.now(),
                        sessionName: parsed?.currentSession?.name || "SessÃ£o",
                        playersCount: Array.isArray(parsed?.players) ? parsed.players.length : 0,
                        state: parsed
                    };
                    
                    if (mmWriteSlot(1, env)) {
                        showToast("âœ… Save antigo migrado para Slot 1!");
                        break;
                    }
                } catch (e) {
                    console.warn("Failed to migrate legacy save from key:", key, e);
                    // Continue to next key
                }
            }

            localStorage.setItem(MM_MIGRATED_FLAG, "1");
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            init(); // Call the existing init function
            mmBoot(); // Show the intro overlay
        });
    </script>
</body>
</html>
