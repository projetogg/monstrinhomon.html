<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Monstrinhomon - Therapeutic Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --fire-color: #ff6b35; --water-color: #4ecdc4; --plant-color: #95e06c; --electric-color: #ffe66d;
            --primary: #6c5ce7; --secondary: #fd79a8; --success: #00b894; --warning: #fdcb6e;
            --danger: #d63031; --dark: #2d3436; --light: #dfe6e9;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--dark); min-height: 100vh; overflow-x: hidden;
        }
        
        .app-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .error-panel {
            position: fixed; top: 0; left: 0; right: 0; background: #d63031; color: white;
            padding: 15px; z-index: 10000; display: none; font-family: monospace; font-size: 14px;
        }
        .error-panel.show { display: block; }
        .error-panel button {
            background: white; color: #d63031; border: none; padding: 8px 15px; margin: 5px;
            border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;
        }
        
        .header {
            background: white; border-radius: 20px; padding: 20px; margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header h1 { color: var(--primary); font-size: 2.5em; text-align: center; margin-bottom: 10px; }
        
        .tabs {
            display: flex; gap: 10px; overflow-x: auto; padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab-button {
            background: var(--light); border: none; padding: 15px 25px; border-radius: 15px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;
            white-space: nowrap; min-width: 100px; min-height: 44px;
        }
        .tab-button.active {
            background: var(--primary); color: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }
        
        .tab-content {
            display: none; background: white; border-radius: 20px; padding: 25px;
            min-height: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tab-content.active { display: block; animation: fadeIn 0.3s; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .btn {
            background: var(--primary); color: white; border: none; padding: 15px 30px;
            border-radius: 12px; font-size: 16px; font-weight: bold; cursor: pointer;
            transition: all 0.3s; min-height: 44px; min-width: 44px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-success { background: var(--success); }
        .btn-danger { background: var(--danger); }
        .btn-warning { background: var(--warning); color: var(--dark); }
        .btn-secondary { background: var(--secondary); }
        .btn-large { font-size: 20px; padding: 20px 40px; }
        
        input, select, textarea {
            width: 100%; padding: 12px; border: 2px solid var(--light); border-radius: 10px;
            font-size: 16px; margin: 8px 0; min-height: 44px;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        
        .card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px; padding: 20px; margin: 15px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .monster-card {
            display: inline-block; width: 150px; margin: 10px; padding: 15px;
            border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .monster-card:active { transform: scale(0.95); }
        .monster-card.fire { background: linear-gradient(135deg, #ff6b35 0%, #ff8c61 100%); }
        .monster-card.water { background: linear-gradient(135deg, #4ecdc4 0%, #7ee0d7 100%); }
        .monster-card.plant { background: linear-gradient(135deg, #95e06c 0%, #b3eb93 100%); }
        .monster-card.electric { background: linear-gradient(135deg, #ffe66d 0%, #fff09c 100%); }
        
        .progress-bar {
            width: 100%; height: 30px; background: var(--light); border-radius: 15px;
            overflow: hidden; position: relative; margin: 10px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--success) 0%, #00b894 100%);
            transition: width 0.5s; display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px;
        }
        .progress-fill.hp { background: linear-gradient(90deg, #d63031 0%, #ff7675 100%); }
        .progress-fill.xp { background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%); }
        
        .badge {
            display: inline-block; padding: 5px 12px; border-radius: 20px;
            font-size: 12px; font-weight: bold; margin: 2px;
        }
        .badge-common { background: #95a5a6; color: white; }
        .badge-rare { background: #3498db; color: white; }
        .badge-epic { background: #9b59b6; color: white; }
        .badge-legendary { background: #f39c12; color: white; }
        .badge-fire { background: var(--fire-color); color: white; }
        .badge-water { background: var(--water-color); color: white; }
        .badge-plant { background: var(--plant-color); color: white; }
        .badge-electric { background: var(--electric-color); color: var(--dark); }
        
        .encounter-panel {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-radius: 20px; padding: 25px; margin: 20px 0;
        }
        
        .combat-log {
            background: white; border-radius: 15px; padding: 15px; max-height: 300px;
            overflow-y: auto; font-family: monospace; font-size: 14px;
        }
        .combat-log div { padding: 5px 0; border-bottom: 1px solid var(--light); }
        
        .therapist-panel {
            border: 3px dashed var(--warning); border-radius: 20px; padding: 20px;
            margin: 20px 0; background: #fffbea;
        }
        
        .objective-item {
            display: flex; align-items: center; gap: 10px; padding: 15px;
            background: white; border-radius: 10px; margin: 10px 0;
        }
        
        .medal { font-size: 48px; display: inline-block; margin: 10px; }
        .hidden { display: none !important; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex-center { display: flex; justify-content: center; align-items: center; gap: 15px; }
        
        .stat-box {
            display: inline-block; padding: 10px 20px; background: var(--light);
            border-radius: 10px; margin: 5px; font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8em; }
            .tab-button { padding: 12px 20px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div id="errorPanel" class="error-panel">
        <div id="errorMessage"></div>
        <button onclick="copyError()">ğŸ“‹ Copy Error</button>
        <button onclick="dismissError()">âœ– Dismiss</button>
    </div>

    <div class="app-container">
        <div class="header">
            <h1>ğŸ® Monstrinhomon ğŸŒŸ</h1>
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">ğŸ  Home</button>
                <button class="tab-button" onclick="switchTab('session')">ğŸ“‹ Session</button>
                <button class="tab-button" onclick="switchTab('players')">ğŸ‘¥ Players</button>
                <button class="tab-button" onclick="switchTab('encounter')">âš”ï¸ Encounter</button>
                <button class="tab-button" onclick="switchTab('therapy')">ğŸ¯ Therapy</button>
                <button class="tab-button" onclick="switchTab('report')">ğŸ“Š Report</button>
                <button class="tab-button" onclick="switchTab('settings')">âš™ï¸ Settings</button>
            </div>
        </div>

        <div id="tabHome" class="tab-content active">
            <h2>Welcome to Monstrinhomon! ğŸ‰</h2>
            <p style="font-size: 18px; margin: 20px 0;">A therapeutic game for young trainers.</p>
            
            <div class="card">
                <h3>Quick Stats</h3>
                <div id="homeStats">
                    <div class="stat-box">Active Players: <span id="statPlayers">0</span></div>
                    <div class="stat-box">Total Monsters: <span id="statMonsters">0</span></div>
                    <div class="stat-box">Session Active: <span id="statSession">No</span></div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div class="flex">
                    <button class="btn btn-large btn-success" onclick="switchTab('session')">Start New Session</button>
                    <button class="btn btn-large" onclick="switchTab('players')">Manage Players</button>
                    <button class="btn btn-large btn-secondary" onclick="switchTab('encounter')">Start Encounter</button>
                </div>
            </div>
        </div>

        <div id="tabSession" class="tab-content">
            <h2>Session Management ğŸ“‹</h2>
            
            <div class="card">
                <h3>Create New Session</h3>
                <input type="text" id="sessionName" placeholder="Session Name (e.g., Therapy Session 2024-01-15)">
                <button class="btn btn-success" onclick="createSession()">Create Session</button>
            </div>

            <div id="activeSessionPanel" class="card hidden">
                <h3>Active Session: <span id="activeSessionName"></span></h3>
                <p>Created: <span id="sessionCreated"></span></p>
                
                <h4>Turn Order</h4>
                <div id="turnOrderList"></div>
                
                <button class="btn btn-warning" onclick="nextTurn()">Next Turn â–¶</button>
                <button class="btn btn-danger" onclick="endSession()">End Session</button>
            </div>
        </div>

        <div id="tabPlayers" class="tab-content">
            <h2>Player Management ğŸ‘¥</h2>
            
            <div class="card">
                <h3>Add New Player</h3>
                <input type="text" id="playerName" placeholder="Player Name">
                <select id="playerClass">
                    <option value="">Select Class</option>
                    <option value="Guerreiro">âš”ï¸ Guerreiro</option>
                    <option value="Mago">ğŸ”® Mago</option>
                    <option value="Curandeiro">ğŸ’š Curandeiro</option>
                    <option value="BÃ¡rbaro">ğŸ’ª BÃ¡rbaro</option>
                    <option value="Ladino">ğŸ—¡ï¸ Ladino</option>
                    <option value="Bardo">ğŸµ Bardo</option>
                    <option value="CaÃ§ador">ğŸ¹ CaÃ§ador</option>
                    <option value="Animalista">ğŸ¾ Animalista</option>
                </select>
                <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
            </div>

            <div id="playersList"></div>
        </div>

        <div id="tabEncounter" class="tab-content">
            <h2>Encounter âš”ï¸</h2>
            
            <div class="card">
                <h3>Start New Encounter</h3>
                <select id="encounterType">
                    <option value="wild">ğŸŒŸ Wild Monster (Individual Capture)</option>
                    <option value="trainer">ğŸ‘¤ Trainer Battle (Group)</option>
                    <option value="boss">ğŸ‘¹ Boss Battle (Group)</option>
                    <option value="event">ğŸ“– Narrative Event</option>
                </select>
                <div id="playerSelectDiv" style="margin-top: 15px;">
                    <label><strong>Select Player for Individual Encounter:</strong></label>
                    <select id="encounterPlayer">
                        <option value="">-- Select Player --</option>
                    </select>
                </div>
                <button class="btn btn-success" onclick="startEncounter()">Start Encounter</button>
            </div>

            <div id="encounterPanel" class="hidden"></div>
        </div>

        <div id="tabTherapy" class="tab-content">
            <h2>Therapeutic Objectives ğŸ¯</h2>
            
            <div class="therapist-panel">
                <h3>âš•ï¸ Therapist Controls</h3>
                
                <div class="card">
                    <h4>Add Objective</h4>
                    <input type="text" id="newObjective" placeholder="Objective description">
                    <select id="objectiveWeight">
                        <option value="1">Low Weight (1)</option>
                        <option value="2">Medium Weight (2)</option>
                        <option value="3">High Weight (3)</option>
                    </select>
                    <button class="btn btn-success" onclick="addObjective()">Add Objective</button>
                </div>

                <div id="objectivesList"></div>
            </div>

            <div id="therapyPlayersList"></div>
        </div>

        <div id="tabReport" class="tab-content">
            <h2>Session Report ğŸ“Š</h2>
            <div id="reportContent"></div>
        </div>

        <div id="tabSettings" class="tab-content">
            <h2>Settings âš™ï¸</h2>
            
            <div class="card">
                <h3>Game Configuration</h3>
                <label>
                    <input type="checkbox" id="therapistMode" onchange="toggleTherapistMode()">
                    Therapist Mode (Show advanced controls)
                </label>
            </div>

            <div class="card">
                <h3>Data Management</h3>
                <button class="btn btn-success" onclick="exportData()">ğŸ“¥ Export All Data</button>
                <button class="btn btn-warning" onclick="importData()">ğŸ“¤ Import Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">ğŸ—‘ï¸ Clear All Data</button>
            </div>

            <div id="configPanel" class="card hidden">
                <h3>Advanced Configuration</h3>
                <div id="configEditor"></div>
            </div>
        </div>
    </div>

    <script>
        // GLOBAL ERROR HANDLER
        window.addEventListener('error', function(event) {
            showError(event.error || event.message, event.error?.stack || '');
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise Rejection: ' + event.reason, event.reason?.stack || '');
        });

        function showError(message, stack) {
            const panel = document.getElementById('errorPanel');
            const messageDiv = document.getElementById('errorMessage');
            messageDiv.innerHTML = `<strong>Error:</strong> ${message}<br><pre>${stack}</pre>`;
            panel.classList.add('show');
            console.error('Error caught:', message, stack);
        }

        function dismissError() {
            document.getElementById('errorPanel').classList.remove('show');
        }

        function copyError() {
            const text = document.getElementById('errorMessage').innerText;
            navigator.clipboard.writeText(text).catch(e => alert('Copy failed: ' + e));
        }

        // STATE MANAGEMENT
        const GameState = {
            players: [],
            monsters: [],
            sessions: [],
            currentSession: null,
            currentEncounter: null,
            objectives: [],
            config: {
                maxTeamSize: 6,
                maxLevel: 100,
                levelExpo: 1.5,
                battleXpBase: 15,
                captureModel: 'threshold_no_dice',
                // Vantagens de Classe (conforme GAME_RULES.md)
                classAdvantages: {
                    'Guerreiro': { strong: 'Ladino', weak: 'Curandeiro' },
                    'Ladino': { strong: 'Mago', weak: 'Guerreiro' },
                    'Mago': { strong: 'BÃ¡rbaro', weak: 'Ladino' },
                    'BÃ¡rbaro': { strong: 'CaÃ§ador', weak: 'Mago' },
                    'CaÃ§ador': { strong: 'Bardo', weak: 'BÃ¡rbaro' },
                    'Bardo': { strong: 'Curandeiro', weak: 'CaÃ§ador' },
                    'Curandeiro': { strong: 'Guerreiro', weak: 'Bardo' },
                    'Animalista': { strong: null, weak: null } // Neutro
                },
                // Thresholds de captura por raridade (sem dado)
                captureThreshold: {
                    'Comum': 0.35,
                    'Incomum': 0.30,
                    'Raro': 0.22,
                    'MÃ­stico': 0.15,
                    'LendÃ¡rio': 0.08
                },
                // Multiplicadores de raridade
                rarityPower: {
                    'Comum': 1.00,
                    'Incomum': 1.08,
                    'Raro': 1.18,
                    'MÃ­stico': 1.32,
                    'LendÃ¡rio': 1.50
                },
                rarityXP: {
                    'Comum': 1.00,
                    'Incomum': 1.05,
                    'Raro': 1.10,
                    'MÃ­stico': 1.15,
                    'LendÃ¡rio': 1.25
                },
                // Chance base de fuga por raridade
                fleeBase: {
                    'Comum': 10,
                    'Incomum': 12,
                    'Raro': 15,
                    'MÃ­stico': 18,
                    'LendÃ¡rio': 25
                },
                medalTiers: { bronze: 5, silver: 12, gold: 25 }
            }
        };

        // MONSTER CATALOG (baseado em MONSTROS.csv)
        const MONSTER_CATALOG = [
            { id: 'MON_001', name: 'Cantapau', class: 'Bardo', rarity: 'Comum', baseHp: 28, baseAtk: 6, baseDef: 4, emoji: 'ğŸµ' },
            { id: 'MON_002', name: 'Pedrino', class: 'Guerreiro', rarity: 'Comum', baseHp: 32, baseAtk: 7, baseDef: 6, emoji: 'âš”ï¸' },
            { id: 'MON_003', name: 'FaÃ­scari', class: 'Mago', rarity: 'Comum', baseHp: 26, baseAtk: 8, baseDef: 3, emoji: 'ğŸ”®' },
            { id: 'MON_004', name: 'Ninfolha', class: 'Curandeiro', rarity: 'Comum', baseHp: 30, baseAtk: 4, baseDef: 4, emoji: 'ğŸ’š' },
            { id: 'MON_005', name: 'Garruncho', class: 'CaÃ§ador', rarity: 'Comum', baseHp: 29, baseAtk: 7, baseDef: 3, emoji: 'ğŸ¹' },
            { id: 'MON_100', name: 'Rato-de-Lama', class: 'Guerreiro', rarity: 'Comum', baseHp: 20, baseAtk: 5, baseDef: 3, emoji: 'ğŸ€' }
        ];

        // CLASTERORB TIERS (Sistema de captura em tiers)
        const CLASTERORBS = {
            'CLASTERORB_COMUM': { id: 'CLASTERORB_COMUM', name: 'ClasterOrb Comum', type: 'CAPTURE', capture_bonus_pp: 0, emoji: 'âšª' },
            'CLASTERORB_INCOMUM': { id: 'CLASTERORB_INCOMUM', name: 'ClasterOrb Incomum', type: 'CAPTURE', capture_bonus_pp: 5, emoji: 'ğŸ”µ' },
            'CLASTERORB_RARA': { id: 'CLASTERORB_RARA', name: 'ClasterOrb Rara', type: 'CAPTURE', capture_bonus_pp: 10, emoji: 'ğŸŸ£' }
        };

        // SKILLS CATALOG (baseado em HABILIDADES.csv)
        const SKILLS_CATALOG = [
            { id: 'SK_WAR_01', name: 'Golpe de Escudo', class: 'Guerreiro', category: 'Controle', power: 6, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: 'Atordoado', desc: 'Ataque curto com chance de atordoar.' },
            { id: 'SK_WAR_02', name: 'Corte Pesado', class: 'Guerreiro', category: 'Ataque', power: 9, accuracy: 0.8, energy_cost: 3, target: 'Inimigo', status: '', desc: 'Dano alto, menos preciso.' },
            { id: 'SK_MAG_01', name: 'Raio MÃ­stico', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Dano mÃ¡gico Ã  distÃ¢ncia.' },
            { id: 'SK_MAG_02', name: 'NÃ©voa Lenta', class: 'Mago', category: 'Controle', power: 4, accuracy: 0.9, energy_cost: 3, target: 'Ãrea', status: 'Enraizado', desc: 'Reduz aÃ§Ã£o/movimento por 1 turno.' },
            { id: 'SK_HEA_01', name: 'Sopro Calmante', class: 'Curandeiro', category: 'Cura', power: 0, accuracy: 1, energy_cost: 4, target: 'Aliado', status: '', desc: 'Cura moderada.' },
            { id: 'SK_HEA_02', name: 'Barreira Suave', class: 'Curandeiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Aliado', status: 'Protegido', desc: 'Aumenta defesa por 2 turnos.' },
            { id: 'SK_HUN_01', name: 'Flecha RÃ¡pida', class: 'CaÃ§ador', category: 'Ataque', power: 8, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: '', desc: 'Dano consistente Ã  distÃ¢ncia.' },
            { id: 'SK_BRD_01', name: 'CanÃ§Ã£o de Coragem', class: 'Bardo', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Ãrea', status: 'Fortalecido', desc: 'Buff de ataque para aliados.' }
        ];

        // CLASS ENERGY REGEN (baseado em CLASSES.csv)
        const CLASS_ENERGY_REGEN = {
            'Guerreiro': { ene_regen_pct: 0.10, ene_regen_min: 2 },
            'Mago': { ene_regen_pct: 0.25, ene_regen_min: 1 },
            'Curandeiro': { ene_regen_pct: 0.20, ene_regen_min: 2 },
            'BÃ¡rbaro': { ene_regen_pct: 0.10, ene_regen_min: 1 },
            'Ladino': { ene_regen_pct: 0.15, ene_regen_min: 1 },
            'Bardo': { ene_regen_pct: 0.18, ene_regen_min: 2 },
            'CaÃ§ador': { ene_regen_pct: 0.12, ene_regen_min: 2 },
            'Animalista': { ene_regen_pct: 0.15, ene_regen_min: 2 }
        };

        // DEFAULT OBJECTIVES
        const DEFAULT_OBJECTIVES = [
            { id: 1, text: 'Followed group rules', weight: 2 },
            { id: 2, text: 'Waited for turn patiently', weight: 3 },
            { id: 3, text: 'Helped another player', weight: 3 },
            { id: 4, text: 'Used calm voice throughout', weight: 2 },
            { id: 5, text: 'Made good eye contact', weight: 1 },
            { id: 6, text: 'Shared materials/ideas', weight: 2 }
        ];

        // INITIALIZATION
        function init() {
            try {
                loadFromLocalStorage();
                if (!GameState.objectives || GameState.objectives.length === 0) {
                    GameState.objectives = [...DEFAULT_OBJECTIVES];
                }
                updateAllViews();
                console.log('Monstrinhomon initialized successfully');
            } catch (error) {
                showError('Initialization failed', error.stack);
            }
        }

        // LOCAL STORAGE
        function saveToLocalStorage() {
            try {
                const data = JSON.stringify(GameState);
                localStorage.setItem('monstrinhomon_state', data);
            } catch (error) {
                showError('Failed to save data', error.stack);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('monstrinhomon_state');
                if (data) {
                    const loaded = JSON.parse(data);
                    Object.assign(GameState, loaded);
                    
                    // Migrar inventÃ¡rios antigos
                    if (GameState.players) {
                        GameState.players.forEach(player => {
                            migrateInventory(player);
                            
                            // Garantir que monstros tenham ENE
                            if (player.team) {
                                player.team.forEach(monster => {
                                    if (!monster.eneMax) {
                                        monster.eneMax = 10 + (monster.level || 1);
                                        monster.ene = monster.eneMax;
                                    }
                                    if (monster.ene === undefined) {
                                        monster.ene = monster.eneMax;
                                    }
                                });
                            }
                        });
                    }
                }
            } catch (error) {
                console.warn('Failed to load saved data:', error);
            }
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            try {
                const tabs = document.querySelectorAll('.tab-content');
                const buttons = document.querySelectorAll('.tab-button');
                
                tabs.forEach(tab => tab.classList.remove('active'));
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeTab = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                const activeButton = Array.from(buttons).find(btn => 
                    btn.textContent.toLowerCase().includes(tabName.toLowerCase())
                );
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                
                updateAllViews();
            } catch (error) {
                showError('Tab switching failed', error.stack);
            }
        }

        // PLAYER MANAGEMENT
        function addPlayer() {
            try {
                const name = document.getElementById('playerName')?.value?.trim();
                const playerClass = document.getElementById('playerClass')?.value;
                
                if (!name) {
                    alert('Please enter a player name');
                    return;
                }
                
                if (!playerClass) {
                    alert('Please select a class');
                    return;
                }
                
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    class: playerClass, // Armazena a classe diretamente
                    playerClassId: playerClass,
                    money: 100,
                    afterlifeCurrency: 0,
                    team: [],
                    box: [],
                    inventory: {
                        'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                        'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                        'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                        'IT_HEAL_01': 3           // Petisco de Cura x3
                    }
                };
                
                GameState.players = GameState.players || [];
                GameState.players.push(player);
                
                giveStarterMonster(player);
                
                document.getElementById('playerName').value = '';
                document.getElementById('playerClass').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add player', error.stack);
            }
        }

        function giveStarterMonster(player) {
            try {
                // Busca monstrinho inicial da mesma classe do jogador
                const classMonsters = MONSTER_CATALOG.filter(m => 
                    m?.class === player?.class && m?.rarity === 'Comum'
                );
                
                // Se nÃ£o encontrar da mesma classe, pega qualquer starter comum
                const starterTemplate = classMonsters.length > 0 ? classMonsters[0] : 
                    MONSTER_CATALOG.find(m => m?.rarity === 'Comum');
                
                if (!starterTemplate) return;
                
                const monster = createMonsterInstance(starterTemplate, player.id, 5);
                
                if (monster) {
                    player.team = player.team || [];
                    player.team.push(monster);
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                }
            } catch (error) {
                console.error('Failed to give starter monster:', error);
            }
        }

        function createMonsterInstance(template, ownerId, level = 1) {
            try {
                if (!template) return null;
                
                // Calcular stats baseados no nÃ­vel
                const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const poder = Math.floor(atk * 0.5); // PODER Ã© derivado de ATK
                
                // Calcular ENE (Sistema ENE)
                const baseEne = template.baseEne || 10; // Fallback se nÃ£o tiver no template
                const eneGrowth = 2; // growth_ene padrÃ£o
                const eneMax = Math.floor(baseEne + eneGrowth * (level - 1));
                
                return {
                    id: Date.now() + Math.random(),
                    ownerId: ownerId,
                    monsterId: template.id,
                    name: template.name,
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji,
                    level: level,
                    xp: 0,
                    hp: hpMax,
                    hpMax: hpMax,
                    atk: atk,
                    def: def,
                    poder: poder,
                    ene: eneMax,      // ENE atual (comeÃ§a cheio)
                    eneMax: eneMax,   // ENE mÃ¡ximo
                    status: 'healthy',
                    skill: null       // SerÃ¡ definido ao entrar em batalha
                };
            } catch (error) {
                console.error('Failed to create monster instance:', error);
                return null;
            }
        }

        // FunÃ§Ã£o para obter habilidade do monstrinho
        function getMonsterSkill(monster) {
            try {
                if (!monster) return null;
                
                // Buscar habilidade da mesma classe
                const classSkills = SKILLS_CATALOG.filter(s => s.class === monster.class);
                
                if (classSkills.length > 0) {
                    // Por enquanto, retorna a primeira habilidade da classe
                    return classSkills[0];
                }
                
                // Fallback: retorna primeira habilidade disponÃ­vel
                return SKILLS_CATALOG[0];
            } catch (error) {
                console.error('Failed to get monster skill:', error);
                return null;
            }
        }

        // Migrar inventÃ¡rio antigo para novo sistema ClasterOrb
        function migrateInventory(player) {
            try {
                if (!player || !player.inventory) return;
                
                // Se tem IT_CAP_01 antigo, converter para CLASTERORB_COMUM
                if (player.inventory['IT_CAP_01']) {
                    const oldCount = player.inventory['IT_CAP_01'];
                    player.inventory['CLASTERORB_COMUM'] = (player.inventory['CLASTERORB_COMUM'] || 0) + oldCount;
                    delete player.inventory['IT_CAP_01'];
                }
                
                // Garantir que novos itens existam
                if (!player.inventory['CLASTERORB_COMUM']) player.inventory['CLASTERORB_COMUM'] = 0;
                if (!player.inventory['CLASTERORB_INCOMUM']) player.inventory['CLASTERORB_INCOMUM'] = 0;
                if (!player.inventory['CLASTERORB_RARA']) player.inventory['CLASTERORB_RARA'] = 0;
            } catch (error) {
                console.error('Failed to migrate inventory:', error);
            }
        }

        // SESSION MANAGEMENT
        function createSession() {
            try {
                const name = document.getElementById('sessionName')?.value?.trim();
                
                if (!name) {
                    alert('Please enter a session name');
                    return;
                }
                
                if (!GameState.players || GameState.players.length === 0) {
                    alert('Please add players first');
                    return;
                }
                
                const session = {
                    id: Date.now(),
                    name: name,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    players: GameState.players.map(p => p?.id).filter(id => id),
                    turnOrder: [...GameState.players.map(p => p?.id).filter(id => id)],
                    currentTurnIndex: 0,
                    encountersLog: [],
                    therapy: {
                        perPlayer: {}
                    }
                };
                
                GameState.players.forEach(player => {
                    if (player?.id) {
                        session.therapy.perPlayer[player.id] = {
                            pm: 0,
                            medals: [],
                            logs: [],
                            completedObjectives: []
                        };
                    }
                });
                
                GameState.sessions = GameState.sessions || [];
                GameState.sessions.push(session);
                GameState.currentSession = session;
                
                document.getElementById('sessionName').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to create session', error.stack);
            }
        }

        function nextTurn() {
            try {
                if (!GameState.currentSession) return;
                
                const session = GameState.currentSession;
                session.currentTurnIndex = ((session.currentTurnIndex || 0) + 1) % (session.turnOrder?.length || 1);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to advance turn', error.stack);
            }
        }

        function endSession() {
            try {
                if (!GameState.currentSession) return;
                
                if (confirm('End this session?')) {
                    GameState.currentSession.completedAt = new Date().toISOString();
                    GameState.currentSession = null;
                    
                    saveToLocalStorage();
                    updateAllViews();
                }
            } catch (error) {
                showError('Failed to end session', error.stack);
            }
        }

        // ENCOUNTER MANAGEMENT
        function startEncounter() {
            try {
                const type = document.getElementById('encounterType')?.value;
                
                if (!type) {
                    alert('Please select encounter type');
                    return;
                }
                
                if (!GameState.currentSession) {
                    alert('Please create a session first');
                    return;
                }
                
                // Para encontros individuais (captura), precisa selecionar jogador
                if (type === 'wild') {
                    const selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                    if (!selectedPlayerId) {
                        alert('Please select a player for individual encounter');
                        return;
                    }
                    
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (!player || !player.team || player.team.length === 0) {
                        alert('Selected player has no monsters in team');
                        return;
                    }
                    
                    // GAME_RULES.md: Em batalha, sÃ³ pode usar monstros da mesma classe do jogador
                    const validMonsters = player.team.filter(m => m.class === player.class && m.status !== 'fainted');
                    if (validMonsters.length === 0) {
                        alert(`âš ï¸ ${player.name} nÃ£o tem monstrinhos da classe ${player.class} disponÃ­veis!\n\nREGRA: Em batalha, vocÃª sÃ³ pode usar monstrinhos da SUA classe.\nTroque com outros jogadores para conseguir monstrinhos da sua classe!`);
                        return;
                    }
                }
                
                const encounter = {
                    id: Date.now(),
                    type: type,
                    active: true,
                    log: [],
                    selectedPlayerId: type === 'wild' ? document.getElementById('encounterPlayer')?.value : null
                };
                
                if (type === 'wild') {
                    const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                    const level = Math.floor(Math.random() * 10) + 1;
                    encounter.wildMonster = createMonsterInstance(randomMonster, null, level);
                    encounter.wildMonster.id = 'wild_' + Date.now();
                }
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start encounter', error.stack);
            }
        }

        function renderEncounter() {
            try {
                const panel = document.getElementById('encounterPanel');
                if (!panel) return;
                
                const encounter = GameState.currentEncounter;
                
                if (!encounter || !encounter.active) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                if (encounter.type === 'wild') {
                    renderWildEncounter(panel, encounter);
                } else {
                    panel.innerHTML = '<div class="encounter-panel"><h3>Encounter type not yet implemented</h3></div>';
                }
            } catch (error) {
                showError('Failed to render encounter', error.stack);
            }
        }

        function renderWildEncounter(panel, encounter) {
            try {
                const monster = encounter.wildMonster;
                if (!monster) return;
                
                // Buscar jogador selecionado
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                const playerMonster = player?.team?.[0];
                
                // Atribuir habilidades se ainda nÃ£o tiver
                if (monster && !monster.skill) {
                    monster.skill = getMonsterSkill(monster);
                }
                if (playerMonster && !playerMonster.skill) {
                    playerMonster.skill = getMonsterSkill(playerMonster);
                }
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const canCapture = hpPercent <= baseThreshold;
                
                const html = `
                    <div class="encounter-panel">
                        <h3>Wild ${monster.emoji} ${monster.name} appeared!</h3>
                        ${player ? `<p><strong>Jogador:</strong> ${player.name} (${player.class})</p>` : ''}
                        ${playerMonster ? `
                        <div style="margin: 10px 0; padding: 10px; background: #e8f5e9; border-radius: 8px;">
                            <p><strong>Seu Monstrinho:</strong> ${playerMonster.emoji} ${playerMonster.name} (Nv ${playerMonster.level})</p>
                            <div><strong>HP:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                            <div><strong>âš¡ ENE:</strong> ${playerMonster.ene || 0}/${playerMonster.eneMax || 0}</div>
                        </div>
                        ` : ''}
                        
                        <div class="monster-card ${monster.class}" style="display: inline-block; margin: 20px;">
                            <div style="font-size: 48px;">${monster.emoji}</div>
                            <strong>${monster.name}</strong>
                            <div class="badge badge-${monster.rarity}">${monster.rarity}</div>
                            <div><strong>Classe:</strong> ${monster.class}</div>
                            <div><strong>Level:</strong> ${monster.level}</div>
                            <div style="margin-top: 8px;">
                                <div><strong>ATK:</strong> ${monster.atk} | <strong>DEF:</strong> ${monster.def}</div>
                                <div><strong>PODER:</strong> ${monster.poder}</div>
                                <div><strong>âš¡ ENE:</strong> ${monster.ene || 0}/${monster.eneMax || 0}</div>
                            </div>
                            <div class="progress-bar" style="margin-top: 10px;">
                                <div class="progress-fill hp" style="width: ${(monster.hp / monster.hpMax) * 100}%">
                                    ${monster.hp}/${monster.hpMax} HP (${Math.floor(hpPercent * 100)}%)
                                </div>
                            </div>
                            ${canCapture ? 
                                '<div style="color: green; margin-top: 5px;">âœ… HP baixo! Pode tentar captura!</div>' : 
                                `<div style="color: orange; margin-top: 5px;">âš ï¸ Abaixe HP para ${Math.floor(baseThreshold * 100)}% para capturar</div>`
                            }
                        </div>
                        
                        <h4>Choose Action:</h4>
                        <div class="flex-center" style="flex-direction: column;">
                            <div style="margin: 10px 0;">
                                <label style="font-weight: bold; font-size: 18px;">ğŸ² Enter your d20 roll:</label>
                                <input type="number" id="diceRoll" min="1" max="20" placeholder="1-20" 
                                       style="width: 120px; text-align: center; font-size: 24px; font-weight: bold; height: 60px; margin: 10px;">
                            </div>
                            
                            ${player ? (() => {
                                const comum = player.inventory?.['CLASTERORB_COMUM'] || 0;
                                const incomum = player.inventory?.['CLASTERORB_INCOMUM'] || 0;
                                const rara = player.inventory?.['CLASTERORB_RARA'] || 0;
                                const hasAnyOrb = comum > 0 || incomum > 0 || rara > 0;
                                
                                return `
                                <div style="margin: 15px 0; background: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #1976d2;">
                                    <strong style="font-size: 16px;">ğŸ¯ Sistema de Captura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>HP% Selvagem:</strong> ${Math.floor(hpPercent * 100)}%</div>
                                        <div><strong>Base Threshold (${monster.rarity}):</strong> ${Math.floor(baseThreshold * 100)}%</div>
                                        <div><strong>BÃ´nus HP Baixo (â‰¤25%):</strong> ${hpPercent <= 0.25 ? '+10%' : '0%'}</div>
                                    </div>
                                    
                                    ${hasAnyOrb ? `
                                    <div style="margin-top: 10px;">
                                        <label style="font-weight: bold;">Escolha sua ClasterOrb:</label>
                                        <select id="captureOrbSelect" onchange="updateCaptureThreshold()" style="width: 100%; padding: 8px; margin: 5px 0; font-size: 14px;">
                                            ${comum > 0 ? `<option value="CLASTERORB_COMUM">âšª Comum (${comum}x) - +0% bonus</option>` : ''}
                                            ${incomum > 0 ? `<option value="CLASTERORB_INCOMUM">ğŸ”µ Incomum (${incomum}x) - +5% bonus</option>` : ''}
                                            ${rara > 0 ? `<option value="CLASTERORB_RARA">ğŸŸ£ Rara (${rara}x) - +10% bonus</option>` : ''}
                                        </select>
                                    </div>
                                    <div id="captureThresholdDisplay" style="margin-top: 10px; padding: 10px; background: #fff; border-radius: 5px;">
                                        <strong>Threshold Final:</strong> <span id="finalThresholdValue">Calculando...</span>
                                    </div>
                                    ` : `
                                    <div style="margin-top: 10px; padding: 10px; background: #ffebee; color: #c62828; border-radius: 5px;">
                                        <strong>âŒ Sem ClasterOrbs!</strong><br>
                                        VocÃª nÃ£o tem orbes de captura disponÃ­veis.
                                    </div>
                                    `}
                                    
                                    <div style="margin-top: 10px;">
                                        <strong>ğŸ“¦ InventÃ¡rio:</strong> 
                                        âšª ${comum} | ğŸ”µ ${incomum} | ğŸŸ£ ${rara} | 
                                        ğŸ’š Cura: ${player.inventory?.['IT_HEAL_01'] || 0}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                            
                            <div class="flex-center">
                                ${player && (player.inventory?.['CLASTERORB_COMUM'] > 0 || player.inventory?.['CLASTERORB_INCOMUM'] > 0 || player.inventory?.['CLASTERORB_RARA'] > 0) ? 
                                    `<button class="btn btn-success btn-large" onclick="attemptCapture()">ğŸ¯ Tentar Capturar</button>` :
                                    `<button class="btn btn-success btn-large" disabled style="opacity: 0.5;">ğŸ¯ Sem Orbes</button>`
                                }
                                <button class="btn btn-danger btn-large" onclick="attackWild()">âš”ï¸ Attack</button>
                                ${playerMonster && playerMonster.skill ? (() => {
                                    const skill = playerMonster.skill;
                                    const canUseSkill = (playerMonster.ene || 0) >= skill.energy_cost;
                                    return `<button class="btn btn-primary btn-large" onclick="useSkillWild()" 
                                            ${!canUseSkill ? 'disabled style="opacity: 0.5;"' : ''} 
                                            title="${skill.name}: ${skill.desc} (Power: ${skill.power})">
                                        âš¡ Skill (-${skill.energy_cost} ENE)
                                    </button>`;
                                })() : ''}
                                <button class="btn btn-warning btn-large" onclick="fleeEncounter()">ğŸƒ Flee</button>
                            </div>
                        </div>
                        
                        <div class="combat-log" id="combatLog" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px; max-height: 300px; overflow-y: auto;">
                            ${(encounter.log || []).map(entry => `<div style="margin: 5px 0; padding: 5px; border-bottom: 1px solid #ddd;">${entry}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                panel.innerHTML = html;
                
                // Atualizar threshold inicial
                setTimeout(() => updateCaptureThreshold(), 100);
            } catch (error) {
                showError('Failed to render wild encounter', error.stack);
            }
        }

        // Atualizar cÃ¡lculo de threshold de captura em tempo real
        function updateCaptureThreshold() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const select = document.getElementById('captureOrbSelect');
                const display = document.getElementById('finalThresholdValue');
                if (!select || !display) return;
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) return;
                
                // Calcular threshold
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const orbBonus = orbInfo.capture_bonus_pp / 100; // Converter pp para decimal
                const lowHpBonus = hpPercent <= 0.25 ? 0.10 : 0;
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                // Atualizar display
                display.innerHTML = `
                    <span style="font-size: 18px; color: ${hpPercent <= thresholdFinal ? '#2e7d32' : '#c62828'}; font-weight: bold;">
                        ${Math.floor(thresholdFinal * 100)}%
                    </span>
                    <br><small>
                        (Base ${Math.floor(baseThreshold * 100)}% + Orb ${orbInfo.capture_bonus_pp}% + HP ${Math.floor(lowHpBonus * 100)}%)
                        <br>${hpPercent <= thresholdFinal ? 'âœ… Captura provÃ¡vel!' : 'âŒ HP muito alto'}
                    </small>
                `;
            } catch (error) {
                console.error('Failed to update capture threshold:', error);
            }
        }

        function attemptCapture() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                // ValidaÃ§Ã£o: HP > 0 obrigatÃ³rio
                if (monster.hp <= 0) {
                    alert('âŒ NÃ£o pode capturar um monstrinho desmaiado! HP deve ser > 0.');
                    return;
                }
                
                // Obter ClasterOrb selecionada
                const select = document.getElementById('captureOrbSelect');
                if (!select) {
                    alert('âŒ Erro ao ler seleÃ§Ã£o de ClasterOrb.');
                    return;
                }
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) {
                    alert('âŒ ClasterOrb invÃ¡lida.');
                    return;
                }
                
                // ValidaÃ§Ã£o: precisa ter a orb selecionada
                player.inventory = player.inventory || {};
                const orbCount = player.inventory[selectedOrbId] || 0;
                
                if (orbCount <= 0) {
                    alert(`âŒ VocÃª nÃ£o tem ${orbInfo.name}!`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // SEMPRE CONSOME 1 item (mesmo se falhar)
                player.inventory[selectedOrbId]--;
                encounter.log.push(`${orbInfo.emoji} ${player.name} usou ${orbInfo.name}! (Restam: ${player.inventory[selectedOrbId]})`);
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                
                // BÃ´nus se HP <= 25%
                let lowHpBonus = 0;
                if (hpPercent <= 0.25) {
                    lowHpBonus = 0.10;
                    encounter.log.push(`âœ¨ HP crÃ­tico! BÃ´nus de +10% na captura!`);
                }
                
                // BÃ´nus da orb (em decimal: 0, 0.05, 0.10)
                const orbBonus = orbInfo.capture_bonus_pp / 100;
                
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                encounter.log.push(`HP: ${Math.floor(hpPercent * 100)}% | Base: ${Math.floor(baseThreshold * 100)}% | Orb: +${orbInfo.capture_bonus_pp}% | HP Bonus: +${Math.floor(lowHpBonus * 100)}%`);
                encounter.log.push(`ğŸ¯ Threshold Final: ${Math.floor(thresholdFinal * 100)}%`);
                
                // Captura determinÃ­stica: sucesso se HP% <= Threshold_final
                if (hpPercent <= thresholdFinal) {
                    encounter.log.push(`âœ… SUCESSO! ${monster.name} foi capturado!`);
                    
                    monster.ownerId = player.id;
                    
                    player.team = player.team || [];
                    player.box = player.box || [];
                    
                    if (player.team.length < (GameState.config?.maxTeamSize || 6)) {
                        player.team.push(monster);
                        encounter.log.push(`${monster.name} foi adicionado ao time de ${player.name}!`);
                    } else {
                        player.box.push(monster);
                        encounter.log.push(`${monster.name} foi enviado para a caixa de ${player.name}!`);
                    }
                    
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                    
                    encounter.active = false;
                    GameState.currentEncounter = null;
                } else {
                    // FALHA: Monstrinho realiza 1 ataque bÃ¡sico IMEDIATO
                    encounter.log.push(`âŒ FALHA! ${monster.name} quebrou livre!`);
                    
                    const playerMonster = player.team?.[0];
                    if (playerMonster && playerMonster.hp > 0) {
                        encounter.log.push(`âš¡ ${monster.name} contra-ataca!`);
                        
                        // Monstrinho selvagem ataca imediatamente
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, monster, playerMonster);
                        encounter.log.push(`ğŸ² ${monster.name} rola ${enemyRoll} (ATK: ${monster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(monster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${monster.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${monster.name} erra o ataque!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Capture attempt failed', error.stack);
            }
        }

        function attackWild() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Player has no monsters in team');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho Ã© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`âš ï¸ VocÃª sÃ³ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} Ã© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Get dice roll from input field
                const diceInput = document.getElementById('diceRoll');
                const playerRoll = parseInt(diceInput?.value || '0');
                
                if (playerRoll < 1 || playerRoll > 20) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                
                // Clear the input for next roll
                if (diceInput) diceInput.value = '';
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno do jogador
                if (playerMonster.ene !== undefined && playerMonster.eneMax) {
                    const regenInfo = CLASS_ENERGY_REGEN[playerMonster.class] || { ene_regen_pct: 0.10, ene_regen_min: 1 };
                    const eneGain = Math.max(regenInfo.ene_regen_min, Math.ceil(playerMonster.eneMax * regenInfo.ene_regen_pct));
                    playerMonster.ene = Math.min(playerMonster.eneMax, playerMonster.ene + eneGain);
                    encounter.log.push(`âš¡ ${playerMonster.name} regenerou +${eneGain} ENE (${playerMonster.ene}/${playerMonster.eneMax})`);
                }
                
                // CRIT 20 ou FALHA 1 (GAME_RULES.md)
                let isCrit20 = false;
                let isFail1 = false;
                let critBonus = null;
                
                if (playerRoll === 20) {
                    isCrit20 = true;
                    encounter.log.push(`â­ CRÃTICO 20! â­`);
                    // Escolher bÃ´nus aleatÃ³rio
                    const bonusRoll = Math.floor(Math.random() * 3);
                    if (bonusRoll === 0) {
                        critBonus = 'double_power';
                        encounter.log.push(`ğŸ’¥ Poder dobrado neste ataque!`);
                    } else if (bonusRoll === 1) {
                        critBonus = 'item';
                        player.inventory = player.inventory || {};
                        player.inventory['IT_HEAL_01'] = (player.inventory['IT_HEAL_01'] || 0) + 1;
                        encounter.log.push(`ğŸ Ganhou 1 Petisco de Cura!`);
                    } else {
                        critBonus = 'money';
                        const moneyGain = 20 + Math.floor(Math.random() * 31); // 20-50
                        player.money = (player.money || 0) + moneyGain;
                        encounter.log.push(`ğŸ’° Ganhou ${moneyGain} moedas!`);
                    }
                } else if (playerRoll === 1) {
                    isFail1 = true;
                }
                
                // Fase 1: Ataque do jogador
                encounter.log.push(`ğŸ² ${player.name}'s ${playerMonster.name} rolls ${playerRoll} (ATK: ${playerMonster.atk})`);
                
                // d20=1 sempre erra, d20=20 sempre acerta
                const playerHit = isFail1 ? false : (isCrit20 ? true : checkHit(playerRoll, playerMonster, encounter.wildMonster));
                
                if (playerHit) {
                    let damage = calculateDamage(playerMonster, encounter.wildMonster);
                    
                    // Se crit 20 com poder dobrado, multiplica dano por 2
                    if (isCrit20 && critBonus === 'double_power') {
                        damage *= 2;
                    }
                    
                    encounter.wildMonster.hp = Math.max(0, encounter.wildMonster.hp - damage);
                    encounter.log.push(`ğŸ’¥ ${playerMonster.name} hits! Deals ${damage} damage!`);
                    
                    if (encounter.wildMonster.hp <= 0) {
                        encounter.log.push(`ğŸ† ${encounter.wildMonster.name} fainted! Victory!`);
                        const xpGained = calculateBattleXP(encounter.wildMonster);
                        giveXp(playerMonster, xpGained);
                        encounter.log.push(`âœ¨ ${playerMonster.name} gains ${xpGained} XP!`);
                        encounter.active = false;
                        GameState.currentEncounter = null;
                        saveToLocalStorage();
                        renderEncounter();
                        return;
                    }
                } else {
                    if (isFail1) {
                        encounter.log.push(`ğŸ’€ FALHA CRÃTICA! Ataque erra automaticamente!`);
                    } else {
                        encounter.log.push(`âŒ ${playerMonster.name} misses!`);
                    }
                }
                
                // Fase 2: Contra-ataque do monstrinho selvagem (se ainda vivo)
                if (encounter.wildMonster.hp > 0) {
                    const wildMonster = encounter.wildMonster;
                    const wildSkill = wildMonster.skill;
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const useSkill = wildSkill && (wildMonster.ene || 0) >= wildSkill.energy_cost && Math.random() < 0.5;
                    
                    if (useSkill) {
                        wildMonster.ene -= wildSkill.energy_cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${wildSkill.name}! (-${wildSkill.energy_cost} ENE)`);
                        
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll}`);
                        
                        if (enemyHit) {
                            const baseDamage = wildMonster.atk + wildSkill.power - playerMonster.def;
                            const damage = Math.max(1, baseDamage);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildSkill.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildSkill.name} erra!`);
                        }
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² Wild ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(wildMonster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Attack failed', error.stack);
            }
        }

        // Usar habilidade contra o selvagem
        function useSkillWild() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const playerMonster = player.team?.[0];
                if (!playerMonster || !playerMonster.skill) {
                    alert('No skill available');
                    return;
                }
                
                const skill = playerMonster.skill;
                
                // Validar ENE suficiente
                if ((playerMonster.ene || 0) < skill.energy_cost) {
                    alert(`âŒ ENE insuficiente! Precisa de ${skill.energy_cost} ENE.`);
                    return;
                }
                
                // Get dice roll from input field
                const diceInput = document.getElementById('diceRoll');
                const playerRoll = parseInt(diceInput?.value || '0');
                
                if (playerRoll < 1 || playerRoll > 20) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                
                if (diceInput) diceInput.value = '';
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno
                const regenInfo = CLASS_ENERGY_REGEN[playerMonster.class] || { ene_regen_pct: 0.10, ene_regen_min: 1 };
                const eneGain = Math.max(regenInfo.ene_regen_min, Math.ceil(playerMonster.eneMax * regenInfo.ene_regen_pct));
                playerMonster.ene = Math.min(playerMonster.eneMax, playerMonster.ene + eneGain);
                encounter.log.push(`âš¡ ${playerMonster.name} regenerou +${eneGain} ENE (${playerMonster.ene}/${playerMonster.eneMax})`);
                
                // CONSUMIR ENE
                playerMonster.ene -= skill.energy_cost;
                encounter.log.push(`âœ¨ ${playerMonster.name} usa ${skill.name}! (-${skill.energy_cost} ENE, resta ${playerMonster.ene})`);
                
                // LÃ³gica de acerto (mesma do ataque bÃ¡sico)
                const playerHit = playerRoll === 1 ? false : (playerRoll === 20 ? true : checkHit(playerRoll, playerMonster, encounter.wildMonster));
                encounter.log.push(`ğŸ² ${player.name}'s ${playerMonster.name} rolls ${playerRoll} (ATK: ${playerMonster.atk})`);
                
                if (playerHit) {
                    // Dano da habilidade: ATK + power - DEF
                    const baseDamage = playerMonster.atk + skill.power - encounter.wildMonster.def;
                    const damage = Math.max(1, baseDamage);
                    
                    encounter.wildMonster.hp = Math.max(0, encounter.wildMonster.hp - damage);
                    encounter.log.push(`ğŸ’¥ ${skill.name} acerta! Causa ${damage} de dano!`);
                    
                    if (encounter.wildMonster.hp <= 0) {
                        encounter.log.push(`ğŸ† ${encounter.wildMonster.name} fainted! Victory!`);
                        const xpGained = calculateBattleXP(encounter.wildMonster);
                        giveXp(playerMonster, xpGained);
                        encounter.log.push(`âœ¨ ${playerMonster.name} gains ${xpGained} XP!`);
                        encounter.active = false;
                        GameState.currentEncounter = null;
                        saveToLocalStorage();
                        renderEncounter();
                        return;
                    }
                } else {
                    if (playerRoll === 1) {
                        encounter.log.push(`ğŸ’€ FALHA CRÃTICA! ${skill.name} erra!`);
                    } else {
                        encounter.log.push(`âŒ ${skill.name} erra!`);
                    }
                }
                
                // Fase 2: Contra-ataque do selvagem (com possibilidade de usar habilidade)
                if (encounter.wildMonster.hp > 0) {
                    const wildMonster = encounter.wildMonster;
                    const wildSkill = wildMonster.skill;
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const useSkill = wildSkill && (wildMonster.ene || 0) >= wildSkill.energy_cost && Math.random() < 0.5;
                    
                    if (useSkill) {
                        wildMonster.ene -= wildSkill.energy_cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${wildSkill.name}! (-${wildSkill.energy_cost} ENE)`);
                        
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll}`);
                        
                        if (enemyHit) {
                            const baseDamage = wildMonster.atk + wildSkill.power - playerMonster.def;
                            const damage = Math.max(1, baseDamage);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildSkill.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildSkill.name} erra!`);
                        }
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² Wild ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(wildMonster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Skill use failed', error.stack);
            }
        }

        // Verifica acerto: d20 + ATK >= DEF
        function checkHit(d20Roll, attacker, defender) {
            try {
                if (!attacker || !defender) return false;
                
                const atkMod = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +2 ATK se forte, -2 ATK se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let atkBonus = 0;
                if (classAdv?.strong === defender.class) {
                    atkBonus = 2;
                } else if (classAdv?.weak === defender.class) {
                    atkBonus = -2;
                }
                
                const totalAtk = d20Roll + atkMod + atkBonus;
                return totalAtk >= defValue;
            } catch (error) {
                console.error('Hit check failed:', error);
                return false;
            }
        }

        // Calcula dano: max(1, ATK + PODER - DEF) com modificadores de classe
        function calculateDamage(attacker, defender) {
            try {
                if (!attacker || !defender) return 1;
                
                const atkValue = attacker.atk || 5;
                const poderValue = attacker.poder || Math.floor(atkValue * 0.5);
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +10% dano se forte, -10% dano se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let damageMult = 1.0;
                if (classAdv?.strong === defender.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === defender.class) {
                    damageMult = 0.90;
                }
                
                const baseDamage = atkValue + poderValue - defValue;
                const finalDamage = Math.floor(baseDamage * damageMult);
                
                return Math.max(1, finalDamage);
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        // Calcula XP de batalha
        function calculateBattleXP(defeatedMonster) {
            try {
                const baseXP = GameState.config?.battleXpBase || 15;
                const levelMod = (defeatedMonster.level || 1) * 2;
                const rarityMod = GameState.config?.rarityXP?.[defeatedMonster.rarity] || 1.0;
                
                return Math.floor((baseXP + levelMod) * rarityMod);
            } catch (error) {
                console.error('XP calculation failed:', error);
                return 15;
            }
        }

        function giveXp(monster, amount) {
            try {
                if (!monster) return;
                
                monster.xp = (monster.xp || 0) + amount;
                
                // FÃ³rmula de XP por nÃ­vel conforme AGENTS.md: Math.round(40 + 6*L + 0.6*(L*L))
                const xpNeeded = Math.round(40 + 6 * monster.level + 0.6 * (monster.level * monster.level));
                
                while (monster.xp >= xpNeeded && monster.level < (GameState.config?.maxLevel || 100)) {
                    monster.xp -= xpNeeded;
                    monster.level++;
                    
                    // Recalcula stats baseado no novo nÃ­vel
                    const template = MONSTER_CATALOG.find(m => m?.id === monster.monsterId);
                    if (template) {
                        const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                        const levelMult = (1 + (monster.level - 1) * 0.1);
                        
                        // HP aumenta: hpMax * 1.04 + 2 conforme AGENTS.md
                        const oldHpMax = monster.hpMax;
                        monster.hpMax = Math.floor(monster.hpMax * 1.04 + 2);
                        // HP atual aumenta proporcionalmente
                        const hpRatio = monster.hp / oldHpMax;
                        monster.hp = Math.floor(monster.hpMax * hpRatio);
                        
                        // Recalcula ATK, DEF, PODER
                        monster.atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                        monster.def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                        monster.poder = Math.floor(monster.atk * 0.5);
                    }
                }
                
                saveToLocalStorage();
            } catch (error) {
                console.error('Failed to give XP:', error);
            }
        }

        function fleeEncounter() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter) return;
                
                if (confirm('Flee from this encounter?')) {
                    encounter.log = encounter.log || [];
                    encounter.log.push('ğŸƒ Fled from encounter');
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    
                    saveToLocalStorage();
                    renderEncounter();
                }
            } catch (error) {
                showError('Flee failed', error.stack);
            }
        }

        function getCurrentPlayer() {
            try {
                if (!GameState.currentSession) return null;
                
                const turnIndex = GameState.currentSession.currentTurnIndex || 0;
                const playerId = GameState.currentSession.turnOrder?.[turnIndex];
                
                return GameState.players?.find(p => p?.id === playerId) || null;
            } catch (error) {
                console.error('Failed to get current player:', error);
                return null;
            }
        }

        // THERAPY MANAGEMENT
        function addObjective() {
            try {
                const text = document.getElementById('newObjective')?.value?.trim();
                const weight = parseInt(document.getElementById('objectiveWeight')?.value || '1');
                
                if (!text) {
                    alert('Please enter objective description');
                    return;
                }
                
                const objective = {
                    id: Date.now(),
                    text: text,
                    weight: weight
                };
                
                GameState.objectives = GameState.objectives || [];
                GameState.objectives.push(objective);
                
                document.getElementById('newObjective').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add objective', error.stack);
            }
        }

        function toggleObjectiveForPlayer(playerId, objectiveId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                therapy.completedObjectives = therapy.completedObjectives || [];
                
                const index = therapy.completedObjectives.indexOf(objectiveId);
                if (index > -1) {
                    therapy.completedObjectives.splice(index, 1);
                } else {
                    therapy.completedObjectives.push(objectiveId);
                }
                
                therapy.pm = 0;
                therapy.completedObjectives.forEach(objId => {
                    const obj = GameState.objectives?.find(o => o?.id === objId);
                    if (obj) {
                        therapy.pm += obj.weight || 0;
                    }
                });
                
                updateMedals(playerId);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to toggle objective', error.stack);
            }
        }

        function updateMedals(playerId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                const pm = therapy.pm || 0;
                const tiers = GameState.config?.medalTiers || { bronze: 10, silver: 25, gold: 50 };
                
                therapy.medals = therapy.medals || [];
                
                if (pm >= tiers.gold && !therapy.medals.includes('gold')) {
                    therapy.medals.push('gold');
                } else if (pm >= tiers.silver && !therapy.medals.includes('silver')) {
                    therapy.medals.push('silver');
                } else if (pm >= tiers.bronze && !therapy.medals.includes('bronze')) {
                    therapy.medals.push('bronze');
                }
            } catch (error) {
                console.error('Failed to update medals:', error);
            }
        }

        // UI UPDATE FUNCTIONS
        function updateAllViews() {
            try {
                updateHomeStats();
                updatePlayersList();
                updateSessionView();
                updateTherapyView();
                updateReportView();
                updateEncounterPlayerDropdown();
                renderEncounter();
            } catch (error) {
                console.error('Failed to update views:', error);
            }
        }

        function updateEncounterPlayerDropdown() {
            try {
                const select = document.getElementById('encounterPlayer');
                if (!select) return;
                
                select.innerHTML = '<option value="">-- Select Player --</option>';
                
                if (GameState.players && GameState.players.length > 0) {
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.name} (${player.class || 'No class'})`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to update encounter player dropdown:', error);
            }
        }

        function updateHomeStats() {
            try {
                const statPlayers = document.getElementById('statPlayers');
                const statMonsters = document.getElementById('statMonsters');
                const statSession = document.getElementById('statSession');
                
                if (statPlayers) statPlayers.textContent = GameState.players?.length || 0;
                if (statMonsters) statMonsters.textContent = GameState.monsters?.length || 0;
                if (statSession) statSession.textContent = GameState.currentSession ? 'Yes' : 'No';
            } catch (error) {
                console.error('Failed to update home stats:', error);
            }
        }

        function updatePlayersList() {
            try {
                const container = document.getElementById('playersList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<div class="card"><p>No players yet. Add one above!</p></div>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const teamCount = player.team?.length || 0;
                    const boxCount = player.box?.length || 0;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <div class="badge badge-${player.playerClassId}">${player.playerClassId}</div>
                            <p>ğŸ’° Money: ${player.money || 0} | â­ Afterlife: ${player.afterlifeCurrency || 0}</p>
                            <p>ğŸ‘¥ Team: ${teamCount}/${GameState.config?.maxTeamSize || 6} | ğŸ“¦ Box: ${boxCount}</p>
                            
                            <h4>Team:</h4>
                            <div class="flex">
                                ${(player.team || []).map(m => renderMonsterCard(m)).join('')}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update players list:', error);
            }
        }

        function renderMonsterCard(monster) {
            try {
                if (!monster) return '';
                
                const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                const xpNeeded = (monster.level || 1) * 100;
                const xpPercent = ((monster.xp || 0) / xpNeeded) * 100;
                
                return `
                    <div class="monster-card ${monster.class || 'common'}">
                        <div style="font-size: 36px;">${monster.emoji || 'ğŸ”®'}</div>
                        <strong>${monster.name || 'Unknown'}</strong>
                        <div class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'common'}</div>
                        <div>Lv ${monster.level || 1}</div>
                        <div class="progress-bar" style="height: 20px;">
                            <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                        </div>
                        <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                        <div class="progress-bar" style="height: 15px;">
                            <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                        </div>
                        <small>${monster.xp || 0}/${xpNeeded} XP</small>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to render monster card:', error);
                return '<div class="monster-card">Error</div>';
            }
        }

        function updateSessionView() {
            try {
                const panel = document.getElementById('activeSessionPanel');
                if (!panel) return;
                
                if (!GameState.currentSession) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                const session = GameState.currentSession;
                document.getElementById('activeSessionName').textContent = session.name || 'Unnamed';
                document.getElementById('sessionCreated').textContent = new Date(session.createdAt).toLocaleString();
                
                const turnList = document.getElementById('turnOrderList');
                if (turnList) {
                    let html = '<div class="flex">';
                    (session.turnOrder || []).forEach((playerId, index) => {
                        const player = GameState.players?.find(p => p?.id === playerId);
                        if (player) {
                            const isCurrent = index === (session.currentTurnIndex || 0);
                            html += `
                                <div class="stat-box" style="${isCurrent ? 'background: var(--success); color: white;' : ''}">
                                    ${isCurrent ? 'â–¶ ' : ''}${player.name}
                                </div>
                            `;
                        }
                    });
                    html += '</div>';
                    turnList.innerHTML = html;
                }
            } catch (error) {
                console.error('Failed to update session view:', error);
            }
        }

        function updateTherapyView() {
            try {
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    let html = '<h4>Current Objectives:</h4>';
                    (GameState.objectives || []).forEach(obj => {
                        if (!obj) return;
                        html += `
                            <div class="objective-item">
                                <strong>Weight ${obj.weight}:</strong> ${obj.text}
                            </div>
                        `;
                    });
                    objectivesList.innerHTML = html;
                }
                
                const therapyPlayersList = document.getElementById('therapyPlayersList');
                if (!therapyPlayersList) return;
                
                if (!GameState.currentSession) {
                    therapyPlayersList.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                let html = '';
                (GameState.players || []).forEach(player => {
                    if (!player) return;
                    
                    const therapy = GameState.currentSession.therapy?.perPlayer?.[player.id];
                    if (!therapy) return;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <p><strong>PM (Merit Points):</strong> ${therapy.pm || 0}</p>
                            <p><strong>Medals:</strong> 
                                ${(therapy.medals || []).map(m => {
                                    const emoji = { bronze: 'ğŸ¥‰', silver: 'ğŸ¥ˆ', gold: 'ğŸ¥‡' }[m] || 'ğŸ…';
                                    return `<span class="medal">${emoji}</span>`;
                                }).join('')}
                            </p>
                            
                            <h4>Objectives:</h4>
                            ${(GameState.objectives || []).map(obj => {
                                if (!obj) return '';
                                const completed = therapy.completedObjectives?.includes(obj.id);
                                return `
                                    <div class="objective-item">
                                        <input type="checkbox" 
                                               ${completed ? 'checked' : ''}
                                               onchange="toggleObjectiveForPlayer(${player.id}, ${obj.id})"
                                               style="width: 30px; height: 30px; cursor: pointer;">
                                        <span>${obj.text} (${obj.weight} PM)</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                });
                
                therapyPlayersList.innerHTML = html;
            } catch (error) {
                console.error('Failed to update therapy view:', error);
            }
        }

        function updateReportView() {
            try {
                const container = document.getElementById('reportContent');
                if (!container) return;
                
                if (!GameState.currentSession) {
                    container.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                const session = GameState.currentSession;
                
                let html = `
                    <div class="card">
                        <h3>Session: ${session.name}</h3>
                        <p>Started: ${new Date(session.createdAt).toLocaleString()}</p>
                        ${session.completedAt ? `<p>Ended: ${new Date(session.completedAt).toLocaleString()}</p>` : '<p>Status: Active</p>'}
                    </div>
                    
                    <div class="card">
                        <h3>Player Summary</h3>
                        ${(GameState.players || []).map(player => {
                            if (!player) return '';
                            const therapy = session.therapy?.perPlayer?.[player.id];
                            if (!therapy) return '';
                            
                            return `
                                <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 10px;">
                                    <h4>${player.name}</h4>
                                    <p>PM Earned: ${therapy.pm || 0}</p>
                                    <p>Medals: ${(therapy.medals || []).join(', ') || 'None yet'}</p>
                                    <p>Objectives Completed: ${therapy.completedObjectives?.length || 0}/${GameState.objectives?.length || 0}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update report view:', error);
            }
        }

        // DATA MANAGEMENT
        function exportData() {
            try {
                const data = JSON.stringify(GameState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                showError('Export failed', error.stack);
            }
        }

        function importData() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target?.files?.[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target?.result || '{}');
                            Object.assign(GameState, data);
                            saveToLocalStorage();
                            updateAllViews();
                            alert('Data imported successfully!');
                        } catch (error) {
                            showError('Import failed', error.stack);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError('Import failed', error.stack);
            }
        }

        function clearAllData() {
            try {
                if (confirm('Are you sure? This will delete ALL data!')) {
                    if (confirm('Really sure? This cannot be undone!')) {
                        localStorage.removeItem('monstrinhomon_state');
                        location.reload();
                    }
                }
            } catch (error) {
                showError('Clear data failed', error.stack);
            }
        }

        function toggleTherapistMode() {
            try {
                const checked = document.getElementById('therapistMode')?.checked;
                const configPanel = document.getElementById('configPanel');
                if (configPanel) {
                    if (checked) {
                        configPanel.classList.remove('hidden');
                    } else {
                        configPanel.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle therapist mode:', error);
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
