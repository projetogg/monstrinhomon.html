<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Monstrinhomon - Therapeutic Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --fire-color: #ff6b35; --water-color: #4ecdc4; --plant-color: #95e06c; --electric-color: #ffe66d;
            --primary: #6c5ce7; --secondary: #fd79a8; --success: #00b894; --warning: #fdcb6e;
            --danger: #d63031; --dark: #2d3436; --light: #dfe6e9;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--dark); min-height: 100vh; overflow-x: hidden;
        }
        
        .app-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .error-panel {
            position: fixed; top: 0; left: 0; right: 0; background: #d63031; color: white;
            padding: 15px; z-index: 10000; display: none; font-family: monospace; font-size: 14px;
        }
        .error-panel.show { display: block; }
        .error-panel button {
            background: white; color: #d63031; border: none; padding: 8px 15px; margin: 5px;
            border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;
        }
        
        .header {
            background: white; border-radius: 20px; padding: 20px; margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header h1 { color: var(--primary); font-size: 2.5em; text-align: center; margin-bottom: 10px; }
        
        .tabs {
            display: flex; gap: 10px; overflow-x: auto; padding: 10px 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab-button {
            background: var(--light); border: none; padding: 15px 25px; border-radius: 15px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;
            white-space: nowrap; min-width: 100px; min-height: 44px;
        }
        .tab-button.active {
            background: var(--primary); color: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }
        
        .tab-content {
            display: none; background: white; border-radius: 20px; padding: 25px;
            min-height: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tab-content.active { display: block; animation: fadeIn 0.3s; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .btn {
            background: var(--primary); color: white; border: none; padding: 15px 30px;
            border-radius: 12px; font-size: 16px; font-weight: bold; cursor: pointer;
            transition: all 0.3s; min-height: 44px; min-width: 44px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-success { background: var(--success); }
        .btn-danger { background: var(--danger); }
        .btn-warning { background: var(--warning); color: var(--dark); }
        .btn-secondary { background: var(--secondary); }
        .btn-large { font-size: 20px; padding: 20px 40px; }
        
        input, select, textarea {
            width: 100%; padding: 12px; border: 2px solid var(--light); border-radius: 10px;
            font-size: 16px; margin: 8px 0; min-height: 44px;
        }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); }
        
        .card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px; padding: 20px; margin: 15px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .monster-card {
            display: inline-block; width: 150px; margin: 10px; padding: 15px;
            border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .monster-card:active { transform: scale(0.95); }
        .monster-card.fire { background: linear-gradient(135deg, #ff6b35 0%, #ff8c61 100%); }
        .monster-card.water { background: linear-gradient(135deg, #4ecdc4 0%, #7ee0d7 100%); }
        .monster-card.plant { background: linear-gradient(135deg, #95e06c 0%, #b3eb93 100%); }
        .monster-card.electric { background: linear-gradient(135deg, #ffe66d 0%, #fff09c 100%); }
        
        .progress-bar {
            width: 100%; height: 30px; background: var(--light); border-radius: 15px;
            overflow: hidden; position: relative; margin: 10px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--success) 0%, #00b894 100%);
            transition: width 0.5s; display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px;
        }
        .progress-fill.hp { background: linear-gradient(90deg, #d63031 0%, #ff7675 100%); }
        .progress-fill.xp { background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%); }
        
        .badge {
            display: inline-block; padding: 5px 12px; border-radius: 20px;
            font-size: 12px; font-weight: bold; margin: 2px;
        }
        .badge-common { background: #95a5a6; color: white; }
        .badge-rare { background: #3498db; color: white; }
        .badge-epic { background: #9b59b6; color: white; }
        .badge-legendary { background: #f39c12; color: white; }
        .badge-fire { background: var(--fire-color); color: white; }
        .badge-water { background: var(--water-color); color: white; }
        .badge-plant { background: var(--plant-color); color: white; }
        .badge-electric { background: var(--electric-color); color: var(--dark); }
        
        .encounter-panel {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-radius: 20px; padding: 25px; margin: 20px 0;
        }
        
        .combat-log {
            background: white; border-radius: 15px; padding: 15px; max-height: 300px;
            overflow-y: auto; font-family: monospace; font-size: 14px;
        }
        .combat-log div { padding: 5px 0; border-bottom: 1px solid var(--light); }
        
        .therapist-panel {
            border: 3px dashed var(--warning); border-radius: 20px; padding: 20px;
            margin: 20px 0; background: #fffbea;
        }
        
        .objective-item {
            display: flex; align-items: center; gap: 10px; padding: 15px;
            background: white; border-radius: 10px; margin: 10px 0;
        }
        
        .medal { font-size: 48px; display: inline-block; margin: 10px; }
        .hidden { display: none !important; }
        .flex { display: flex; gap: 15px; flex-wrap: wrap; }
        .flex-center { display: flex; justify-content: center; align-items: center; gap: 15px; }
        
        .stat-box {
            display: inline-block; padding: 10px 20px; background: var(--light);
            border-radius: 10px; margin: 5px; font-weight: bold;
        }
        
        #mmToastHost{
          position:fixed;
          top:12px;
          right:12px;
          z-index:9999;
          display:flex;
          flex-direction:column;
          gap:8px;
        }
        .mm-toast{
          background:rgba(20,20,20,0.92);
          color:#fff;
          padding:10px 12px;
          border-radius:12px;
          font-size:14px;
          max-width:320px;
          box-shadow:0 8px 24px rgba(0,0,0,0.25);
        }
        
        /* ============================= */
        /* FEATURE 3.8 â€” BATTLE POLISH */
        /* ============================= */
        
        /* Floating damage/heal text */
        .floating-text {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
        }
        
        .floating-text.damage {
            color: #d32f2f;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .floating-text.heal {
            color: #2e7d32;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .floating-text.crit {
            color: #ff6f00;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(255,193,7,0.8), 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            70% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-60px);
            }
        }
        
        /* Flash target effects */
        .flash-crit {
            animation: flashCrit 0.4s ease-out;
        }
        
        .flash-fail {
            animation: flashFail 0.4s ease-out;
        }
        
        .flash-hit {
            animation: flashHit 0.3s ease-out;
        }
        
        @keyframes flashCrit {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px 5px rgba(255,193,7,0.8); background-color: rgba(255,193,7,0.2); }
        }
        
        @keyframes flashFail {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px 5px rgba(211,47,47,0.8); background-color: rgba(211,47,47,0.2); }
        }
        
        @keyframes flashHit {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 15px 3px rgba(66,66,66,0.6); background-color: rgba(66,66,66,0.1); }
        }
        
        /* Last d20 roll badge */
        .d20-badge {
            display: inline-block;
            padding: 8px 15px;
            margin: 10px 0;
            border-radius: 8px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            font-size: 16px;
            font-weight: bold;
        }
        
        .d20-badge.crit {
            background: linear-gradient(135deg, #fff9c4 0%, #ffeb3b 100%);
            border-color: #fbc02d;
            color: #f57c00;
            box-shadow: 0 2px 8px rgba(251,192,45,0.4);
        }
        
        .d20-badge.fail {
            background: linear-gradient(135deg, #ffcdd2 0%, #ef5350 100%);
            border-color: #e53935;
            color: #b71c1c;
            box-shadow: 0 2px 8px rgba(229,57,53,0.4);
        }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8em; }
            .tab-button { padding: 12px 20px; font-size: 14px; }
        }
        
        /* Toast notifications */
        .mm-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10001;
            transform: translateX(400px);
            transition: transform 0.3s ease-out;
        }
        
        .mm-toast.show {
            transform: translateX(0);
        }
        
        /* ===== Feature 4.0: Menu / Overlays ===== */
        .mm-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 30% 20%, rgba(120,80,255,0.25), transparent 45%),
                        radial-gradient(circle at 70% 70%, rgba(0,200,255,0.18), transparent 45%),
                        rgba(10,10,14,0.92);
            color: #fff;
            z-index: 9999;
            display: none;
        }

        .mm-overlay.show { display: flex; }

        .mm-overlay .mm-card {
            width: min(560px, calc(100vw - 24px));
            margin: auto;
            background: rgba(20,20,28,0.85);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.45);
        }

        .mm-title { font-size: 28px; font-weight: 900; margin: 6px 0 8px; }
        .mm-sub { opacity: 0.9; margin: 0 0 14px; line-height: 1.3; }

        .mm-btn {
            width: 100%;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-weight: 800;
            font-size: 16px;
            cursor: pointer;
            margin: 8px 0;
            min-height: 44px;
        }
        .mm-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .mm-row { display: flex; gap: 10px; }
        .mm-row .mm-btn { width: auto; flex: 1; }

        .mm-field { margin: 10px 0; }
        .mm-field label { display:block; font-size: 13px; opacity: 0.9; margin-bottom: 6px; }
        .mm-field input, .mm-field select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.25);
            color: #fff;
            outline: none;
        }

        .mm-hint { font-size: 12px; opacity: 0.75; margin-top: 6px; }

        /* Feature 4.3: Save Slots */
        .mm-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.08); 
            color:#fff; 
        }
        
        .mm-slot { 
            border-radius:14px; 
            padding:14px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.06); 
        }
        
        .mm-slot h3 { 
            margin:0 0 8px 0; 
            font-size:18px;
        }
        
        .mm-slot-meta { 
            opacity:0.85; 
            font-size:13px; 
            line-height:1.4; 
        }
        
        .mm-slot-meta > div {
            margin:3px 0;
        }
        
        .mm-slot-actions { 
            display:flex; 
            gap:8px; 
            flex-wrap:wrap; 
            margin-top:12px; 
        }
    </style>
</head>
<body>
    <div id="errorPanel" class="error-panel">
        <div id="errorMessage"></div>
        <button onclick="copyError()">ğŸ“‹ Copy Error</button>
        <button onclick="dismissError()">âœ– Dismiss</button>
    </div>

    <div class="app-container">
        <div class="header">
            <h1>ğŸ® Monstrinhomon ğŸŒŸ</h1>
            <div class="tabs">
                <button class="tab-button active" onclick="switchTab('home')">ğŸ  Home</button>
                <button class="tab-button" onclick="switchTab('session')">ğŸ“‹ Session</button>
                <button class="tab-button" onclick="switchTab('players')">ğŸ‘¥ Players</button>
                <button class="tab-button" onclick="switchTab('encounter')">âš”ï¸ Encounter</button>
                <button class="tab-button" onclick="switchTab('therapy')">ğŸ¯ Therapy</button>
                <button class="tab-button" onclick="switchTab('report')">ğŸ“Š Report</button>
                <button class="tab-button" onclick="switchTab('settings')">âš™ï¸ Settings</button>
            </div>
        </div>

        <div id="tabHome" class="tab-content active">
            <h2>Welcome to Monstrinhomon! ğŸ‰</h2>
            <p style="font-size: 18px; margin: 20px 0;">A therapeutic game for young trainers.</p>
            
            <div class="card">
                <h3>Quick Stats</h3>
                <div id="homeStats">
                    <div class="stat-box">Active Players: <span id="statPlayers">0</span></div>
                    <div class="stat-box">Total Monsters: <span id="statMonsters">0</span></div>
                    <div class="stat-box">Session Active: <span id="statSession">No</span></div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div class="flex">
                    <button class="btn btn-large btn-success" onclick="switchTab('session')">Start New Session</button>
                    <button class="btn btn-large" onclick="switchTab('players')">Manage Players</button>
                    <button class="btn btn-large btn-secondary" onclick="switchTab('encounter')">Start Encounter</button>
                </div>
            </div>
        </div>

        <div id="tabSession" class="tab-content">
            <h2>Session Management ğŸ“‹</h2>
            
            <div class="card">
                <h3>Create New Session</h3>
                <input type="text" id="sessionName" placeholder="Session Name (e.g., Therapy Session 2024-01-15)">
                <button class="btn btn-success" onclick="createSession()">Create Session</button>
            </div>

            <div id="activeSessionPanel" class="card hidden">
                <h3>Active Session: <span id="activeSessionName"></span></h3>
                <p>Created: <span id="sessionCreated"></span></p>
                
                <h4>Turn Order</h4>
                <div id="turnOrderList"></div>
                
                <button class="btn btn-warning" onclick="nextTurn()">Next Turn â–¶</button>
                <button class="btn btn-danger" onclick="endSession()">End Session</button>
            </div>
        </div>

        <div id="tabPlayers" class="tab-content">
            <h2>Player Management ğŸ‘¥</h2>
            
            <div class="card">
                <h3>Add New Player</h3>
                <input type="text" id="playerName" placeholder="Player Name">
                <select id="playerClass">
                    <option value="">Select Class</option>
                    <option value="Guerreiro">âš”ï¸ Guerreiro</option>
                    <option value="Mago">ğŸ”® Mago</option>
                    <option value="Curandeiro">ğŸ’š Curandeiro</option>
                    <option value="BÃ¡rbaro">ğŸ’ª BÃ¡rbaro</option>
                    <option value="Ladino">ğŸ—¡ï¸ Ladino</option>
                    <option value="Bardo">ğŸµ Bardo</option>
                    <option value="CaÃ§ador">ğŸ¹ CaÃ§ador</option>
                    <option value="Animalista">ğŸ¾ Animalista</option>
                </select>
                <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
            </div>

            <div id="playersList"></div>
        </div>

        <div id="tabEncounter" class="tab-content">
            <h2>Encounter âš”ï¸</h2>
            
            <div class="card">
                <h3>Start New Encounter</h3>
                <select id="encounterType" onchange="updateEncounterUI()">
                    <option value="wild">ğŸŒŸ Wild Monster (Individual Capture)</option>
                    <option value="trainer">ğŸ‘¤ Trainer Battle (Group)</option>
                    <option value="boss">ğŸ‘¹ Boss Battle (Group)</option>
                    <option value="event">ğŸ“– Narrative Event</option>
                </select>
                
                <!-- Para encontros individuais (wild) -->
                <div id="playerSelectDiv" style="margin-top: 15px;">
                    <label><strong>Select Player for Individual Encounter:</strong></label>
                    <select id="encounterPlayer">
                        <option value="">-- Select Player --</option>
                    </select>
                </div>
                
                <!-- Para encontros em grupo (trainer/boss) -->
                <div id="groupSelectDiv" class="hidden" style="margin-top: 15px;">
                    <label><strong>Select Participants (1-6):</strong></label>
                    <div id="groupParticipantsList" style="margin-top: 10px;"></div>
                    <div style="margin-top: 10px;">
                        <label><strong>Enemy Level:</strong></label>
                        <select id="enemyLevel">
                            <option value="1">1</option>
                            <option value="3">3</option>
                            <option value="5" selected>5</option>
                            <option value="7">7</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                    
                    <!-- Team Reorder UI -->
                    <div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                        <h4 style="margin-top: 0;">âš”ï¸ Organize Equipes</h4>
                        <p style="font-size: 0.9em; color: #666;">Reordene o time de cada jogador. O primeiro monstrinho vivo serÃ¡ usado na batalha.</p>
                        <div id="teamReorderContainer"></div>
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="startEncounter()">Start Encounter</button>
            </div>

            <div id="encounterPanel" class="hidden"></div>
        </div>

        <div id="tabTherapy" class="tab-content">
            <h2>Therapeutic Objectives ğŸ¯</h2>
            
            <div class="therapist-panel">
                <h3>âš•ï¸ Therapist Controls</h3>
                
                <div class="card">
                    <h4>Add Objective</h4>
                    <input type="text" id="newObjective" placeholder="Objective description">
                    <select id="objectiveWeight">
                        <option value="1">Low Weight (1)</option>
                        <option value="2">Medium Weight (2)</option>
                        <option value="3">High Weight (3)</option>
                    </select>
                    <button class="btn btn-success" onclick="addObjective()">Add Objective</button>
                </div>

                <div id="objectivesList"></div>
            </div>

            <div id="therapyPlayersList"></div>
        </div>

        <div id="tabReport" class="tab-content">
            <h2>Session Report ğŸ“Š</h2>
            <div id="reportContent"></div>
        </div>

        <div id="tabSettings" class="tab-content">
            <h2>Settings âš™ï¸</h2>
            
            <div class="card">
                <h3>Game Configuration</h3>
                <label>
                    <input type="checkbox" id="therapistMode" onchange="toggleTherapistMode()">
                    Therapist Mode (Show advanced controls)
                </label>
            </div>

            <!-- Therapist Mode Panel - Commit 1 -->
            <div id="therapistPanel" class="card" style="display:none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h3>ğŸ”¬ Therapist Mode Tools</h3>
                <p style="font-size: 0.9em; opacity: 0.9;">Advanced debugging and testing controls</p>
                <div id="therapistPanelContent">
                    <!-- Commit 2: Export/Import Save Tools -->
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                        <h4 style="margin-bottom: 10px;">ğŸ’¾ Save Management</h4>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="therapistExportSave()" style="flex: 1; min-width: 120px;">ğŸ“¤ Export Save (JSON)</button>
                            <button class="btn btn-warning" onclick="therapistImportSave()" style="flex: 1; min-width: 120px;">ğŸ“¥ Import Save (JSON)</button>
                        </div>
                        <textarea id="therapistJsonArea" placeholder="Paste JSON here to import..." 
                            style="width: 100%; min-height: 100px; margin-top: 10px; padding: 8px; font-family: monospace; font-size: 12px; border-radius: 5px; display: none;"></textarea>
                        <div style="display: flex; gap: 10px; margin-top: 10px; display: none;" id="therapistJsonButtons">
                            <button class="btn btn-success" onclick="therapistLoadJson()" style="flex: 1;">âœ… Load JSON</button>
                            <button class="btn btn-danger" onclick="therapistCancelImport()" style="flex: 1;">âŒ Cancel</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸµ Audio Configuration</h3>
                <div style="display:grid; gap:12px;">
                    <div>
                        <div style="margin-bottom:6px;">ğŸ§ Volume SFX</div>
                        <input id="mmSfxVol" type="range" min="0" max="100" value="70"
                            oninput="Audio.setSfxVolume(Number(this.value)/100)">
                    </div>

                    <div>
                        <div style="margin-bottom:6px;">ğŸµ Volume MÃºsica (preparado)</div>
                        <input id="mmMusicVol" type="range" min="0" max="100" value="40"
                            oninput="Audio.setMusicVolume(Number(this.value)/100)">
                    </div>

                    <div style="display:flex; gap:10px; flex-wrap:wrap;">
                        <button id="mmMuteBtn" class="btn" style="width:auto;" onclick="Audio.toggleMute()">ğŸ”Š Som</button>
                        <button class="btn" style="width:auto;" onclick="Audio.playSfx('ui_click')">âœ… Testar som</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Data Management</h3>
                <button class="btn btn-success" onclick="exportData()">ğŸ“¥ Export All Data</button>
                <button class="btn btn-warning" onclick="importData()">ğŸ“¤ Import Data</button>
                <button class="btn btn-danger" onclick="clearAllData()">ğŸ—‘ï¸ Clear All Data</button>
            </div>

            <div id="configPanel" class="card hidden">
                <h3>Advanced Configuration</h3>
                <div id="configEditor"></div>
            </div>
        </div>
    </div>

    <!-- ===== Feature 4.0 Overlays ===== -->
    <div id="mmIntro" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">ğŸ® Monstrinhomon</div>
            <p class="mm-sub">RPG terapÃªutico infantil (PokÃ©mon + RPG).<br/>Clique para comeÃ§ar.</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">âœ¨ Iniciar</button>
            <p class="mm-hint">Dica: o jogo salva automaticamente em seu navegador.</p>
        </div>
    </div>

    <div id="mmMenu" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Menu Principal</div>
            <button class="mm-btn" onclick="mmOpenSaves()">ğŸ“‚ Gerenciar Saves</button>
            <button class="mm-btn" onclick="mmOpenSlotPickerForNewGame()">ğŸ® Novo Jogo</button>
            <button class="mm-btn" onclick="mmStartTutorial()">ğŸ“ Tutorial</button>
            <button class="mm-btn" onclick="mmShowConfig()">âš™ï¸ ConfiguraÃ§Ãµes</button>
            <button id="mmTherapistBtn" class="mm-btn" onclick="mmOpenTherapistPanel()" style="display:none;">ğŸ§‘â€ğŸ« Mestre</button>
            <div class="mm-row">
                <button class="mm-btn" onclick="mmCloseAllOverlays()">Fechar</button>
                <button class="mm-btn" onclick="mmResetSaveConfirm()">ğŸ—‘ï¸ Apagar Save</button>
            </div>
        </div>
    </div>

    <div id="mmNewGame" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">Novo Jogo</div>

            <div id="mmNewGameStep"></div>

            <div class="mm-row">
                <button class="mm-btn" onclick="mmNewGameBack()">â¬…ï¸ Voltar</button>
                <button class="mm-btn" onclick="mmNewGameNext()">â¡ï¸ PrÃ³ximo</button>
            </div>
        </div>
    </div>

    <div id="mmSlotPicker" class="mm-overlay hidden">
        <div class="mm-card" style="max-width:640px;">
            <div class="mm-title">ğŸ’¾ Escolher Slot</div>
            <div style="opacity:0.9; margin-bottom:12px;">
                Selecione onde salvar este <b>Novo Jogo</b>. (VocÃª pode exportar/importar depois.)
            </div>

            <div id="mmSlotPickerList" style="display:grid; gap:10px;"></div>

            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;">
                <button class="mm-btn" style="width:auto;" onclick="mmCancelSlotPicker()">â†©ï¸ Voltar</button>
            </div>
        </div>
    </div>

    <div id="mmConfig" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">ConfiguraÃ§Ãµes</div>
            <p class="mm-sub">MVP: placeholder. (Depois entra volume, modo terapeuta, etc.)</p>
            <button class="mm-btn" onclick="mmShowMainMenu()">Voltar</button>
        </div>
    </div>

    <!-- Feature 4.6: Therapist Mode Panel -->
    <div id="mmTherapist" class="mm-overlay">
        <div class="mm-card">
            <div class="mm-title">ğŸ§‘â€ğŸ« Therapist Mode</div>
            <div id="mmTherapistBody"></div>

            <div class="mm-row" style="margin-top:12px;">
                <button class="mm-btn" onclick="mmCloseAllOverlays()">Fechar</button>
            </div>
        </div>
    </div>

    <!-- Feature 4.3: Save Slots Screen -->
    <div id="mmSavesScreen" class="mm-overlay hidden">
        <div class="mm-card" style="max-width:820px;">
            <div class="mm-title">ğŸ“‚ Gerenciar Saves</div>
            <div id="mmSavesSlots" style="display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px;"></div>

            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:16px;">
                <label class="mm-btn" style="width:auto; display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
                    â¬†ï¸ Importar JSON
                    <input id="mmImportFile" type="file" accept="application/json" style="display:none;">
                </label>

                <select id="mmImportSlotPick" class="mm-input" style="min-width:160px;">
                    <option value="1">Importar para Slot 1</option>
                    <option value="2">Importar para Slot 2</option>
                    <option value="3">Importar para Slot 3</option>
                </select>

                <button class="mm-btn" style="width:auto;" onclick="mmCloseSaves()">â†©ï¸ Voltar</button>
            </div>

            <div style="opacity:0.75; font-size:12px; margin-top:10px;">
                Dica: Exportar/Importar Ã© ideal para backup e trocar de dispositivo (iPad).
            </div>
        </div>
    </div>

    <!-- Feature 4.1.1: Start Choice Modal -->
    <div id="mmStartChoice" class="mm-overlay hidden">
        <div class="mm-card">
            <h2 style="font-size: 28px; font-weight: 900; margin: 6px 0 8px;">ğŸ® ComeÃ§ar</h2>
            <p style="opacity: 0.9; margin: 0 0 14px; line-height: 1.3;">Quer fazer o <b>Tutorial</b> agora?</p>

            <label style="display:flex; gap:10px; align-items:center; margin:14px 0;">
                <input type="checkbox" id="mmRememberTutorialChoice">
                Lembrar minha escolha
            </label>

            <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
                <button class="mm-btn" onclick="mmStartTutorialFromChoice()">ğŸ“ Fazer Tutorial</button>
                <button class="mm-btn" style="opacity:0.9;" onclick="mmSkipTutorialFromChoice()">ğŸš€ Pular</button>
            </div>
        </div>
    </div>

    <script>
        // GLOBAL ERROR HANDLER
        window.addEventListener('error', function(event) {
            showError(event.error || event.message, event.error?.stack || '');
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise Rejection: ' + event.reason, event.reason?.stack || '');
        });

        function showError(message, stack) {
            const panel = document.getElementById('errorPanel');
            const messageDiv = document.getElementById('errorMessage');
            messageDiv.innerHTML = `<strong>Error:</strong> ${message}<br><pre>${stack}</pre>`;
            panel.classList.add('show');
            console.error('Error caught:', message, stack);
        }

        function dismissError() {
            document.getElementById('errorPanel').classList.remove('show');
        }

        function copyError() {
            const text = document.getElementById('errorMessage').innerText;
            navigator.clipboard.writeText(text).catch(e => alert('Copy failed: ' + e));
        }

        // ===== Feature 4.4: Audio (MVP without audio files) =====
        const Audio = (() => {
            let ctx = null;
            let unlocked = false;

            let sfxVol = clamp01(Number(localStorage.getItem("mm_audio_sfx") ?? 0.7));
            let musVol = clamp01(Number(localStorage.getItem("mm_audio_music") ?? 0.4));
            let muted = (localStorage.getItem("mm_audio_muted") === "1");

            function clamp01(v){ return isFinite(v) ? Math.max(0, Math.min(1, v)) : 0; }

            function init() {
                // Initialize UI with saved settings
                syncUI();
            }

            function ensureCtx() {
                // Lazy AudioContext creation - delays until first audio interaction
                if (!ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return null;
                    ctx = new AC();
                }
                return ctx;
            }

            async function unlock() {
                try {
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") await c.resume();
                    // iOS unlock: play a silent buffer
                    const o = c.createOscillator();
                    const g = c.createGain();
                    g.gain.value = 0.0001;
                    o.connect(g).connect(c.destination);
                    o.start();
                    o.stop(c.currentTime + 0.01);
                    unlocked = true;
                } catch {}
            }

            function setSfxVolume(v) {
                sfxVol = clamp01(v);
                localStorage.setItem("mm_audio_sfx", String(sfxVol));
                syncUI();
            }
            function setMusicVolume(v) {
                musVol = clamp01(v);
                localStorage.setItem("mm_audio_music", String(musVol));
                syncUI();
            }
            function toggleMute() {
                muted = !muted;
                localStorage.setItem("mm_audio_muted", muted ? "1" : "0");
                syncUI();
            }

            function playTone(freq, durMs, vol, type="sine") {
                try {
                    if (muted) return;
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") return; // not unlocked yet
                    const o = c.createOscillator();
                    const g = c.createGain();
                    o.type = type;
                    o.frequency.value = freq;
                    
                    // Clamp vol parameter to valid range
                    const clampedVol = Math.max(0, Math.min(1, vol));
                    g.gain.value = clampedVol * sfxVol;

                    o.connect(g).connect(c.destination);

                    const now = c.currentTime;
                    const dur = durMs / 1000;

                    // Envelope to avoid clicks
                    const safeGain = Math.max(0.0001, g.gain.value);
                    g.gain.setValueAtTime(0.0001, now);
                    g.gain.exponentialRampToValueAtTime(safeGain, now + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

                    o.start(now);
                    o.stop(now + dur + 0.02);
                } catch {}
            }

            // Helper to schedule multi-tone sounds using AudioContext timeline
            function playMultiTone(tones) {
                try {
                    if (muted) return;
                    const c = ensureCtx();
                    if (!c) return;
                    if (c.state === "suspended") return;
                    
                    const now = c.currentTime;
                    
                    for (const tone of tones) {
                        const startTime = now + (tone.delay || 0) / 1000;
                        const o = c.createOscillator();
                        const g = c.createGain();
                        o.type = tone.type || "sine";
                        o.frequency.value = tone.freq;
                        
                        const clampedVol = Math.max(0, Math.min(1, tone.vol));
                        const targetGain = clampedVol * sfxVol;
                        const safeGain = Math.max(0.0001, targetGain);
                        
                        o.connect(g).connect(c.destination);
                        
                        const dur = tone.durMs / 1000;
                        g.gain.setValueAtTime(0.0001, startTime);
                        g.gain.exponentialRampToValueAtTime(safeGain, startTime + 0.01);
                        g.gain.exponentialRampToValueAtTime(0.0001, startTime + dur);
                        
                        o.start(startTime);
                        o.stop(startTime + dur + 0.02);
                    }
                } catch {}
            }

            // Sound palette using synthesized tones (can be replaced with audio files in the future)
            function playSfx(name) {
                try {
                    if (muted) return;
                    // Each event uses distinct frequency/waveform combinations for audio differentiation
                    switch (name) {
                        case "ui_click":   
                            playTone(660, 60, 0.6, "square"); 
                            break;
                        case "hit":        
                            playTone(220, 80, 0.7, "sawtooth"); 
                            break;
                        case "miss":       
                            playTone(140, 120, 0.5, "triangle"); 
                            break;
                        case "crit":       
                            playMultiTone([
                                { freq: 880, durMs: 80, vol: 0.8, type: "square", delay: 0 },
                                { freq: 990, durMs: 80, vol: 0.7, type: "square", delay: 70 }
                            ]);
                            break;
                        case "heal":       
                            playMultiTone([
                                { freq: 523, durMs: 80, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 659, durMs: 80, vol: 0.5, type: "sine", delay: 90 }
                            ]);
                            break;
                        case "capture_ok": 
                            playMultiTone([
                                { freq: 784, durMs: 70, vol: 0.7, type: "sine", delay: 0 },
                                { freq: 988, durMs: 90, vol: 0.7, type: "sine", delay: 80 }
                            ]);
                            break;
                        case "capture_fail": 
                            playMultiTone([
                                { freq: 196, durMs: 90, vol: 0.7, type: "sawtooth", delay: 0 },
                                { freq: 164, durMs: 110, vol: 0.6, type: "sawtooth", delay: 90 }
                            ]);
                            break;
                        case "win":        
                            playMultiTone([
                                { freq: 659, durMs: 80, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 784, durMs: 90, vol: 0.6, type: "sine", delay: 90 },
                                { freq: 988, durMs: 120, vol: 0.6, type: "sine", delay: 190 }
                            ]);
                            break;
                        case "lose":       
                            playMultiTone([
                                { freq: 220, durMs: 120, vol: 0.7, type: "triangle", delay: 0 },
                                { freq: 196, durMs: 140, vol: 0.6, type: "triangle", delay: 120 }
                            ]);
                            break;
                        case "levelup":    
                            playMultiTone([
                                { freq: 740, durMs: 70, vol: 0.6, type: "sine", delay: 0 },
                                { freq: 880, durMs: 90, vol: 0.7, type: "sine", delay: 80 }
                            ]);
                            break;
                        case "evolve":     
                            playMultiTone([
                                { freq: 523, durMs: 80, vol: 0.5, type: "sine", delay: 0 },
                                { freq: 659, durMs: 90, vol: 0.6, type: "sine", delay: 90 },
                                { freq: 784, durMs: 120, vol: 0.7, type: "sine", delay: 190 }
                            ]);
                            break;
                        default:           
                            playTone(440, 60, 0.4, "sine");
                    }
                } catch {}
            }

            function syncUI() {
                // Optional: only runs if elements exist
                const sfx = document.getElementById("mmSfxVol");
                const mus = document.getElementById("mmMusicVol");
                const mute = document.getElementById("mmMuteBtn");
                if (sfx) sfx.value = String(Math.round(sfxVol * 100));
                if (mus) mus.value = String(Math.round(musVol * 100));
                if (mute) mute.textContent = muted ? "ğŸ”‡ Mudo" : "ğŸ”Š Som";
            }

            return { init, unlock, playSfx, setSfxVolume, setMusicVolume, toggleMute, syncUI };
        })();

        // Call once on boot
        Audio.init();

        // iOS unlock: first user gesture
        window.addEventListener("pointerdown", () => Audio.unlock(), { once: true });
        window.addEventListener("keydown", () => Audio.unlock(), { once: true });

        // STATE MANAGEMENT
        const GameState = {
            players: [],
            monsters: [],
            sessions: [],
            currentSession: null,
            currentEncounter: null,
            objectives: [],
            therapistMode: false, // Feature 4.6: Therapist Mode
            // COMMIT 4: Save versioning
            meta: {
                saveVersion: 1  // Current save format version
            },
            config: {
                maxTeamSize: 6,
                maxLevel: 100,
                levelExpo: 1.5,
                battleXpBase: 15,
                captureModel: 'threshold_no_dice',
                // Vantagens de Classe (conforme GAME_RULES.md)
                classAdvantages: {
                    'Guerreiro': { strong: 'Ladino', weak: 'Curandeiro' },
                    'Ladino': { strong: 'Mago', weak: 'Guerreiro' },
                    'Mago': { strong: 'BÃ¡rbaro', weak: 'Ladino' },
                    'BÃ¡rbaro': { strong: 'CaÃ§ador', weak: 'Mago' },
                    'CaÃ§ador': { strong: 'Bardo', weak: 'BÃ¡rbaro' },
                    'Bardo': { strong: 'Curandeiro', weak: 'CaÃ§ador' },
                    'Curandeiro': { strong: 'Guerreiro', weak: 'Bardo' },
                    'Animalista': { strong: null, weak: null } // Neutro
                },
                // Thresholds de captura por raridade (sem dado)
                captureThreshold: {
                    'Comum': 0.35,
                    'Incomum': 0.30,
                    'Raro': 0.22,
                    'MÃ­stico': 0.15,
                    'LendÃ¡rio': 0.08
                },
                // Multiplicadores de raridade
                rarityPower: {
                    'Comum': 1.00,
                    'Incomum': 1.08,
                    'Raro': 1.18,
                    'MÃ­stico': 1.32,
                    'LendÃ¡rio': 1.50
                },
                rarityXP: {
                    'Comum': 1.00,
                    'Incomum': 1.05,
                    'Raro': 1.10,
                    'MÃ­stico': 1.15,
                    'LendÃ¡rio': 1.25
                },
                // Chance base de fuga por raridade
                fleeBase: {
                    'Comum': 10,
                    'Incomum': 12,
                    'Raro': 15,
                    'MÃ­stico': 18,
                    'LendÃ¡rio': 25
                },
                medalTiers: { bronze: 5, silver: 12, gold: 25 }
            }
        };

        // MONSTER CATALOG (baseado em MONSTROS.csv)
        const MONSTER_CATALOG = [
            { id: 'MON_001', name: 'Cantapau', class: 'Bardo', rarity: 'Comum', baseHp: 28, baseAtk: 6, baseDef: 4, baseSpd: 6, baseEne: 8, emoji: 'ğŸµ' },
            { id: 'MON_002', name: 'Pedrino', class: 'Guerreiro', rarity: 'Comum', baseHp: 32, baseAtk: 7, baseDef: 6, baseSpd: 5, baseEne: 6, emoji: 'âš”ï¸', evolvesTo: 'MON_002B', evolvesAt: 12 },
            { id: 'MON_002B', name: 'Pedronar', class: 'Guerreiro', rarity: 'Incomum', baseHp: 42, baseAtk: 10, baseDef: 8, baseSpd: 6, baseEne: 6, emoji: 'âš”ï¸', evolvesTo: 'MON_002C', evolvesAt: 25 },
            { id: 'MON_002C', name: 'Pedragon', class: 'Guerreiro', rarity: 'Raro', baseHp: 56, baseAtk: 14, baseDef: 11, baseSpd: 8, baseEne: 6, emoji: 'ğŸ—¡ï¸' },
            { id: 'MON_003', name: 'FaÃ­scari', class: 'Mago', rarity: 'Comum', baseHp: 26, baseAtk: 8, baseDef: 3, baseSpd: 7, baseEne: 10, emoji: 'ğŸ”®' },
            { id: 'MON_004', name: 'Ninfolha', class: 'Curandeiro', rarity: 'Comum', baseHp: 30, baseAtk: 4, baseDef: 4, baseSpd: 5, baseEne: 12, emoji: 'ğŸ’š' },
            { id: 'MON_005', name: 'Garruncho', class: 'CaÃ§ador', rarity: 'Comum', baseHp: 29, baseAtk: 7, baseDef: 3, baseSpd: 8, baseEne: 8, emoji: 'ğŸ¹' },
            { id: 'MON_006', name: 'Lobinho', class: 'Animalista', rarity: 'Comum', baseHp: 31, baseAtk: 6, baseDef: 5, baseSpd: 5, baseEne: 7, emoji: 'ğŸº' },
            { id: 'MON_007', name: 'TrovÃ£o', class: 'BÃ¡rbaro', rarity: 'Comum', baseHp: 33, baseAtk: 8, baseDef: 4, baseSpd: 4, baseEne: 6, emoji: 'âš¡' },
            { id: 'MON_008', name: 'Sombrio', class: 'Ladino', rarity: 'Comum', baseHp: 27, baseAtk: 7, baseDef: 4, baseSpd: 8, baseEne: 6, emoji: 'ğŸŒ‘' },
            { id: 'MON_100', name: 'Rato-de-Lama', class: 'Guerreiro', rarity: 'Comum', baseHp: 20, baseAtk: 5, baseDef: 3, baseSpd: 4, baseEne: 4, emoji: 'ğŸ€' }
        ];

        // ENE REGEN CONSTANTS por classe (fallback)
        const ENE_REGEN_BY_CLASS = {
            'Mago': { pct: 0.18, min: 3 },
            'Curandeiro': { pct: 0.18, min: 3 },
            'Bardo': { pct: 0.14, min: 2 },
            'CaÃ§ador': { pct: 0.14, min: 2 },
            'Ladino': { pct: 0.14, min: 2 },
            'Animalista': { pct: 0.12, min: 2 },
            'BÃ¡rbaro': { pct: 0.12, min: 2 },
            'Guerreiro': { pct: 0.10, min: 1 }
        };

        // POWER BÃSICO por classe (ataque sem habilidade)
        const BASIC_ATTACK_POWER = {
            'Guerreiro': 12,
            'Mago': 11,
            'Curandeiro': 10,
            'BÃ¡rbaro': 14,
            'Ladino': 12,
            'Bardo': 11,
            'CaÃ§ador': 13,
            'Animalista': 12
        };

        // SKILL DEFINITIONS (inline - por classe e estÃ¡gio)
        const SKILL_DEFS = {
            // GUERREIRO
            'Guerreiro': {
                'Golpe de Espada': [
                    { tier: 1, name: 'Golpe de Espada I', type: 'DAMAGE', cost: 4, power: 18, desc: 'Ataque com espada.' },
                    { tier: 2, name: 'Golpe de Espada II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque forte com espada.' },
                    { tier: 3, name: 'Golpe de Espada III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque devastador com espada.' }
                ],
                'Escudo': [
                    { tier: 1, name: 'Escudo I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF temporariamente.' },
                    { tier: 2, name: 'Escudo II', type: 'BUFF', cost: 6, power: 3, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta muito a DEF.' },
                    { tier: 3, name: 'Escudo III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'self', duration: 3, desc: 'Escudo poderoso.' }
                ],
                'Provocar': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Provocar I', type: 'TAUNT', cost: 4, power: 0, desc: 'Provoca o inimigo.' },
                    { tier: 3, name: 'Provocar II', type: 'TAUNT', cost: 6, power: 0, desc: 'Provoca intensamente.' }
                ]
            },
            // CURANDEIRO
            'Curandeiro': {
                'Cura': [
                    { tier: 1, name: 'Cura I', type: 'HEAL', cost: 5, power: 15, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'Cura II', type: 'HEAL', cost: 7, power: 25, target: 'ally', desc: 'Cura moderada.' },
                    { tier: 3, name: 'Cura III', type: 'HEAL', cost: 10, power: 40, target: 'ally', desc: 'Cura poderosa.' }
                ],
                'BÃªnÃ§Ã£o': [
                    { tier: 1, name: 'BÃªnÃ§Ã£o I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK do aliado.' },
                    { tier: 2, name: 'BÃªnÃ§Ã£o II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'BÃªnÃ§Ã£o III', type: 'BUFF', cost: 8, power: 4, buffType: 'DEF', target: 'ally', duration: 3, desc: 'BÃªnÃ§Ã£o poderosa (DEF).' }
                ]
            },
            // MAGO
            'Mago': {
                'Magia Elemental': [
                    { tier: 1, name: 'Magia Elemental I', type: 'DAMAGE', cost: 4, power: 20, desc: 'Magia elemental.' },
                    { tier: 2, name: 'Magia Elemental II', type: 'DAMAGE', cost: 6, power: 26, desc: 'Magia elemental forte.' },
                    { tier: 3, name: 'Magia Elemental III', type: 'DAMAGE', cost: 8, power: 32, desc: 'Magia elemental poderosa.' }
                ],
                'ExplosÃ£o Elemental': [
                    { tier: 1, name: 'ExplosÃ£o Elemental I', type: 'DAMAGE', cost: 6, power: 24, desc: 'ExplosÃ£o mÃ¡gica.' },
                    { tier: 2, name: 'ExplosÃ£o Elemental II', type: 'DAMAGE', cost: 8, power: 32, desc: 'ExplosÃ£o mÃ¡gica forte.' },
                    { tier: 3, name: 'ExplosÃ£o Elemental III', type: 'DAMAGE', cost: 12, power: 38, desc: 'ExplosÃ£o devastadora.' }
                ]
            },
            // BÃRBARO
            'BÃ¡rbaro': {
                'FÃºria': [
                    { tier: 1, name: 'FÃºria I', type: 'BUFF', cost: 4, power: 3, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -1, desc: 'Aumenta ATK, reduz DEF.' },
                    { tier: 2, name: 'FÃºria II', type: 'BUFF', cost: 6, power: 4, buffType: 'ATK', target: 'self', duration: 2, debuffType: 'DEF', debuffPower: -2, desc: 'FÃºria intensa.' },
                    { tier: 3, name: 'FÃºria III', type: 'BUFF', cost: 8, power: 6, buffType: 'ATK', target: 'self', duration: 3, debuffType: 'DEF', debuffPower: -2, desc: 'FÃºria selvagem.' }
                ],
                'Golpe Brutal': [
                    { tier: 1, name: 'Golpe Brutal I', type: 'DAMAGE', cost: 6, power: 24, desc: 'Golpe brutal.' },
                    { tier: 2, name: 'Golpe Brutal II', type: 'DAMAGE', cost: 8, power: 32, desc: 'Golpe muito brutal.' },
                    { tier: 3, name: 'Golpe Brutal III', type: 'DAMAGE', cost: 12, power: 38, desc: 'Golpe devastador.' }
                ]
            },
            // LADINO
            'Ladino': {
                'Ataque Preciso': [
                    { tier: 1, name: 'Ataque Preciso I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Ataque preciso.' },
                    { tier: 2, name: 'Ataque Preciso II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Ataque muito preciso.' },
                    { tier: 3, name: 'Ataque Preciso III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Ataque extremamente preciso.' }
                ],
                'Enfraquecer': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Enfraquecer I', type: 'BUFF', cost: 4, power: -2, buffType: 'ATK', target: 'enemy', duration: 1, desc: 'Reduz ATK do inimigo.' },
                    { tier: 3, name: 'Enfraquecer II', type: 'BUFF', cost: 6, power: -3, buffType: 'ATK', target: 'enemy', duration: 2, desc: 'Enfraquece muito o inimigo.' }
                ]
            },
            // BARDO
            'Bardo': {
                'CanÃ§Ã£o de Coragem': [
                    { tier: 1, name: 'CanÃ§Ã£o de Coragem I', type: 'BUFF', cost: 4, power: 2, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta ATK.' },
                    { tier: 2, name: 'CanÃ§Ã£o de Coragem II', type: 'BUFF', cost: 6, power: 3, buffType: 'ATK', target: 'ally', duration: 2, desc: 'Aumenta muito o ATK.' },
                    { tier: 3, name: 'CanÃ§Ã£o de Coragem III', type: 'BUFF', cost: 8, power: 4, buffType: 'ATK', target: 'ally', duration: 3, desc: 'CanÃ§Ã£o inspiradora.' }
                ],
                'CanÃ§Ã£o Calmante': [
                    { tier: 1, name: 'CanÃ§Ã£o Calmante I', type: 'HEAL', cost: 5, power: 12, target: 'ally', desc: 'Cura leve.' },
                    { tier: 2, name: 'CanÃ§Ã£o Calmante II', type: 'BUFF', cost: 6, power: 2, buffType: 'DEF', target: 'ally', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 3, name: 'CanÃ§Ã£o Calmante III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'ally', duration: 3, desc: 'CanÃ§Ã£o protetora.' }
                ]
            },
            // CAÃ‡ADOR
            'CaÃ§ador': {
                'Flecha Poderosa': [
                    { tier: 1, name: 'Flecha Poderosa I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Flecha poderosa.' },
                    { tier: 2, name: 'Flecha Poderosa II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Flecha muito poderosa.' },
                    { tier: 3, name: 'Flecha Poderosa III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Flecha devastadora.' }
                ],
                'Armadilha': [
                    null, // S0 nÃ£o tem
                    { tier: 2, name: 'Armadilha I', type: 'BUFF', cost: 4, power: -2, buffType: 'SPD', target: 'enemy', duration: 1, desc: 'Reduz SPD do inimigo.' },
                    { tier: 3, name: 'Armadilha II', type: 'BUFF', cost: 6, power: -3, buffType: 'SPD', target: 'enemy', duration: 2, desc: 'Armadilha poderosa.' }
                ]
            },
            // ANIMALISTA
            'Animalista': {
                'Investida Bestial': [
                    { tier: 1, name: 'Investida Bestial I', type: 'DAMAGE', cost: 4, power: 19, desc: 'Investida feroz.' },
                    { tier: 2, name: 'Investida Bestial II', type: 'DAMAGE', cost: 6, power: 24, desc: 'Investida muito feroz.' },
                    { tier: 3, name: 'Investida Bestial III', type: 'DAMAGE', cost: 8, power: 30, desc: 'Investida selvagem.' }
                ],
                'Instinto Selvagem': [
                    { tier: 1, name: 'Instinto Selvagem I', type: 'BUFF', cost: 4, power: 2, buffType: 'DEF', target: 'self', duration: 2, desc: 'Aumenta DEF.' },
                    { tier: 2, name: 'Instinto Selvagem II', type: 'BUFF', cost: 6, power: 2, buffType: 'SPD', target: 'self', duration: 2, desc: 'Aumenta SPD.' },
                    { tier: 3, name: 'Instinto Selvagem III', type: 'BUFF', cost: 8, power: 3, buffType: 'DEF', target: 'self', duration: 3, desc: 'Instinto aguÃ§ado.' }
                ]
            }
        };

        // CLASTERORB TIERS (Sistema de captura em tiers)
        const CLASTERORBS = {
            'CLASTERORB_COMUM': { id: 'CLASTERORB_COMUM', name: 'ClasterOrb Comum', type: 'CAPTURE', capture_bonus_pp: 0, emoji: 'âšª' },
            'CLASTERORB_INCOMUM': { id: 'CLASTERORB_INCOMUM', name: 'ClasterOrb Incomum', type: 'CAPTURE', capture_bonus_pp: 5, emoji: 'ğŸ”µ' },
            'CLASTERORB_RARA': { id: 'CLASTERORB_RARA', name: 'ClasterOrb Rara', type: 'CAPTURE', capture_bonus_pp: 10, emoji: 'ğŸŸ£' }
        };

        // SKILLS CATALOG (baseado em HABILIDADES.csv)
        const SKILLS_CATALOG = [
            // Tier I skills (original)
            { id: 'SK_WAR_01', name: 'Golpe de Escudo', class: 'Guerreiro', category: 'Controle', power: 6, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: 'Atordoado', desc: 'Ataque curto com chance de atordoar.' },
            { id: 'SK_WAR_02', name: 'Corte Pesado', class: 'Guerreiro', category: 'Ataque', power: 9, accuracy: 0.8, energy_cost: 3, target: 'Inimigo', status: '', desc: 'Dano alto, menos preciso.' },
            { id: 'SK_MAG_01', name: 'Raio MÃ­stico', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Dano mÃ¡gico Ã  distÃ¢ncia.' },
            { id: 'SK_MAG_02', name: 'NÃ©voa Lenta', class: 'Mago', category: 'Controle', power: 4, accuracy: 0.9, energy_cost: 3, target: 'Ãrea', status: 'Enraizado', desc: 'Reduz aÃ§Ã£o/movimento por 1 turno.' },
            { id: 'SK_HEA_01', name: 'Sopro Calmante', class: 'Curandeiro', category: 'Cura', power: 0, accuracy: 1, energy_cost: 4, target: 'Aliado', status: '', desc: 'Cura moderada.' },
            { id: 'SK_HEA_02', name: 'Barreira Suave', class: 'Curandeiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Aliado', status: 'Protegido', desc: 'Aumenta defesa por 2 turnos.' },
            { id: 'SK_HUN_01', name: 'Flecha RÃ¡pida', class: 'CaÃ§ador', category: 'Ataque', power: 8, accuracy: 0.9, energy_cost: 2, target: 'Inimigo', status: '', desc: 'Dano consistente Ã  distÃ¢ncia.' },
            { id: 'SK_BRD_01', name: 'CanÃ§Ã£o de Coragem', class: 'Bardo', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 3, target: 'Ãrea', status: 'Fortalecido', desc: 'Buff de ataque para aliados.' },
            
            // Feature 3.6: Tier I/II/III variants for testing
            { id: 'GOLPE_ESPADA_I', name: 'Golpe de Espada I', class: 'Guerreiro', category: 'Ataque', power: 8, accuracy: 0.85, energy_cost: 4, target: 'Inimigo', status: '', desc: 'Ataque de espada bÃ¡sico.' },
            { id: 'GOLPE_ESPADA_II', name: 'Golpe de Espada II', class: 'Guerreiro', category: 'Ataque', power: 12, accuracy: 0.85, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de espada aprimorado.' },
            { id: 'GOLPE_ESPADA_III', name: 'Golpe de Espada III', class: 'Guerreiro', category: 'Ataque', power: 18, accuracy: 0.85, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de espada mestre.' },
            
            { id: 'ESCUDO_I', name: 'Escudo I', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 4, target: 'Self', status: 'Protegido', desc: 'Defesa bÃ¡sica.' },
            { id: 'ESCUDO_II', name: 'Escudo II', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 5, target: 'Self', status: 'Protegido', desc: 'Defesa aprimorada.' },
            { id: 'ESCUDO_III', name: 'Escudo III', class: 'Guerreiro', category: 'Suporte', power: 0, accuracy: 1, energy_cost: 6, target: 'Self', status: 'Protegido', desc: 'Defesa mestre.' },
            
            { id: 'BOLA_FOGO_I', name: 'Bola de Fogo I', class: 'Mago', category: 'Ataque', power: 10, accuracy: 0.9, energy_cost: 5, target: 'Inimigo', status: '', desc: 'Ataque de fogo bÃ¡sico.' },
            { id: 'BOLA_FOGO_II', name: 'Bola de Fogo II', class: 'Mago', category: 'Ataque', power: 15, accuracy: 0.9, energy_cost: 6, target: 'Inimigo', status: '', desc: 'Ataque de fogo aprimorado.' },
            { id: 'BOLA_FOGO_III', name: 'Bola de Fogo III', class: 'Mago', category: 'Ataque', power: 22, accuracy: 0.9, energy_cost: 8, target: 'Inimigo', status: '', desc: 'Ataque de fogo mestre.' }
        ];

        // CLASS ENERGY REGEN (baseado em CLASSES.csv)
        const CLASS_ENERGY_REGEN = {
            'Guerreiro': { ene_regen_pct: 0.10, ene_regen_min: 2 },
            'Mago': { ene_regen_pct: 0.25, ene_regen_min: 1 },
            'Curandeiro': { ene_regen_pct: 0.20, ene_regen_min: 2 },
            'BÃ¡rbaro': { ene_regen_pct: 0.10, ene_regen_min: 1 },
            'Ladino': { ene_regen_pct: 0.15, ene_regen_min: 1 },
            'Bardo': { ene_regen_pct: 0.18, ene_regen_min: 2 },
            'CaÃ§ador': { ene_regen_pct: 0.12, ene_regen_min: 2 },
            'Animalista': { ene_regen_pct: 0.15, ene_regen_min: 2 }
        };

        // DEFAULT OBJECTIVES
        const DEFAULT_OBJECTIVES = [
            { id: 1, text: 'Followed group rules', weight: 2 },
            { id: 2, text: 'Waited for turn patiently', weight: 3 },
            { id: 3, text: 'Helped another player', weight: 3 },
            { id: 4, text: 'Used calm voice throughout', weight: 2 },
            { id: 5, text: 'Made good eye contact', weight: 1 },
            { id: 6, text: 'Shared materials/ideas', weight: 2 }
        ];

        // INITIALIZATION
        function init() {
            try {
                loadFromLocalStorage();
                
                // Restore therapist mode state from localStorage
                if (typeof GameState.therapistMode !== "boolean") {
                    GameState.therapistMode = (localStorage.getItem("mm_therapist_mode") === "1");
                }
                
                if (!GameState.objectives || GameState.objectives.length === 0) {
                    GameState.objectives = [...DEFAULT_OBJECTIVES];
                }
                
                updateAllViews();
                mmUpdateTherapistUI(); // Update therapist mode UI
                
                console.log('Monstrinhomon initialized successfully');
            } catch (error) {
                showError('Initialization failed', error.stack);
            }
        }

        // LOCAL STORAGE
        // COMMIT 4: Save Migration System
        // Version ladder: migrate old saves to current format
        /**
         * Aplica migraÃ§Ãµes sequenciais sem perder dados extras.
         * HARDENED: Preserva campos existentes em meta (nÃ£o sobrescreve).
         */
        function migrateSaveIfNeeded(saveObj) {
            if (!saveObj || typeof saveObj !== 'object') {
                return saveObj;
            }
            
            // Garantir que meta exista sem apagar dados existentes
            saveObj.meta = saveObj.meta || {};
            
            // Determine current version (default to 0 for old saves)
            const currentVersion = saveObj.meta.saveVersion || 0;
            const targetVersion = 1;  // Current version
            
            if (currentVersion >= targetVersion) {
                // Already at current version
                return saveObj;
            }
            
            console.log(`[Migration] Migrating save from version ${currentVersion} to ${targetVersion}`);
            
            // Migration ladder
            let migratedSave = saveObj;
            
            // Migrate from version 0 to 1
            if (currentVersion < 1) {
                // Version 0 -> 1: Update saveVersion (preserving other meta fields)
                migratedSave.meta.saveVersion = 1;
                
                // Add timestamp if not present
                if (!migratedSave.meta.lastSaveDate) {
                    migratedSave.meta.lastSaveDate = new Date().toISOString();
                }
                
                // Ensure therapistMode exists
                if (migratedSave.therapistMode === undefined) {
                    migratedSave.therapistMode = false;
                }
                
                // Garantir arrays essenciais
                migratedSave.players = Array.isArray(migratedSave.players) ? migratedSave.players : [];
                migratedSave.monsters = Array.isArray(migratedSave.monsters) ? migratedSave.monsters : [];
                migratedSave.sessions = Array.isArray(migratedSave.sessions) ? migratedSave.sessions : [];
                
                console.log('[Migration] Applied v0->v1: Added meta.saveVersion (preserved existing meta fields)');
            }
            
            // Future migrations would go here:
            // if (currentVersion < 2) { ... }
            // if (currentVersion < 3) { ... }
            
            return migratedSave;
        }

        // COMMIT 5: Canonical Monster Schema + Normalization
        /**
         * Canonical monster fields (the ONE source of truth):
         * - hp: current HP
         * - hpMax: maximum HP
         * - ene: current ENE
         * - eneMax: maximum ENE
         * - level: current level
         * - xp: current XP
         * - buffs: array of active buffs
         * - templateId: ID from catalog (formerly monsterId)
         * - instanceId: unique instance ID (formerly id)
         * - class: monster class
         * - rarity: monster rarity
         * 
         * HARDENED (Bug-proof):
         * - Uses ?? (nullish coalescing) to accept 0 as valid value
         * - Prefers fields with valid values
         * - Clamps hp/ene to max (prevents over-heal bugs)
         * - Deletes legacy fields after migration
         * - Idempotent: safe to run multiple times
         */
        function normalizeMonster(mon) {
            if (!mon || typeof mon !== 'object') return null;
            
            // --- 1. Identificadores ---
            // Prioridade: templateId > monsterId > baseId > idBase
            mon.templateId = mon.templateId ?? mon.monsterId ?? mon.baseId ?? mon.idBase ?? 'unknown';
            // Remove campos legados para evitar confusÃ£o futura
            delete mon.monsterId;
            delete mon.baseId;
            delete mon.idBase;
            
            // instanceId (formerly just 'id')
            if (mon.id !== undefined && mon.instanceId === undefined) {
                mon.instanceId = mon.id;
            }
            
            // --- 2. Stats MÃ¡ximos (A Ã¢ncora da verdade) ---
            // Prioridade: hpMax > maxHp > cÃ¡lculo fallback
            if (mon.hpMax === undefined) {
                mon.hpMax = mon.maxHp ?? calculateMaxHpFallback(mon.level);
            }
            // Remove legado
            delete mon.maxHp;
            
            // --- 3. Stats Atuais (Com clamping) ---
            // Prioridade: hp > currentHp > hpCurrent > hpMax (full heal se perdido)
            // Usa ?? para aceitar 0 como valor vÃ¡lido
            let rawHp = mon.hp ?? mon.currentHp ?? mon.hpCurrent ?? mon.hpMax;
            
            // Regra de Ouro: HP nunca pode ser > hpMax nem < 0
            const safeHpMax = Number(mon.hpMax) || 30;
            mon.hp = Math.min(Math.max(0, Number(rawHp) || 0), safeHpMax);
            
            // Limpeza legado
            delete mon.currentHp;
            delete mon.hpCurrent;
            
            // --- 4. ENE (Energia) ---
            // Calcular eneMax baseado em nÃ­vel (se nÃ£o existir)
            if (mon.eneMax === undefined) {
                const baseEne = 10;
                const eneGrowth = 2;
                const lvl = mon.level || 1;
                mon.eneMax = Math.floor(baseEne + eneGrowth * (lvl - 1));
            }
            
            // Prioridade: ene > currentEne > eneMax
            let rawEne = mon.ene ?? mon.currentEne ?? mon.eneMax;
            const safeEneMax = Number(mon.eneMax) || 10;
            mon.ene = Math.min(Math.max(0, Number(rawEne) || 0), safeEneMax);
            
            // Limpeza legado
            delete mon.currentEne;
            
            // --- 5. Garantias Estruturais ---
            // Ensure required fields exist
            if (mon.level === undefined) mon.level = 1;
            if (mon.xp === undefined) mon.xp = 0;
            
            // Ensure arrays exist
            if (!Array.isArray(mon.buffs)) {
                mon.buffs = [];
            }
            if (!Array.isArray(mon.statusEffects)) {
                mon.statusEffects = [];
            }
            
            // Ensure class and rarity exist
            if (!mon.class) mon.class = 'Neutro';
            if (!mon.rarity) mon.rarity = 'Comum';
            
            return mon;
        }
        
        /**
         * Helper: Calcula HP mÃ¡ximo fallback baseado em nÃ­vel
         * (usado quando nÃ£o temos acesso ao catalog)
         */
        function calculateMaxHpFallback(level) {
            const baseHp = 30;
            const growthPerLevel = 5;
            const lvl = level || 1;
            return baseHp + (growthPerLevel * (lvl - 1));
        }

        // COMMIT 6: normalizeGameState()
        /**
         * Garante estrutura e tipos do save carregado.
         * 
         * O QUE FAZ:
         * - Valida que state Ã© objeto
         * - Garante meta, players, party, storage, inventory, flags existem com tipos corretos
         * - Chama normalizeMonster() em todos os monstros
         * 
         * O QUE NÃƒO FAZ:
         * - NÃ£o recalcula level, XP, stats, economia
         * - NÃ£o sobrescreve meta existente (apenas garante tipo)
         * - NÃ£o faz over-correction (normalizeMonster jÃ¡ faz)
         * - NÃ£o Ã© responsÃ¡vel por migraÃ§Ã£o (migrateSaveIfNeeded jÃ¡ faz)
         */
        function normalizeGameState(state) {
            // Se state nÃ£o Ã© objeto vÃ¡lido, retorna estado default seguro
            if (!state || typeof state !== 'object' || Array.isArray(state)) {
                console.warn('[System] Invalid state structure, using default');
                return {
                    players: [],
                    monsters: [],
                    sessions: [],
                    currentSession: null,
                    currentEncounter: null,
                    objectives: [],
                    therapistMode: false,
                    meta: {
                        saveVersion: 1
                    },
                    config: {} // Config will be merged from GameState defaults
                };
            }
            
            // Garantir meta Ã© objeto (preservando keys existentes)
            if (!state.meta || typeof state.meta !== 'object' || Array.isArray(state.meta)) {
                console.warn('[System] Invalid meta, resetting to default');
                state.meta = { saveVersion: 1 };
            }
            
            // Garantir players Ã© array
            if (!Array.isArray(state.players)) {
                console.warn('[System] Invalid players structure, resetting to []');
                state.players = [];
            }
            
            // Garantir monsters Ã© array (global list)
            if (!Array.isArray(state.monsters)) {
                console.warn('[System] Invalid monsters structure, resetting to []');
                state.monsters = [];
            }
            
            // Garantir sessions Ã© array
            if (!Array.isArray(state.sessions)) {
                state.sessions = [];
            }
            
            // Garantir objectives Ã© array
            if (!Array.isArray(state.objectives)) {
                state.objectives = [];
            }
            
            // Normalizar cada jogador
            if (state.players) {
                state.players.forEach(player => {
                    if (!player || typeof player !== 'object') return;
                    
                    // Garantir team Ã© array
                    if (!Array.isArray(player.team)) {
                        player.team = [];
                    }
                    
                    // Garantir box Ã© array
                    if (!Array.isArray(player.box)) {
                        player.box = [];
                    }
                    
                    // Garantir inventory Ã© objeto
                    if (!player.inventory || typeof player.inventory !== 'object' || Array.isArray(player.inventory)) {
                        player.inventory = {};
                    }
                    
                    // Normalizar monstros no team
                    if (player.team) {
                        player.team.forEach(monster => {
                            if (!monster) return;
                            normalizeMonster(monster);
                        });
                    }
                    
                    // Normalizar monstros no box
                    if (player.box) {
                        player.box.forEach(monster => {
                            if (!monster) return;
                            normalizeMonster(monster);
                        });
                    }
                });
            }
            
            return state;
        }

        // COMMIT 3: Centralized Persistence Layer
        // All localStorage access must go through these functions
        
        function saveGame() {
            try {
                const data = JSON.stringify(GameState);
                localStorage.setItem('monstrinhomon_state', data);
            } catch (error) {
                showError('Failed to save data', error.stack);
            }
        }
        
        /**
         * Carrega o jogo de forma segura e transacional.
         * Retorna verdadeiro se carregou com sucesso, falso se usou o estado padrÃ£o.
         * 
         * HARDENED (Bug-proof):
         * - Fail-safe: null save â†’ retorna false, mantÃ©m GameState default
         * - Fail-safe: JSON invÃ¡lido â†’ backup + reset, retorna false
         * - Fail-safe: migration error â†’ fallback seguro
         * 
         * COMMIT 6: Integrado normalizeGameState()
         */
        function loadGame() {
            try {
                const raw = localStorage.getItem('monstrinhomon_state');
                
                // 1. Fail-safe: Se nÃ£o tem save, nÃ£o faz nada (mantÃ©m GameState default)
                if (raw === null) {
                    console.log('[System] No save found. Starting new game.');
                    return false;
                }
                
                // 2. Fail-safe: Parse JSON com tratamento de erro
                let loaded;
                try {
                    loaded = JSON.parse(raw);
                } catch (parseError) {
                    // JSON corrompido: faz backup e reseta
                    console.error('[System] Corrupted save detected. Creating backup and resetting.', parseError);
                    localStorage.setItem('monstrinhomon_corrupted_backup', raw);
                    localStorage.removeItem('monstrinhomon_state');
                    return false;
                }
                
                // ValidaÃ§Ã£o estrutural mÃ­nima antes de tocar no GameState
                if (!loaded || typeof loaded !== 'object') {
                    console.warn('[System] Invalid save format (not an object). Resetting.');
                    return false;
                }
                
                // 3. MigraÃ§Ã£o em Escada (Safe Migration)
                const migrated = migrateSaveIfNeeded(loaded);
                
                // 4. NormalizaÃ§Ã£o de Estado (COMMIT 6)
                // Garante estrutura e tipos corretos, chama normalizeMonster() em todos os monstros
                const normalized = normalizeGameState(migrated);
                
                // 5. Merge Seguro (nÃ£o substituir GameState inteiro)
                Object.assign(GameState, normalized);
                
                // 6. PÃ³s-processamento especÃ­fico
                if (GameState.players) {
                    GameState.players.forEach(player => {
                        // Validar estrutura do jogador
                        if (!player || !player.id || !player.name) {
                            console.warn('[System] Invalid player detected:', player);
                            return;
                        }
                        
                        // Migrar inventÃ¡rios antigos (se funÃ§Ã£o existe)
                        if (typeof migrateInventory === 'function') {
                            migrateInventory(player);
                        }
                        
                        // ProgressÃ£o (Feature 3.3) - se funÃ§Ã£o existe
                        if (player.team) {
                            player.team.forEach(monster => {
                                if (!monster) return;
                                if (typeof ensureMonsterProgressFields === 'function') {
                                    ensureMonsterProgressFields(monster);
                                }
                            });
                        }
                        
                        if (player.box) {
                            player.box.forEach(monster => {
                                if (!monster) return;
                                if (typeof ensureMonsterProgressFields === 'function') {
                                    ensureMonsterProgressFields(monster);
                                }
                            });
                        }
                    });
                }
                
                console.log(`[System] Game loaded successfully. Save version: ${GameState.meta?.saveVersion || 0}`);
                return true;
                
            } catch (error) {
                console.error('[System] Critical error in loadGame:', error);
                alert('Error loading game. Check console for details.');
                return false;
            }
        }

        // Legacy wrapper for backward compatibility (Commit 3)
        function saveToLocalStorage() {
            saveGame();
        }

        function loadFromLocalStorage() {
            loadGame();
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            try {
                const tabs = document.querySelectorAll('.tab-content');
                const buttons = document.querySelectorAll('.tab-button');
                
                tabs.forEach(tab => tab.classList.remove('active'));
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeTab = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                const activeButton = Array.from(buttons).find(btn => 
                    btn.textContent.toLowerCase().includes(tabName.toLowerCase())
                );
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                
                updateAllViews();
            } catch (error) {
                showError('Tab switching failed', error.stack);
            }
        }

        // THERAPIST MODE HELPERS (Feature 4.6)
        function mmIsTherapistMode() {
            try {
                if (GameState && typeof GameState.therapistMode === "boolean") return GameState.therapistMode;
            } catch (e) {
                console.warn('Failed to access GameState.therapistMode:', e);
            }
            return localStorage.getItem("mm_therapist_mode") === "1";
        }

        function mmSetTherapistMode(on) {
            const v = !!on;
            try { 
                GameState.therapistMode = v; 
            } catch (e) {
                console.warn('Failed to set GameState.therapistMode:', e);
            }
            localStorage.setItem("mm_therapist_mode", v ? "1" : "0");
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            // Update UI elements
            mmUpdateTherapistUI();
        }

        function mmRequireGameOrAlert() {
            if (!GameState?.players || GameState.players.length === 0) {
                alert("Crie um novo jogo primeiro!");
                return false;
            }
            return true;
        }

        function mmUpdateTherapistUI() {
            // Update therapist button visibility in menu
            const btn = document.getElementById("mmTherapistBtn");
            if (btn) btn.style.display = mmIsTherapistMode() ? "" : "none";
            
            // Update checkbox in settings
            const checkbox = document.getElementById("therapistMode");
            if (checkbox) checkbox.checked = mmIsTherapistMode();
            
            // Update therapist panel visibility (Commit 1)
            const panel = document.getElementById("therapistPanel");
            if (panel) panel.style.display = mmIsTherapistMode() ? "" : "none";
        }

        // COMMIT 2: Therapist Export/Import Save Tools
        function therapistExportSave() {
            try {
                const saveData = JSON.stringify(GameState, null, 2);
                
                // Copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(saveData).then(() => {
                        alert('âœ… Save data copied to clipboard!\n\nYou can also download it as a file.');
                    }).catch(() => {
                        alert('âš ï¸ Could not copy to clipboard, but you can download the file.');
                    });
                }
                
                // Also download as file
                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_save_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log('[Therapist] Save exported successfully');
            } catch (error) {
                console.error('[Therapist] Export failed:', error);
                alert('âŒ Export failed: ' + error.message);
            }
        }

        function therapistImportSave() {
            try {
                // Show textarea and buttons for JSON paste
                const textarea = document.getElementById('therapistJsonArea');
                const buttons = document.getElementById('therapistJsonButtons');
                
                if (textarea && buttons) {
                    textarea.style.display = 'block';
                    buttons.style.display = 'flex';
                    textarea.value = '';
                    textarea.focus();
                }
                
                console.log('[Therapist] Ready to import save - paste JSON and click Load');
            } catch (error) {
                console.error('[Therapist] Import UI failed:', error);
                alert('âŒ Import failed: ' + error.message);
            }
        }

        function therapistLoadJson() {
            try {
                const textarea = document.getElementById('therapistJsonArea');
                const jsonText = textarea?.value?.trim();
                
                if (!jsonText) {
                    alert('âš ï¸ Please paste JSON data first');
                    return;
                }
                
                // Validate JSON
                let saveData;
                try {
                    saveData = JSON.parse(jsonText);
                } catch (parseError) {
                    console.error('[Therapist] Invalid JSON:', parseError);
                    alert('âŒ Invalid JSON format:\n' + parseError.message);
                    return;
                }
                
                // Basic validation
                if (typeof saveData !== 'object' || saveData === null) {
                    alert('âŒ Invalid save data: must be an object');
                    return;
                }
                
                // Load through existing safe load routine
                Object.assign(GameState, saveData);
                
                // Re-run load validation and migrations
                if (GameState.players && Array.isArray(GameState.players)) {
                    GameState.players.forEach(player => {
                        if (!player) return;
                        
                        // Ensure arrays
                        player.team = Array.isArray(player.team) ? player.team : [];
                        player.box = Array.isArray(player.box) ? player.box : [];
                        player.inventory = player.inventory || {};
                        
                        // ENE migration for monsters
                        if (player.team) {
                            player.team.forEach(monster => {
                                if (!monster) return;
                                // COMMIT 5: Use normalizeMonster instead of manual migration
                                normalizeMonster(monster);
                            });
                        }
                        
                        if (player.box) {
                            player.box.forEach(monster => {
                                if (!monster) return;
                                normalizeMonster(monster);
                            });
                        }
                    });
                }
                
                // Save to localStorage using centralized function (Commit 3)
                saveGame();
                
                // Update all views
                if (typeof updateAllViews === 'function') updateAllViews();
                
                // Hide import UI
                therapistCancelImport();
                
                alert('âœ… Save data loaded successfully!');
                console.log('[Therapist] Save imported and loaded successfully');
                
            } catch (error) {
                console.error('[Therapist] Load failed:', error);
                alert('âŒ Load failed: ' + error.message);
            }
        }

        function therapistCancelImport() {
            try {
                const textarea = document.getElementById('therapistJsonArea');
                const buttons = document.getElementById('therapistJsonButtons');
                
                if (textarea) {
                    textarea.style.display = 'none';
                    textarea.value = '';
                }
                if (buttons) {
                    buttons.style.display = 'none';
                }
                
                console.log('[Therapist] Import cancelled');
            } catch (error) {
                console.error('[Therapist] Cancel failed:', error);
            }
        }

        // PLAYER MANAGEMENT
        function addPlayer() {
            try {
                const name = document.getElementById('playerName')?.value?.trim();
                const playerClass = document.getElementById('playerClass')?.value;
                
                if (!name) {
                    alert('Please enter a player name');
                    return;
                }
                
                if (!playerClass) {
                    alert('Please select a class');
                    return;
                }
                
                const player = {
                    id: Date.now().toString(),
                    name: name,
                    class: playerClass, // Armazena a classe diretamente
                    playerClassId: playerClass,
                    money: 100,
                    afterlifeCurrency: 0,
                    team: [],
                    box: [],
                    inventory: {
                        'CLASTERORB_COMUM': 5,    // ClasterOrb Comum x5
                        'CLASTERORB_INCOMUM': 2,  // ClasterOrb Incomum x2
                        'CLASTERORB_RARA': 1,     // ClasterOrb Rara x1
                        'IT_HEAL_01': 3           // Petisco de Cura x3
                    }
                };
                
                GameState.players = GameState.players || [];
                GameState.players.push(player);
                
                giveStarterMonster(player);
                
                document.getElementById('playerName').value = '';
                document.getElementById('playerClass').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add player', error.stack);
            }
        }

        function giveStarterMonster(player) {
            try {
                // Busca monstrinho inicial da mesma classe do jogador
                const classMonsters = MONSTER_CATALOG.filter(m => 
                    m?.class === player?.class && m?.rarity === 'Comum'
                );
                
                // Se nÃ£o encontrar da mesma classe, pega qualquer starter comum
                const starterTemplate = classMonsters.length > 0 ? classMonsters[0] : 
                    MONSTER_CATALOG.find(m => m?.rarity === 'Comum');
                
                if (!starterTemplate) return;
                
                // COMMIT 8 (Wave A): Use Award API for canonical monster creation
                const monster = awardMonster(
                    starterTemplate.id,  // templateId
                    5,                   // level
                    null,                // rarity (use template default)
                    'party',             // destination
                    player               // player object
                );
                
                if (!monster) {
                    console.error('Failed to award starter monster via Award API');
                }
            } catch (error) {
                console.error('Failed to give starter monster:', error);
            }
        }

        function createMonsterInstance(template, ownerId, level = 1) {
            try {
                if (!template) return null;
                
                // Calcular stats baseados no nÃ­vel
                const rarityMult = GameState.config?.rarityPower?.[template.rarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult); // SPD adicionado
                const poder = Math.floor(atk * 0.5); // PODER Ã© derivado de ATK
                
                // Calcular ENE (Sistema ENE)
                const baseEne = template.baseEne || 10; // Fallback se nÃ£o tiver no template
                const eneGrowth = 2; // growth_ene padrÃ£o
                const eneMax = Math.floor(baseEne + eneGrowth * (level - 1));
                
                // Determinar stage baseado no nÃ­vel (simplificado)
                // S0: nÃ­vel 1-9, S1: 10-24, S2: 25-44, S3: 45+
                let stage = 0;
                if (level >= 45) stage = 3;
                else if (level >= 25) stage = 2;
                else if (level >= 10) stage = 1;
                
                return {
                    id: Date.now() + Math.random(),
                    ownerId: ownerId,
                    monsterId: template.id,
                    name: template.name,
                    nickname: template.name, // Nickname padrÃ£o
                    class: template.class,
                    rarity: template.rarity,
                    emoji: template.emoji,
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level), // Feature 3.3
                    hp: hpMax,
                    hpMax: hpMax,
                    atk: atk,
                    def: def,
                    spd: spd,           // SPD adicionado
                    poder: poder,
                    ene: eneMax,      // ENE atual (comeÃ§a cheio)
                    eneMax: eneMax,   // ENE mÃ¡ximo
                    stage: stage,     // EstÃ¡gio de evoluÃ§Ã£o (0-3)
                    status: 'healthy',
                    buffs: []         // Array para buffs temporÃ¡rios
                };
            } catch (error) {
                console.error('Failed to create monster instance:', error);
                return null;
            }
        }

        // COMMIT 7: Factory Pattern - createMonsterInstanceFromTemplate()
        /**
         * Factory function para criar instÃ¢ncias de monstros com schema canÃ´nico.
         * 
         * Esta Ã© a funÃ§Ã£o OFICIAL para criar novos monstros a partir do catÃ¡logo.
         * Garante que todos os monstros nascam com estrutura canÃ´nica consistente.
         * 
         * @param {string} templateId - ID do template no MONSTER_CATALOG (ex: 'MON_001')
         * @param {number} level - NÃ­vel do monstrinho (padrÃ£o: 1)
         * @param {string|null} rarity - Raridade (se null, usa do template)
         * @param {object} overrides - Campos opcionais para sobrescrever (ex: {nickname: 'Fofinho'})
         * @returns {object|null} - InstÃ¢ncia do monstrinho ou null se template nÃ£o encontrado
         * 
         * SCHEMA CANÃ”NICO (Commit 5):
         * - templateId: ID do template (nÃ£o monsterId, baseId, idBase)
         * - instanceId: ID Ãºnico da instÃ¢ncia (nÃ£o id)
         * - hp/hpMax: HP atual/mÃ¡ximo (nÃ£o currentHp, maxHp)
         * - ene/eneMax: ENE atual/mÃ¡ximo
         * - level, xp, buffs, class, rarity
         */
        function createMonsterInstanceFromTemplate(templateId, level = 1, rarity = null, overrides = {}) {
            try {
                // 1. Buscar template no catÃ¡logo
                const catalog = MONSTER_CATALOG || [];
                const template = catalog.find(m => m && m.id === templateId);
                
                if (!template) {
                    console.warn(`[Factory] Template not found: ${templateId}`);
                    return null;
                }
                
                // 2. Gerar instanceId Ãºnico
                // Formato: mi_timestamp_random (mi = monster instance)
                const instanceId = `mi_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // 3. Determinar raridade (parÃ¢metro ou do template)
                const finalRarity = rarity || template.rarity || 'Comum';
                
                // 4. Calcular stats baseados no nÃ­vel
                const rarityMult = GameState.config?.rarityPower?.[finalRarity] || 1.0;
                const levelMult = (1 + (level - 1) * 0.1);
                
                const hpMax = Math.floor((template.baseHp || 30) * levelMult);
                const atk = Math.floor((template.baseAtk || 5) * levelMult * rarityMult);
                const def = Math.floor((template.baseDef || 3) * levelMult * rarityMult);
                const spd = Math.floor((template.baseSpd || 5) * levelMult * rarityMult);
                const poder = Math.floor(atk * 0.5);
                
                // 5. Calcular ENE usando fÃ³rmula canÃ´nica: floor(10 + 2*(level-1))
                const eneMax = Math.floor(10 + 2 * (level - 1));
                
                // 6. Criar instÃ¢ncia com campos canÃ´nicos
                const instance = {
                    // IDs (schema canÃ´nico)
                    templateId: template.id,     // âœ… CanÃ´nico (nÃ£o monsterId)
                    instanceId: instanceId,       // âœ… CanÃ´nico (nÃ£o id)
                    
                    // Info bÃ¡sica
                    name: template.name,
                    nickname: template.name,      // PadrÃ£o (pode ser sobrescrito)
                    emoji: template.emoji || 'ğŸ‘¾',
                    
                    // Classe e raridade
                    class: template.class || 'Neutro',
                    rarity: finalRarity,
                    
                    // ProgressÃ£o
                    level: level,
                    xp: 0,
                    xpNeeded: calculateXPNeeded(level),
                    
                    // HP (schema canÃ´nico)
                    hp: hpMax,          // âœ… CanÃ´nico (nÃ£o currentHp)
                    hpMax: hpMax,       // âœ… CanÃ´nico (nÃ£o maxHp)
                    
                    // ENE (schema canÃ´nico)
                    ene: eneMax,        // âœ… ComeÃ§a cheio
                    eneMax: eneMax,     // âœ… CanÃ´nico
                    
                    // Stats de combate
                    atk: atk,
                    def: def,
                    spd: spd,
                    poder: poder,
                    
                    // Estado
                    status: 'healthy',
                    buffs: [],          // âœ… Array vazio (nÃ£o undefined)
                    
                    // EvoluÃ§Ã£o
                    stage: 0            // Sempre comeÃ§a em stage 0
                };
                
                // 7. Aplicar overrides (ex: nickname personalizado, ownerId, etc.)
                if (overrides && typeof overrides === 'object') {
                    Object.assign(instance, overrides);
                }
                
                // 8. Normalizar usando funÃ§Ã£o robusta do Commit 5
                // Isso garante que mesmo com overrides, a estrutura fica canÃ´nica
                const normalized = normalizeMonster(instance);
                
                if (!normalized) {
                    console.error('[Factory] Normalization failed for template:', templateId);
                    return null;
                }
                
                console.log(`[Factory] Created ${normalized.name} (${templateId}) at level ${level}`);
                return normalized;
                
            } catch (error) {
                console.error('[Factory] Error creating monster instance:', error, { templateId, level, rarity });
                return null;
            }
        }

        // TODO (Commit 8): Substituir chamadas de createMonsterInstance() por createMonsterInstanceFromTemplate()
        // A funÃ§Ã£o antiga ainda funciona para compatibilidade, mas a nova garante schema canÃ´nico.

        // ============================================================================
        // COMMIT 8: Award API - Single Official Path for Rewards
        // ============================================================================

        /**
         * Awards XP to a monster and triggers level-ups automatically.
         * @param {Object|number} target - Monster object or index in player's team
         * @param {number} amount - XP amount to award (must be >= 1)
         * @param {Object} player - Player object (optional, for index-based targeting)
         * @returns {boolean} - true if successful, false otherwise
         */
        function awardXP(target, amount, player = null) {
            try {
                // Validate amount
                const xpAmount = Math.max(1, Number(amount) || 0);
                if (xpAmount < 1) {
                    console.warn('[Award] Invalid XP amount:', amount);
                    return false;
                }

                // Resolve target monster
                let monster = null;
                if (typeof target === 'object' && target !== null) {
                    // Direct monster object
                    monster = target;
                } else if (typeof target === 'number' && player) {
                    // Index in player's team
                    if (!player.team || !Array.isArray(player.team)) {
                        console.warn('[Award] Player has no team array');
                        return false;
                    }
                    monster = player.team[target];
                }

                if (!monster) {
                    console.warn('[Award] Target monster not found');
                    return false;
                }

                // Use existing giveXP function (already handles level-ups)
                const logArr = [];
                giveXP(monster, xpAmount, logArr);

                // Log to console if in therapist mode
                if (typeof mmGetTherapistMode === 'function' && mmGetTherapistMode()) {
                    console.log('[Award] Granted XP:', {
                        monster: monster.name || monster.templateId,
                        amount: xpAmount,
                        newLevel: monster.level,
                        log: logArr
                    });
                }

                // Persist
                saveGame();
                return true;

            } catch (error) {
                console.error('[Award] awardXP failed:', error);
                return false;
            }
        }

        /**
         * Awards an item to a player's inventory.
         * @param {string} itemId - Item ID to award
         * @param {number} qty - Quantity to award (must be >= 1)
         * @param {Object} player - Player object
         * @returns {boolean} - true if successful, false otherwise
         */
        function awardItem(itemId, qty, player) {
            try {
                // Validate inputs
                if (!itemId || typeof itemId !== 'string') {
                    console.warn('[Award] Invalid itemId:', itemId);
                    return false;
                }

                const quantity = Math.max(1, Number(qty) || 1);
                if (quantity < 1) {
                    console.warn('[Award] Invalid quantity:', qty);
                    return false;
                }

                if (!player || typeof player !== 'object') {
                    console.warn('[Award] Invalid player object');
                    return false;
                }

                // Ensure inventory exists
                player.inventory = player.inventory || {};

                // Add item (reuse existing inventory logic)
                player.inventory[itemId] = (player.inventory[itemId] || 0) + quantity;

                // Log to console if in therapist mode
                if (typeof mmGetTherapistMode === 'function' && mmGetTherapistMode()) {
                    console.log('[Award] Granted item:', {
                        itemId: itemId,
                        quantity: quantity,
                        newTotal: player.inventory[itemId],
                        player: player.name
                    });
                }

                // Persist
                saveGame();
                return true;

            } catch (error) {
                console.error('[Award] awardItem failed:', error);
                return false;
            }
        }

        /**
         * Awards a new monster to a player (party or box).
         * @param {string} templateId - Monster template ID from catalog
         * @param {number} level - Starting level
         * @param {string|null} rarity - Rarity override (null = use template default)
         * @param {string} destination - 'party', 'box', or 'auto' (auto respects team limit)
         * @param {Object} player - Player object
         * @param {Object} overrides - Optional field overrides
         * @returns {Object|null} - Created monster or null if failed
         */
        function awardMonster(templateId, level, rarity, destination, player, overrides = {}) {
            try {
                // Validate inputs
                if (!templateId || typeof templateId !== 'string') {
                    console.warn('[Award] Invalid templateId:', templateId);
                    return null;
                }

                if (!player || typeof player !== 'object') {
                    console.warn('[Award] Invalid player object');
                    return null;
                }

                const monsterLevel = Math.max(1, Number(level) || 1);
                const dest = destination || 'auto';

                // Create monster using factory (Commit 7)
                const monster = createMonsterInstanceFromTemplate(templateId, monsterLevel, rarity, overrides);
                
                if (!monster) {
                    console.warn('[Award] Failed to create monster from template:', templateId);
                    return null;
                }

                // Set owner
                if (player.id) {
                    monster.ownerId = player.id;
                }

                // Ensure arrays exist
                player.team = player.team || [];
                player.box = player.box || [];

                // Determine destination
                let actualDest = dest;
                if (dest === 'auto') {
                    const maxTeamSize = GameState.config?.maxTeamSize || 6;
                    actualDest = (player.team.length < maxTeamSize) ? 'party' : 'box';
                }

                // Add to destination
                if (actualDest === 'party' || actualDest === 'team') {
                    const maxTeamSize = GameState.config?.maxTeamSize || 6;
                    if (player.team.length < maxTeamSize) {
                        player.team.push(monster);
                    } else {
                        // Party full, add to box instead
                        player.box.push(monster);
                        actualDest = 'box';
                        console.warn('[Award] Party full, monster sent to box');
                    }
                } else {
                    // box
                    player.box.push(monster);
                }

                // Add to global monsters list (for compatibility)
                GameState.monsters = GameState.monsters || [];
                GameState.monsters.push(monster);

                // Log to console if in therapist mode
                if (typeof mmGetTherapistMode === 'function' && mmGetTherapistMode()) {
                    console.log('[Award] Granted monster:', {
                        templateId: templateId,
                        name: monster.name,
                        level: monsterLevel,
                        rarity: monster.rarity,
                        destination: actualDest,
                        player: player.name
                    });
                }

                // Persist
                saveGame();
                return monster;

            } catch (error) {
                console.error('[Award] awardMonster failed:', error);
                return null;
            }
        }

        // ============================================================================
        // End of Award API
        // ============================================================================

        // FunÃ§Ã£o para obter habilidade do monstrinho
        // Obter habilidades do monstrinho baseado em classe e estÃ¡gio
        function getMonsterSkills(monster) {
            try {
                if (!monster || !monster.class) return [];
                
                const classSkills = SKILL_DEFS[monster.class];
                if (!classSkills) return [];
                
                const stage = monster.stage || 0;
                const skillList = [];
                
                // Pegar as duas primeiras skills sempre disponÃ­veis
                const skillNames = Object.keys(classSkills);
                for (let i = 0; i < Math.min(2, skillNames.length); i++) {
                    const skillTiers = classSkills[skillNames[i]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                // Terceira skill (se existir e stage >= 1)
                if (skillNames.length > 2 && stage >= 1) {
                    const skillTiers = classSkills[skillNames[2]];
                    const skill = skillTiers[stage];
                    if (skill) {
                        skillList.push(skill);
                    }
                }
                
                return skillList;
            } catch (error) {
                console.error('Failed to get monster skills:', error);
                return [];
            }
        }

        // Aplicar regeneraÃ§Ã£o de ENE
        function applyEneRegen(monster, encounter) {
            try {
                if (!monster || !monster.class) return;
                
                const regenData = ENE_REGEN_BY_CLASS[monster.class] || { pct: 0.10, min: 1 };
                const eneGain = Math.max(regenData.min, Math.ceil(monster.eneMax * regenData.pct));
                
                monster.ene = Math.min(monster.eneMax, monster.ene + eneGain);
                
                if (encounter && encounter.log) {
                    encounter.log.push(`âš¡ ${monster.name} regenerou ${eneGain} ENE (${monster.ene}/${monster.eneMax})`);
                }
            } catch (error) {
                console.error('Failed to apply ENE regen:', error);
            }
        }

        // Usar habilidade
        function useSkill(attacker, skill, defender, encounter) {
            try {
                if (!attacker || !skill || !defender) return false;
                
                // Verificar se tem ENE suficiente
                if (attacker.ene < skill.cost) {
                    return false;
                }
                
                // Consumir ENE
                attacker.ene -= skill.cost;
                
                encounter.log = encounter.log || [];
                encounter.log.push(`âœ¨ ${attacker.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                
                // Aplicar efeito baseado no tipo
                switch (skill.type) {
                    case 'DAMAGE':
                        // Calcular dano da habilidade com nova fÃ³rmula
                        const atkMods = getBuffModifiers(attacker);
                        const effectiveAtk = Math.max(1, attacker.atk + atkMods.atk);
                        
                        const defMods = getBuffModifiers(defender);
                        const effectiveDef = Math.max(1, defender.def + defMods.def);
                        
                        // Vantagem de classe
                        const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                        let damageMult = 1.0;
                        if (classAdv?.strong === defender.class) {
                            damageMult = 1.10;
                        } else if (classAdv?.weak === defender.class) {
                            damageMult = 0.90;
                        }
                        
                        const skillDamage = calcDamage({
                            atk: effectiveAtk,
                            def: effectiveDef,
                            power: skill.power,
                            damageMult: damageMult
                        });
                        
                        defender.hp = Math.max(0, defender.hp - skillDamage);
                        encounter.log.push(`ğŸ’¥ ${defender.name} recebe ${skillDamage} de dano!`);
                        break;
                        
                    case 'HEAL':
                        // Curar (self ou ally)
                        const healAmount = skill.power;
                        const target = (skill.target === 'ally' || skill.target === 'self') ? attacker : defender;
                        target.hp = Math.min(target.hpMax, target.hp + healAmount);
                        encounter.log.push(`ğŸ’š ${target.name} recupera ${healAmount} HP!`);
                        break;
                        
                    case 'BUFF':
                        // Aplicar buff/debuff
                        const buffTarget = skill.target === 'enemy' ? defender : attacker;
                        buffTarget.buffs = buffTarget.buffs || [];
                        
                        const buff = {
                            type: skill.buffType,
                            power: skill.power,
                            duration: skill.duration || 1,
                            source: skill.name
                        };
                        buffTarget.buffs.push(buff);
                        
                        const buffDesc = skill.power > 0 ? `+${skill.power}` : skill.power;
                        encounter.log.push(`ğŸ”® ${buffTarget.name} recebe ${buff.type} ${buffDesc} por ${buff.duration} turnos!`);
                        
                        // Se for FÃºria (BÃ¡rbaro), aplicar tambÃ©m o debuff
                        if (skill.debuffType && skill.debuffPower) {
                            const debuff = {
                                type: skill.debuffType,
                                power: skill.debuffPower,
                                duration: skill.duration || 1,
                                source: skill.name
                            };
                            attacker.buffs.push(debuff);
                            encounter.log.push(`âš ï¸ ${attacker.name} recebe ${debuff.type} ${debuff.power} por ${debuff.duration} turnos!`);
                        }
                        break;
                        
                    case 'TAUNT':
                        // Marcar alvo como provocado (flag simples)
                        defender.taunted = true;
                        encounter.log.push(`ğŸ˜  ${defender.name} foi provocado!`);
                        break;
                }
                
                return true;
            } catch (error) {
                console.error('Failed to use skill:', error);
                return false;
            }
        }

        // Atualizar buffs (reduzir duraÃ§Ã£o, remover expirados)
        function updateBuffs(monster) {
            try {
                if (!monster || !monster.buffs) return;
                
                monster.buffs = monster.buffs.filter(buff => {
                    buff.duration--;
                    return buff.duration > 0;
                });
            } catch (error) {
                console.error('Failed to update buffs:', error);
            }
        }

        // Calcular modificadores de buffs
        function getBuffModifiers(monster) {
            try {
                if (!monster || !monster.buffs) return { atk: 0, def: 0, spd: 0 };
                
                const mods = { atk: 0, def: 0, spd: 0 };
                
                monster.buffs.forEach(buff => {
                    const type = buff.type.toLowerCase();
                    if (type === 'atk') mods.atk += buff.power;
                    else if (type === 'def') mods.def += buff.power;
                    else if (type === 'spd') mods.spd += buff.power;
                });
                
                return mods;
            } catch (error) {
                console.error('Failed to get buff modifiers:', error);
                return { atk: 0, def: 0, spd: 0 };
            }
        }

        // FunÃ§Ã£o antiga removida - usar getMonsterSkills acima

        // Migrar inventÃ¡rio antigo para novo sistema ClasterOrb
        function migrateInventory(player) {
            try {
                if (!player || !player.inventory) return;
                
                // Se tem IT_CAP_01 antigo, converter para CLASTERORB_COMUM
                if (player.inventory['IT_CAP_01']) {
                    const oldCount = player.inventory['IT_CAP_01'];
                    player.inventory['CLASTERORB_COMUM'] = (player.inventory['CLASTERORB_COMUM'] || 0) + oldCount;
                    delete player.inventory['IT_CAP_01'];
                }
                
                // Garantir que novos itens existam
                if (!player.inventory['CLASTERORB_COMUM']) player.inventory['CLASTERORB_COMUM'] = 0;
                if (!player.inventory['CLASTERORB_INCOMUM']) player.inventory['CLASTERORB_INCOMUM'] = 0;
                if (!player.inventory['CLASTERORB_RARA']) player.inventory['CLASTERORB_RARA'] = 0;
            } catch (error) {
                console.error('Failed to migrate inventory:', error);
            }
        }

        // SESSION MANAGEMENT
        function createSession() {
            try {
                const name = document.getElementById('sessionName')?.value?.trim();
                
                if (!name) {
                    alert('Please enter a session name');
                    return;
                }
                
                if (!GameState.players || GameState.players.length === 0) {
                    alert('Please add players first');
                    return;
                }
                
                const session = {
                    id: Date.now(),
                    name: name,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    players: GameState.players.map(p => p?.id).filter(id => id),
                    turnOrder: [...GameState.players.map(p => p?.id).filter(id => id)],
                    currentTurnIndex: 0,
                    encountersLog: [],
                    therapy: {
                        perPlayer: {}
                    }
                };
                
                GameState.players.forEach(player => {
                    if (player?.id) {
                        session.therapy.perPlayer[player.id] = {
                            pm: 0,
                            medals: [],
                            logs: [],
                            completedObjectives: []
                        };
                    }
                });
                
                GameState.sessions = GameState.sessions || [];
                GameState.sessions.push(session);
                GameState.currentSession = session;
                
                document.getElementById('sessionName').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to create session', error.stack);
            }
        }

        function nextTurn() {
            try {
                if (!GameState.currentSession) return;
                
                const session = GameState.currentSession;
                session.currentTurnIndex = ((session.currentTurnIndex || 0) + 1) % (session.turnOrder?.length || 1);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to advance turn', error.stack);
            }
        }

        function endSession() {
            try {
                if (!GameState.currentSession) return;
                
                if (confirm('End this session?')) {
                    GameState.currentSession.completedAt = new Date().toISOString();
                    GameState.currentSession = null;
                    
                    saveToLocalStorage();
                    updateAllViews();
                }
            } catch (error) {
                showError('Failed to end session', error.stack);
            }
        }

        // ENCOUNTER MANAGEMENT
        function startEncounter() {
            try {
                const type = document.getElementById('encounterType')?.value;
                
                if (!type) {
                    alert('Please select encounter type');
                    return;
                }
                
                if (!GameState.currentSession) {
                    alert('Please create a session first');
                    return;
                }
                
                // Para encontros em grupo (trainer/boss), usar sistema de grupo
                if (type === 'trainer' || type === 'boss') {
                    // Coletar participantes selecionados
                    const checkboxes = document.querySelectorAll('input[name="groupParticipant"]:checked');
                    const selectedPlayerIds = Array.from(checkboxes).map(cb => cb.value);
                    
                    if (selectedPlayerIds.length === 0) {
                        alert('Selecione pelo menos 1 jogador para a batalha em grupo');
                        return;
                    }
                    
                    if (selectedPlayerIds.length > 6) {
                        alert('MÃ¡ximo de 6 jogadores por batalha');
                        return;
                    }
                    
                    const enemyLevel = parseInt(document.getElementById('enemyLevel')?.value || '5');
                    startGroupEncounter(selectedPlayerIds, type, enemyLevel);
                    return;
                }
                
                // Para encontros individuais (captura), precisa selecionar jogador
                if (type === 'wild') {
                    const selectedPlayerId = document.getElementById('encounterPlayer')?.value;
                    if (!selectedPlayerId) {
                        alert('Please select a player for individual encounter');
                        return;
                    }
                    
                    const player = GameState.players.find(p => p.id === selectedPlayerId);
                    if (!player || !player.team || player.team.length === 0) {
                        alert('Selected player has no monsters in team');
                        return;
                    }
                    
                    // GAME_RULES.md: Em batalha, sÃ³ pode usar monstros da mesma classe do jogador
                    const validMonsters = player.team.filter(m => m.class === player.class && m.status !== 'fainted');
                    if (validMonsters.length === 0) {
                        alert(`âš ï¸ ${player.name} nÃ£o tem monstrinhos da classe ${player.class} disponÃ­veis!\n\nREGRA: Em batalha, vocÃª sÃ³ pode usar monstrinhos da SUA classe.\nTroque com outros jogadores para conseguir monstrinhos da sua classe!`);
                        return;
                    }
                }
                
                const encounter = {
                    id: Date.now(),
                    type: type,
                    active: true,
                    log: [],
                    selectedPlayerId: type === 'wild' ? document.getElementById('encounterPlayer')?.value : null,
                    rewardsGranted: false  // Previne duplicaÃ§Ã£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                if (type === 'wild') {
                    // Limpar buffs do monstrinho do jogador antes da batalha
                    const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
                    if (player && player.team) {
                        for (const mon of player.team) {
                            if (mon && mon.buffs) {
                                mon.buffs = [];
                            }
                        }
                    }
                    
                    const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                    const level = Math.floor(Math.random() * 10) + 1;
                    encounter.wildMonster = createMonsterInstance(randomMonster, null, level);
                    encounter.wildMonster.id = 'wild_' + Date.now();
                }
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start encounter', error.stack);
            }
        }

        // GROUP BATTLE FUNCTIONS (Feature 3.2)
        
        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }
        
        function startGroupEncounter(selectedPlayerIds, encounterType, enemyLevel) {
            try {
                // Initialize activeIndex for all participating players
                for (const pid of selectedPlayerIds) {
                    const player = GameState.players.find(p => p.id === pid);
                    if (!player) continue;
                    
                    // Ensure player has valid starter
                    if (!autoSelectStarter(player)) {
                        alert(`âš ï¸ ${player.name || player.nome} nÃ£o tem monstrinhos vivos! NÃ£o pode participar da batalha.`);
                        return;
                    }
                }
                
                // Limpar buffs dos monstrinhos dos jogadores participantes
                for (const pid of selectedPlayerIds) {
                    const player = GameState.players.find(p => p.id === pid);
                    if (player && player.team) {
                        for (const mon of player.team) {
                            if (mon && mon.buffs) {
                                mon.buffs = [];
                            }
                        }
                    }
                }
                
                // Criar inimigo
                const randomMonster = MONSTER_CATALOG[Math.floor(Math.random() * MONSTER_CATALOG.length)];
                const enemy = createMonsterInstance(randomMonster, null, enemyLevel);
                enemy.id = 'enemy_1';
                
                // Criar encounter de grupo
                const encounter = {
                    id: Date.now(),
                    type: encounterType === 'boss' ? 'boss' : 'group_trainer',
                    active: true,
                    log: [],
                    participants: selectedPlayerIds,
                    enemies: [enemy],
                    turnOrder: [],
                    turnIndex: 0,
                    currentActor: null,
                    finished: false,
                    result: null,
                    rewardsGranted: false  // Previne duplicaÃ§Ã£o de XP
                };
                
                // Inicializar campos de toast
                initializeEncounterToast(encounter);
                
                // Calcular ordem de turnos
                encounter.turnOrder = calculateGroupTurnOrder(encounter);
                encounter.turnIndex = 0;
                encounter.currentActor = getCurrentActor(encounter);
                
                encounter.log.push('ğŸ² Ordem de turnos calculada!');
                encounter.turnOrder.forEach((actor, idx) => {
                    const tieInfo = actor._tiebreak ? ` (d20: ${actor._tiebreak})` : '';
                    encounter.log.push(`   ${idx + 1}. ${actor.name} (${actor.side === 'player' ? 'Jogador' : 'Inimigo'}, SPD: ${actor.spd}${tieInfo})`);
                });
                
                GameState.currentEncounter = encounter;
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to start group encounter', error.stack);
            }
        }
        
        function calculateGroupTurnOrder(enc) {
            const order = [];
            
            // Adicionar jogadores participantes
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                if (!p) continue;
                
                const mon = p.team?.[0];
                if (!mon) continue;
                
                const hp = Number(mon.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "player",
                    id: pid,
                    name: p.name || p.nome || "Jogador",
                    spd: Number(mon.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Adicionar inimigos
            for (let i = 0; i < (enc.enemies || []).length; i++) {
                const e = enc.enemies[i];
                if (!e) continue;
                
                const hp = Number(e.hp) || 0;
                if (hp <= 0) continue;
                
                order.push({
                    side: "enemy",
                    id: i,
                    name: e.name || e.nome || `Inimigo ${i + 1}`,
                    spd: Number(e.spd) || 0,
                    _tiebreak: null
                });
            }
            
            // Ordenar por SPD descendente
            order.sort((a, b) => (b.spd - a.spd));
            
            // Desempate por grupos de mesmo SPD
            let i = 0;
            while (i < order.length) {
                let j = i + 1;
                while (j < order.length && order[j].spd === order[i].spd) j++;
                
                // [i, j) Ã© o bloco empatado
                if (j - i > 1) {
                    for (let k = i; k < j; k++) {
                        order[k]._tiebreak = rollD20();
                    }
                    const sortedBlock = order.slice(i, j).sort((a, b) => (b._tiebreak - a._tiebreak));
                    for (let k = 0; k < sortedBlock.length; k++) {
                        order[i + k] = sortedBlock[k];
                    }
                }
                
                i = j;
            }
            
            return order;
        }
        
        function getCurrentActor(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return null;
            const idx = Number(enc.turnIndex) || 0;
            return enc.turnOrder[idx] || null;
        }
        
        function _hasAlivePlayers(enc) {
            for (const pid of (enc.participants || [])) {
                const p = GameState.players.find(x => x.id === pid);
                if (!p || !Array.isArray(p.team)) continue;
                // Check if player has any alive monster in team
                if (firstAliveIndex(p.team) >= 0) return true;
            }
            return false;
        }
        
        function _hasAliveEnemies(enc) {
            for (const e of (enc.enemies || [])) {
                if ((Number(e?.hp) || 0) > 0) return true;
            }
            return false;
        }
        
        function advanceTurn(enc) {
            if (!enc || !enc.turnOrder || enc.turnOrder.length === 0) return;
            
            // Verificar condiÃ§Ãµes de fim
            const alivePlayers = _hasAlivePlayers(enc);
            const aliveEnemies = _hasAliveEnemies(enc);
            
            if (!aliveEnemies) {
                enc.finished = true;
                enc.result = "victory";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("ğŸ VitÃ³ria! Todos os inimigos foram derrotados.");
                
                // Feature 4.4: Victory sound (com idempotÃªncia)
                if (!enc._winSfxPlayed) {
                    Audio.playSfx("win");
                    enc._winSfxPlayed = true;
                }
                
                // Distribuir recompensas (XP) com idempotÃªncia
                handleVictoryRewards(enc);
                
                return;
            }
            
            if (!alivePlayers) {
                enc.finished = true;
                enc.result = "defeat";
                enc.active = false;
                enc.log = enc.log || [];
                enc.log.push("ğŸ’€ Derrota... Todos os participantes foram derrotados.");
                
                // Feature 4.4: Defeat sound (com idempotÃªncia)
                if (!enc._loseSfxPlayed) {
                    Audio.playSfx("lose");
                    enc._loseSfxPlayed = true;
                }
                
                return;
            }
            
            // AvanÃ§ar para prÃ³ximo ator vÃ¡lido
            const maxLoops = enc.turnOrder.length + 2;
            let loops = 0;
            
            do {
                enc.turnIndex = ((Number(enc.turnIndex) || 0) + 1) % enc.turnOrder.length;
                loops++;
                
                const actor = getCurrentActor(enc);
                if (!actor) break;
                
                // Validar se ator ainda estÃ¡ vivo
                if (actor.side === "player") {
                    const p = GameState.players.find(x => x.id === actor.id);
                    const mon = p?.team?.[0];
                    if (mon && (Number(mon.hp) || 0) > 0) break;
                } else {
                    const e = enc.enemies?.[actor.id];
                    if (e && (Number(e.hp) || 0) > 0) break;
                }
                
            } while (loops < maxLoops);
            
            // Atualizar currentActor
            enc.currentActor = getCurrentActor(enc);
            
            // Auto-trigger turno do inimigo
            const actorNow = getCurrentActor(enc);
            if (actorNow && actorNow.side === "enemy" && !enc.finished) {
                processEnemyTurnGroup(enc);
            } else if (actorNow) {
                enc.log = enc.log || [];
                enc.log.push(`âºï¸ Turno: ${actorNow.name}`);
            }
        }
        
        function groupPassTurn() {
            try {
                const enc = GameState.currentEncounter;
                if (!enc) return;
                
                const actor = getCurrentActor(enc);
                if (!actor) return;
                
                enc.log.push(`â–¶ï¸ ${actor.name} passou o turno`);
                
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to pass turn', error.stack);
            }
        }

        // ==================== FASE 3: Helper Functions ====================

        function _getGroupEncounter() {
            return GameState.currentEncounter;
        }

        function _getPlayerById(playerId) {
            return GameState.players.find(p => p.id === playerId) || null;
        }

        function _getActiveMonsterOfPlayer(player) {
            if (!player || !Array.isArray(player.team)) return null;
            
            // Initialize activeIndex if not set
            if (typeof player.activeIndex !== 'number') {
                player.activeIndex = firstAliveIndex(player.team);
            }
            
            // Return the active monster (or null if index is invalid)
            return player.team[player.activeIndex] || null;
        }

        function _getEnemyByIndex(enc, idx) {
            return enc?.enemies?.[idx] || null;
        }

        function _clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }

        function _calcDamage(power, atk, def) {
            const A = Number(atk) || 0;
            const D = Number(def) || 0;
            const P = Number(power) || 0;
            const ratio = (A <= 0 && D <= 0) ? 0.5 : (A / (A + D));
            const base = Math.floor(P * ratio);
            return Math.max(1, base);
        }

        function _isAlive(entity) {
            return (Number(entity?.hp) || 0) > 0;
        }

        function _log(enc, msg) {
            enc.log = enc.log || [];
            enc.log.push(msg);
        }

        // ==================== Team Management Helpers ====================
        
        /**
         * Returns the index of the first alive monster in the team (hp > 0).
         * Returns -1 if no alive monsters found.
         */
        function firstAliveIndex(team) {
            if (!Array.isArray(team)) return -1;
            for (let i = 0; i < team.length; i++) {
                if (_isAlive(team[i])) return i;
            }
            return -1;
        }

        /**
         * Moves a team member from one position to another.
         * Updates the player's team array and saves.
         */
        function moveTeamMember(player, fromIdx, toIdx) {
            if (!player || !Array.isArray(player.team)) return;
            if (fromIdx < 0 || fromIdx >= player.team.length) return;
            if (toIdx < 0 || toIdx >= player.team.length) return;
            if (fromIdx === toIdx) return;

            const monster = player.team[fromIdx];
            player.team.splice(fromIdx, 1);
            player.team.splice(toIdx, 0, monster);

            // Update activeIndex if player has one
            if (typeof player.activeIndex === 'number') {
                if (player.activeIndex === fromIdx) {
                    player.activeIndex = toIdx;
                } else if (fromIdx < toIdx) {
                    if (player.activeIndex > fromIdx && player.activeIndex <= toIdx) {
                        player.activeIndex--;
                    }
                } else {
                    if (player.activeIndex >= toIdx && player.activeIndex < fromIdx) {
                        player.activeIndex++;
                    }
                }
            }

            saveToLocalStorage();
        }

        /**
         * Auto-selects the starter for encounter.
         * Sets player.activeIndex to the first alive monster.
         * Returns true if a valid starter was found, false otherwise.
         */
        function autoSelectStarter(player) {
            if (!player || !Array.isArray(player.team)) return false;
            const idx = firstAliveIndex(player.team);
            if (idx >= 0) {
                player.activeIndex = idx;
                return true;
            }
            player.activeIndex = -1;
            return false;
        }

        /**
         * Ensures the active monster is alive.
         * - Outside battle: auto-switches to first alive
         * - During battle: opens modal for manual selection (if inBattle is true)
         */
        function ensureActiveAlive(player, options = {}) {
            if (!player || !Array.isArray(player.team)) return false;
            
            // Initialize activeIndex if not set
            if (typeof player.activeIndex !== 'number') {
                player.activeIndex = 0;
            }

            const currentMon = player.team[player.activeIndex];
            
            // If current is alive, we're good
            if (_isAlive(currentMon)) return true;

            // Current is fainted
            if (options.inBattle) {
                // In battle: need to open modal for replacement
                return false; // Caller should handle modal
            } else {
                // Outside battle: auto-switch to first alive
                const idx = firstAliveIndex(player.team);
                if (idx >= 0) {
                    player.activeIndex = idx;
                    saveToLocalStorage();
                    return true;
                }
                // No alive monsters
                player.activeIndex = -1;
                return false;
            }
        }

        function _chooseTargetPlayerId(enc) {
            let best = null;
            for (const pid of (enc.participants || [])) {
                const p = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(p);
                if (!mon || !_isAlive(mon)) continue;

                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;
                const pct = hp / hpMax;

                if (!best || pct < best.pct) best = { pid, pct };
            }
            return best ? best.pid : null;
        }

        // ==================== FASE 3.A: Player Attack ====================

        function groupAttack() {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                // GAME_RULES.md: Em batalha, sÃ³ pode usar monstros da mesma classe do jogador
                if (mon.class !== player.class) {
                    alert(`âš ï¸ ${player.name}: VocÃª sÃ³ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${mon.name} Ã© da classe ${mon.class}.\nREGRA: Em batalha, vocÃª sÃ³ pode usar monstrinhos da SUA classe.`);
                    return;
                }

                if (!_isAlive(mon)) {
                    _log(enc, "âš ï¸ Seu monstrinho estÃ¡ desmaiado. NÃ£o pode atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Aplicar ENE REGEN no inÃ­cio do turno do jogador
                applyEneRegen(mon, enc);
                
                // Atualizar buffs (reduzir duraÃ§Ã£o)
                updateBuffs(mon);

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;

                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) {
                    _log(enc, "â„¹ï¸ NÃ£o hÃ¡ inimigos vivos para atacar.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const d20 = rollD20();
                
                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (isCrit || checkHit(d20, mon, enemy));

                const attackerName = player.name || player.nome || actor.name || "Jogador";
                const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                const enemyName = enemy.name || enemy.nome || "Inimigo";
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit ? 'crit' : alwaysMiss ? 'fail' : 'normal';
                recordD20Roll(enc, attackerName, d20, rollType);

                // Feature 4.4: Play attack sound
                if (isCrit) {
                    Audio.playSfx("crit");
                } else if (alwaysMiss || !hit) {
                    Audio.playSfx("miss");
                } else {
                    Audio.playSfx("hit");
                }

                if (!hit) {
                    _log(enc, `ğŸ² ${attackerName} (${monName}) rolou ${d20} e ERROU o ataque em ${enemyName}.`);
                    
                    // Feature 3.8: Flash fail on player
                    setTimeout(() => flashTarget(`grpP_${actor.id}`, 'fail'), 50);
                    
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER bÃ¡sico
                const basicPower = BASIC_ATTACK_POWER[mon.class] || 12;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `ğŸ’¥ CRIT 20! ${monName} ativou Poder Duplo!`);
                }

                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(mon);
                const effectiveAtk = Math.max(1, (Number(mon.atk) || 0) + atkMods.atk);
                
                const defMods = getBuffModifiers(enemy);
                const effectiveDef = Math.max(1, (Number(enemy.def) || 0) + defMods.def);

                // Calcular vantagem de classe
                const classAdv = GameState.config?.classAdvantages?.[mon.class];
                let damageMult = 1.0;
                if (classAdv?.strong === enemy.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === enemy.class) {
                    damageMult = 0.90;
                }

                const dmg = calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: powerUsed,
                    damageMult: damageMult
                });
                enemy.hp = _clamp((Number(enemy.hp) || 0) - dmg, 0, Number(enemy.hpMax) || 999999);

                _log(enc, `ğŸ² ${attackerName} (${monName}) rolou ${d20} e acertou ${enemyName} causando ${dmg} de dano!`);
                
                // Feature 3.8: Visual feedback
                saveToLocalStorage();
                renderEncounter();
                setTimeout(() => {
                    showFloatingText(`grpE_${enemyIndex}`, `-${dmg}`, isCrit ? 'crit' : 'damage');
                    flashTarget(`grpE_${enemyIndex}`, isCrit ? 'crit' : 'hit');
                }, 50);

                if (!_isAlive(enemy)) {
                    _log(enc, `ğŸ ${enemyName} foi derrotado!`);
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to attack', error.stack);
            }
        }

        // ==================== FASE 3.B: Enemy AI ====================

        function processEnemyTurnGroup(enc) {
            try {
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'enemy') return;

                const enemy = _getEnemyByIndex(enc, actor.id);
                if (!enemy || !_isAlive(enemy)) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Aplicar ENE REGEN no inÃ­cio do turno do inimigo
                applyEneRegen(enemy, enc);
                
                // Atualizar buffs (reduzir duraÃ§Ã£o)
                updateBuffs(enemy);

                // Escolhe alvo (menor HP%)
                const targetPid = _chooseTargetPlayerId(enc);
                if (!targetPid) {
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                const targetPlayer = _getPlayerById(targetPid);
                const targetMon = _getActiveMonsterOfPlayer(targetPlayer);

                const enemyName = enemy.name || actor.name || "Inimigo";
                const targetName = targetPlayer?.name || targetPlayer?.nome || "Jogador";
                const targetMonName = targetMon?.nickname || targetMon?.name || targetMon?.nome || "Monstrinho";

                const d20 = rollD20();

                const alwaysMiss = (d20 === 1);
                const isCrit = (d20 === 20);
                const hit = !alwaysMiss && (isCrit || checkHit(d20, enemy, targetMon));
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit ? 'crit' : alwaysMiss ? 'fail' : 'normal';
                recordD20Roll(enc, enemyName, d20, rollType);

                // Feature 4.4: Enemy attack sound (group)
                if (isCrit) {
                    Audio.playSfx("crit");
                } else if (alwaysMiss || !hit) {
                    Audio.playSfx("miss");
                } else {
                    Audio.playSfx("hit");
                }

                if (!hit) {
                    _log(enc, `ğŸ² ${enemyName} rolou ${d20} e ERROU o ataque em ${targetName} (${targetMonName}).`);
                    
                    // Feature 3.8: Flash fail on enemy
                    const enemyIndex = enc.enemies.indexOf(enemy);
                    setTimeout(() => flashTarget(`grpE_${enemyIndex}`, 'fail'), 50);
                    
                    advanceTurn(enc);
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // POWER bÃ¡sico do inimigo
                const basicPower = BASIC_ATTACK_POWER[enemy.class] || 12;
                let powerUsed = basicPower;

                if (isCrit) {
                    powerUsed = basicPower * 2;
                    _log(enc, `ğŸ’¥ CRIT 20! ${enemyName} ativou Poder Duplo!`);
                }

                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(enemy);
                const effectiveAtk = Math.max(1, (Number(enemy.atk) || 0) + atkMods.atk);
                
                const defMods = getBuffModifiers(targetMon);
                const effectiveDef = Math.max(1, (Number(targetMon?.def) || 0) + defMods.def);

                // Calcular vantagem de classe
                const classAdv = GameState.config?.classAdvantages?.[enemy.class];
                let damageMult = 1.0;
                if (classAdv?.strong === targetMon?.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === targetMon?.class) {
                    damageMult = 0.90;
                }

                const dmg = calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: powerUsed,
                    damageMult: damageMult
                });
                targetMon.hp = _clamp((Number(targetMon.hp) || 0) - dmg, 0, Number(targetMon.hpMax) || 999999);

                _log(enc, `ğŸ² ${enemyName} rolou ${d20} e acertou ${targetName} (${targetMonName}) causando ${dmg} de dano!`);
                
                // Feature 3.8: Visual feedback
                saveToLocalStorage();
                renderEncounter();
                setTimeout(() => {
                    showFloatingText(`grpP_${targetPid}`, `-${dmg}`, isCrit ? 'crit' : 'damage');
                    flashTarget(`grpP_${targetPid}`, isCrit ? 'crit' : 'hit');
                }, 50);

                if (!_isAlive(targetMon)) {
                    _log(enc, `ğŸ’€ ${targetName} (${targetMonName}) foi derrotado!`);
                    
                    // Check if player has other alive monsters
                    const aliveIdx = firstAliveIndex(targetPlayer.team);
                    if (aliveIdx >= 0) {
                        // Player has other monsters - need to switch
                        // Save state and open modal
                        saveToLocalStorage();
                        renderEncounter();
                        
                        // Open modal for replacement (async)
                        setTimeout(() => {
                            openSwitchMonsterModal(targetPlayer, enc);
                        }, 100);
                        return; // Don't advance turn yet - modal will handle it
                    } else {
                        // Player has no more monsters - they're out
                        _log(enc, `âš ï¸ ${targetName} nÃ£o tem mais monstrinhos vivos!`);
                    }
                }

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to process enemy turn', error.stack);
            }
        }

        // ==================== Switch Monster Modal ====================

        function openSwitchMonsterModal(player, enc) {
            if (!player || !Array.isArray(player.team)) return;
            
            // Get alive monsters (excluding current active)
            const aliveMonsters = [];
            player.team.forEach((mon, idx) => {
                if (_isAlive(mon) && idx !== player.activeIndex) {
                    aliveMonsters.push({ monster: mon, index: idx });
                }
            });
            
            if (aliveMonsters.length === 0) {
                alert('Sem monstrinhos vivos para substituir!');
                // Continue battle
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
                return;
            }
            
            // Build modal HTML
            let html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 9999;" id="switchMonsterModal">';
            html += '<div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; max-height: 80vh; overflow-y: auto;">';
            html += `<h3>ğŸ’€ ${player.name || player.nome}: Escolha um Substituto</h3>`;
            html += '<p>Seu monstrinho foi derrotado! Escolha um substituto:</p>';
            html += '<div style="margin: 15px 0;">';
            
            aliveMonsters.forEach(({ monster, index }) => {
                const hpPercent = Math.floor((monster.hp / monster.hpMax) * 100);
                html += `<div style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 4px; cursor: pointer; background: #f5f5f5;" onclick="selectReplacementMonster('${player.id}', ${index}, '${enc.id}')">`;
                html += `<strong>${monster.emoji || ''} ${monster.name || monster.nome}</strong> - Nv ${monster.level}`;
                html += `<br>HP: ${monster.hp}/${monster.hpMax} (${hpPercent}%)`;
                html += `<br>Classe: ${monster.class}`;
                html += `</div>`;
            });
            
            html += '</div>';
            html += '</div>';
            html += '</div>';
            
            // Add modal to body
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = html;
            document.body.appendChild(modalDiv);
        }

        function selectReplacementMonster(playerId, newActiveIndex, encounterId) {
            try {
                const player = _getPlayerById(playerId);
                const enc = GameState.currentEncounter;
                
                if (!player || !enc || enc.id !== encounterId) {
                    console.error('Invalid state for monster replacement');
                    return;
                }
                
                // Set new active index
                player.activeIndex = newActiveIndex;
                
                const newMon = player.team[newActiveIndex];
                _log(enc, `ğŸ”„ ${player.name || player.nome} trocou para ${newMon.name || newMon.nome}!`);
                
                // Close modal
                const modal = document.getElementById('switchMonsterModal');
                if (modal) modal.remove();
                
                // Continue battle
                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to select replacement monster', error.stack);
            }
        }

        // ==================== FASE 3.C: Skills and Items ====================

        function groupUseSkill(skillIndex) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon || !_isAlive(mon)) return;

                // Alvo: primeiro inimigo vivo
                let enemyIndex = 0;
                while (enemyIndex < (enc.enemies?.length || 0) && !_isAlive(enc.enemies[enemyIndex])) enemyIndex++;
                const enemy = _getEnemyByIndex(enc, enemyIndex);
                if (!enemy || !_isAlive(enemy)) return;

                _log(enc, "â„¹ï¸ (Ajuste) Sistema de habilidades serÃ¡ integrado na Feature 3.3");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use skill', error.stack);
            }
        }

        function groupUseItem(itemId) {
            try {
                const enc = _getGroupEncounter();
                if (!enc || enc.finished) return;

                const actor = getCurrentActor(enc);
                if (!actor || actor.side !== 'player') return;

                const player = _getPlayerById(actor.id);
                const mon = _getActiveMonsterOfPlayer(player);
                if (!player || !mon) return;

                // Reutiliza lÃ³gica do 3.1
                const hp = Number(mon.hp) || 0;
                const hpMax = Number(mon.hpMax) || 1;

                if (hp <= 0) {
                    _log(enc, "âš ï¸ Monstrinho estÃ¡ desmaiado.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (hp >= hpMax) {
                    _log(enc, "â„¹ï¸ HP jÃ¡ estÃ¡ cheio.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                if (!itemId || itemId === 'IT_HEAL_01') {
                    itemId = 'IT_HEAL_01';
                }

                const itemCount = Number(player.inventory?.[itemId]) || 0;
                if (itemCount <= 0) {
                    _log(enc, "âš ï¸ VocÃª nÃ£o tem esse item.");
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }

                // Consumir item
                player.inventory[itemId] = Math.max(0, itemCount - 1);

                // Aplicar cura (mesmo do 3.1)
                const healAmount = Math.max(30, Math.floor(hpMax * 0.30));
                const newHp = Math.min(hpMax, hp + healAmount);
                const healed = newHp - hp;
                mon.hp = newHp;

                const playerName = player.name || "Jogador";
                const monName = mon.nickname || mon.name || "Monstrinho";

                _log(enc, `ğŸ’š ${playerName} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                _log(enc, `âœ¨ ${monName} recuperou ${healed} HP! (${mon.hp}/${hpMax})`);
                
                // Feature 4.4: Heal sound
                Audio.playSfx("heal");

                advanceTurn(enc);
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Failed to use item', error.stack);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FEATURE 3.3 - SISTEMA DE XP E LEVEL UP (com idempotÃªncia)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Garante que um monstro tenha campos de progressÃ£o (compatibilidade com saves antigos)
         */
        function ensureMonsterProgressFields(mon) {
            if (!mon) return;
            mon.level = Math.max(1, Number(mon.level) || 1);
            mon.xp = Math.max(0, Number(mon.xp) || 0);
            mon.xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
            // Fallback hpMax/maxHp
            if (mon.hpMax == null && mon.maxHp != null) mon.hpMax = mon.maxHp;
            if (mon.hp == null && mon.hpMax != null) mon.hp = mon.hpMax;
        }
        
        /**
         * Calcula XP necessÃ¡rio para prÃ³ximo nÃ­vel (curva suave)
         */
        function calcXpNeeded(level) {
            const L = Math.max(1, Number(level) || 1);
            return Math.round(40 + 6 * L + 0.6 * (L * L));
        }
        
        // Alias para compatibilidade
        function calculateXPNeeded(level) {
            return calcXpNeeded(level);
        }
        
        /**
         * Garante que um monstro tenha campos de XP preenchidos
         */
        function ensureXpFields(mon) {
            if (!mon) return;
            if (mon.level == null) mon.level = 1;
            if (mon.xp == null) mon.xp = 0;
            if (mon.xpNeeded == null) mon.xpNeeded = calcXpNeeded(mon.level);
        }
        
        /**
         * Exibe um toast notification temporÃ¡rio
         */
        function showToast(text) {
            const host = document.getElementById("mmToastHost");
            if (!host) return;

            const el = document.createElement("div");
            el.className = "mm-toast";
            el.textContent = text;

            host.appendChild(el);

            setTimeout(() => {
                el.style.opacity = "0";
                el.style.transform = "translateY(-4px)";
                el.style.transition = "opacity .2s ease, transform .2s ease";
            }, 2600);

            setTimeout(() => el.remove(), 3100);
        }

        /**
         * Inicializa campos de toast para um encounter
         * Garante que cada encounter tenha IDs Ãºnicos e cursor de toast resetado
         */
        function initializeEncounterToast(enc) {
            if (!enc) return;
            
            // Garantir ID Ãºnico do encounter
            if (!enc.encounterId) {
                enc.encounterId = "enc_" + Date.now() + "_" + Math.random().toString(16).slice(2);
            }
            
            // Inicializar cursor de toast
            enc._toastCursor = 0;
            
            // Opcional: tracking de mensagens jÃ¡ vistas (para futuro uso)
            enc._toastSeen = {};
        }
        
        /**
         * Verifica novas entradas no log e exibe toasts para eventos importantes
         * Usa cursor para evitar repetir toasts em re-render
         * Detecta level up e evoluÃ§Ã£o por emoji OU por texto
         */
        function maybeToastFromLog(enc) {
            if (!enc || !Array.isArray(enc.log)) return;

            // Garantir inicializaÃ§Ã£o do cursor (seguranÃ§a para encounters antigos)
            if (enc._toastCursor == null) enc._toastCursor = 0;

            const start = Number.isFinite(enc._toastCursor) ? enc._toastCursor : 0;
            for (let i = start; i < enc.log.length; i++) {
                const line = String(enc.log[i] || "");
                
                // Detectar level up: por emoji OU por texto
                const isLevelUp = line.includes("âœ¨") || /subiu para o nÃ­vel/i.test(line);
                if (isLevelUp) showToast(line);
                
                // Detectar evoluÃ§Ã£o: por emoji OU por texto
                const isEvo = line.includes("ğŸŒŸ") || /evoluiu para/i.test(line);
                if (isEvo) showToast(line);
            }
            enc._toastCursor = enc.log.length;
        }
        
        /**
         * Feature 4.4: Plays sounds for level up and evolution events from log
         * Uses cursor to prevent repeating sounds on re-render
         */
        function maybeSfxFromLog(enc) {
            if (!enc || !Array.isArray(enc.log)) return;
            
            // Guarantee cursor initialization
            if (enc._sfxCursor == null) enc._sfxCursor = 0;
            
            const start = Number.isFinite(enc._sfxCursor) ? enc._sfxCursor : 0;
            for (let i = start; i < enc.log.length; i++) {
                const line = String(enc.log[i] || "");
                
                // Detect level up - check emoji first to avoid double-trigger
                if (line.includes("âœ¨")) {
                    Audio.playSfx("levelup");
                } else if (/subiu para o nÃ­vel/i.test(line)) {
                    Audio.playSfx("levelup");
                }
                
                // Detect evolution - check emoji first to avoid double-trigger
                if (line.includes("ğŸŒŸ")) {
                    Audio.playSfx("evolve");
                } else if (/evoluiu para/i.test(line)) {
                    Audio.playSfx("evolve");
                }
            }
            enc._sfxCursor = enc.log.length;
        }
        
        /**
         * Calcula XP ganho de uma batalha
         * @param {Object} defeatedEnemy - Inimigo derrotado
         * @param {string} encounterType - Tipo do encontro ('wild', 'group_trainer', 'boss')
         * @returns {number} - XP calculado
         */
        function calculateBattleXP(defeatedEnemy, encounterType) {
            const base = GameState.config?.battleXpBase || 15;
            const level = Math.max(1, Number(defeatedEnemy?.level) || 1);
            const rarity = defeatedEnemy?.rarity || defeatedEnemy?.raridade || null;
            
            // Multiplicador de raridade (com fallback)
            const rarityMult = Number(GameState.config.rarityXP?.[rarity]) || 1.0;
            
            let xp = Math.floor((base + level * 2) * rarityMult);
            
            // Boss bonus (se encounterType for fornecido)
            if (encounterType && String(encounterType).toLowerCase() === 'boss') {
                xp = Math.floor(xp * 1.5);
            }
            
            return Math.max(1, xp);
        }
        
        /**
         * DÃ¡ XP para um monstro e processa level ups
         * @param {Object} mon - Monstro que receberÃ¡ XP
         * @param {number} amount - Quantidade de XP
         * @param {Array} logArr - Array de log (opcional, usa encounter.log se nÃ£o fornecido)
         */
        function giveXP(mon, amount, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            const xpGain = Math.max(0, Number(amount) || 0);
            if (xpGain <= 0) return;
            
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            mon.xp += xpGain;
            
            // Logar no array fornecido ou no encounter atual
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            if (Array.isArray(log)) {
                log.push(`ğŸ§ª ${name} ganhou +${xpGain} XP.`);
            }
            
            // Loop de level ups (pode subir mÃºltiplos nÃ­veis de uma vez)
            while (mon.xp >= mon.xpNeeded) {
                mon.xp -= mon.xpNeeded;
                levelUpMonster(mon, log);
            }
        }
        
        /**
         * Processa um level up para o monstro
         * @param {Object} mon - Monstro que vai subir de nÃ­vel
         * @param {Array} logArr - Array de log (opcional)
         */
        function levelUpMonster(mon, logArr) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Capturar HP% ANTES do level up para preservar na evoluÃ§Ã£o
            const hpPctBeforeLevelUp = Math.max(0, Number(mon.hp) || 0) / Math.max(1, Number(mon.hpMax) || 1);
            
            mon.level++;
            
            // Aumentar HP Max (fÃ³rmula oficial: hpMax * 1.04 + 2)
            const hpMax = Number(mon.hpMax) || Number(mon.maxHp) || 1;
            mon.hpMax = Math.floor(hpMax * 1.04 + 2);
            
            // Curar completamente ao subir de nÃ­vel
            mon.hp = mon.hpMax;
            
            // Atualizar ENE Max (cresce com level)
            const baseEne = 10; // base padrÃ£o
            const eneGrowth = 2; // crescimento por nÃ­vel
            mon.eneMax = Math.floor(baseEne + eneGrowth * (mon.level - 1));
            mon.ene = mon.eneMax; // Restaurar ENE ao subir de nÃ­vel
            
            // Recalcular stats baseado no novo nÃ­vel
            recalculateStatsFromTemplate(mon);
            
            // PrÃ³ximo XP necessÃ¡rio
            mon.xpNeeded = calcXpNeeded(mon.level);
            
            // Log com emoji especial
            const log = Array.isArray(logArr) ? logArr : (GameState.currentEncounter?.log || []);
            const name = mon.nickname || mon.name || mon.nome || "Monstrinho";
            if (Array.isArray(log)) {
                log.push(`âœ¨ ${name} subiu para o nÃ­vel ${mon.level}!`);
            }
            
            // Verificar e aplicar evoluÃ§Ã£o apÃ³s level up (passa o HP% original)
            maybeEvolveAfterLevelUp(mon, log, hpPctBeforeLevelUp);
            
            // Verificar e aplicar upgrade de skills (Feature 3.6)
            maybeUpgradeSkillsModelB(mon, log);
        }
        
        // Alias para compatibilidade
        function levelUp(mon) {
            return levelUpMonster(mon, GameState.currentEncounter?.log);
        }
        
        /**
         * Recalcula stats do monstro baseado no nÃ­vel e raridade (com fallbacks)
         * @param {Object} mon - Monstro para recalcular
         */
        function recalculateStatsFromTemplate(mon) {
            if (!mon) return;
            
            ensureMonsterProgressFields(mon);
            
            // Buscar template base do catÃ¡logo (com mÃºltiplos fallbacks)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            if (!template) return; // NÃ£o quebra se nÃ£o encontrar
            
            // Obter raridade (com fallback)
            const rarity = template.rarity || template.raridade || mon.rarity || mon.raridade;
            
            // Multiplicadores
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (Math.max(1, mon.level) - 1) * 0.1;
            
            // Base stats (com mÃºltiplos fallbacks)
            const baseAtk = Number(template.baseAtk ?? template.atkBase ?? template.atk) || 0;
            const baseDef = Number(template.baseDef ?? template.defBase ?? template.def) || 0;
            const baseSpd = Number(template.baseSpd ?? template.spdBase ?? template.spd) || 0;
            
            // Recalcular stats (HP Ã© tratado separadamente em levelUpMonster)
            mon.atk = Math.floor(baseAtk * levelMult * rarityMult);
            mon.def = Math.floor(baseDef * levelMult * rarityMult);
            mon.spd = Math.floor(baseSpd * levelMult * rarityMult);
        }
        
        // Alias para compatibilidade
        function recalculateStats(mon) {
            return recalculateStatsFromTemplate(mon);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FEATURE 3.4 â€” EVOLUTION (MVP)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Busca template base de um monstro no catÃ¡logo
         * @param {Object} mon - Monstro
         * @returns {Object|null} - Template encontrado ou null
         */
        function getMonsterTemplate(mon) {
            if (!mon) return null;
            
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const templateId = mon.monsterId || mon.idBase || mon.templateId;
            const template = catalog.find(m => String(m.id) === String(templateId));
            
            return template || null;
        }
        
        /**
         * Extrai dados de evoluÃ§Ã£o de um template (com fallbacks para mÃºltiplos nomes)
         * @param {Object} template - Template do monstro
         * @returns {Object|null} - { toId, atLv } ou null se nÃ£o evoluir
         */
        function getEvolutionData(template) {
            if (!template) return null;

            const evolvesTo = template.evolvesTo ?? template.evolve_to ?? template.evoluiPara ?? template.evolutionTo ?? null;
            const evolvesAt = template.evolvesAt ?? template.evolve_at ?? template.evoluiNoNivel ?? template.evolutionAt ?? null;

            const toId = evolvesTo != null ? String(evolvesTo) : "";
            const atLv = evolvesAt != null ? Number(evolvesAt) : NaN;

            if (!toId || !Number.isFinite(atLv) || atLv <= 0) return null;
            return { toId, atLv };
        }

        /**
         * Busca template do monstro evoluÃ­do
         * @param {Object} mon - Monstro atual
         * @returns {Object|null} - { nextTemplate, evolvesAt } ou null
         */
        function getEvolutionTargetTemplate(mon) {
            const currentTemplate = getMonsterTemplate(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return null;

            // Busca o template alvo no catÃ¡logo (usa MONSTER_CATALOG como fonte primÃ¡ria)
            const catalog = MONSTER_CATALOG || (window.DB?.MONSTERS) || (window.DB?.MONSTER_CATALOG) || [];
            const nextTemplate = catalog.find(m => String(m.id) === String(evo.toId));
            
            if (nextTemplate) return { nextTemplate, evolvesAt: evo.atLv };
            return null;
        }

        /**
         * Aplica evoluÃ§Ã£o no monstro (atualiza ID, nome, stats, preserva HP%)
         * @param {Object} mon - Monstro que vai evoluir
         * @param {Object} nextTemplate - Template da evoluÃ§Ã£o
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional, se nÃ£o fornecido usa HP% atual)
         */
        function applyEvolution(mon, nextTemplate, logArr, hpPctOverride) {
            if (!mon || !nextTemplate) return;

            // preserva % de HP (usa override se fornecido, senÃ£o usa o atual)
            let hpPct;
            if (hpPctOverride != null && Number.isFinite(hpPctOverride)) {
                hpPct = hpPctOverride;
            } else {
                const oldHp = Math.max(0, Number(mon.hp) || 0);
                const oldHpMax = Math.max(1, Number(mon.hpMax) || 1);
                hpPct = oldHp / oldHpMax;
            }

            const oldName = mon.nickname || mon.name || mon.nome || "Monstrinho";
            const newName = nextTemplate.name || nextTemplate.nome || oldName;

            // Atualiza o ID base do monstro (tenta manter compatibilidade)
            if (mon.monsterId != null) mon.monsterId = String(nextTemplate.id);
            else if (mon.templateId != null) mon.templateId = String(nextTemplate.id);
            else mon.monsterId = String(nextTemplate.id);

            // Atualiza campos visuais e de gameplay se existirem no template
            if (nextTemplate.name || nextTemplate.nome) mon.name = (nextTemplate.name || nextTemplate.nome);
            if (nextTemplate.emoji) mon.emoji = nextTemplate.emoji;
            if (nextTemplate.class || nextTemplate.classe) mon.class = (nextTemplate.class || nextTemplate.classe);
            if (nextTemplate.rarity || nextTemplate.raridade) mon.rarity = (nextTemplate.rarity || nextTemplate.raridade);

            // Recalcula stats com a nova forma
            recalculateStatsFromTemplate(mon);
            
            // Recalcula hpMax baseado no novo baseHp do template
            const baseHp = Number(nextTemplate.baseHp ?? nextTemplate.hpBase ?? nextTemplate.hp) || mon.hpMax || 1;
            const level = Math.max(1, mon.level);
            const rarity = nextTemplate.rarity || nextTemplate.raridade || mon.rarity;
            const rarityPowerMap = GameState.config.rarityPower || (window.DB?.RARITY_POWER) || {};
            const rarityMult = Number(rarityPowerMap[rarity]) || 1.0;
            const levelMult = 1 + (level - 1) * 0.1;
            
            // Nova hpMax baseada no template da evoluÃ§Ã£o
            mon.hpMax = Math.floor(baseHp * levelMult * rarityMult);

            // Ajuste final de HP mantendo percentual
            const newHpMax = Math.max(1, Number(mon.hpMax) || 1);
            mon.hp = Math.max(1, Math.floor(newHpMax * hpPct)); // mÃ­nimo 1 para nÃ£o "morrer" ao evoluir

            if (Array.isArray(logArr)) {
                logArr.push(`ğŸŒŸ ${oldName} evoluiu para ${newName}!`);
            }
            
            // Verificar e aplicar upgrade de skills apÃ³s evoluÃ§Ã£o (Feature 3.6)
            maybeUpgradeSkillsModelB(mon, logArr);
        }

        /**
         * Verifica e aplica evoluÃ§Ã£o se o monstro atingiu o nÃ­vel necessÃ¡rio
         * @param {Object} mon - Monstro a verificar
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% para usar (opcional)
         * @returns {boolean} - true se evoluiu, false caso contrÃ¡rio
         */
        function checkEvolution(mon, logArr, hpPctOverride) {
            if (!mon) return false;
            ensureMonsterProgressFields(mon);

            const currentTemplate = getMonsterTemplate(mon);
            const evo = getEvolutionData(currentTemplate);
            if (!evo) return false;

            if (mon.level < evo.atLv) return false;

            const target = getEvolutionTargetTemplate(mon);
            if (!target?.nextTemplate) return false;

            applyEvolution(mon, target.nextTemplate, logArr, hpPctOverride);
            return true;
        }

        /**
         * Tenta evoluir monstro apÃ³s level up (no mÃ¡ximo 1 evoluÃ§Ã£o por levelUp no MVP)
         * @param {Object} mon - Monstro que acabou de subir de nÃ­vel
         * @param {Array} logArr - Array de log (opcional)
         * @param {number} hpPctOverride - HP% de antes do level up para preservar
         */
        function maybeEvolveAfterLevelUp(mon, logArr, hpPctOverride) {
            checkEvolution(mon, logArr, hpPctOverride);
        }
        
        // =============================
        // FEATURE 3.6 â€” SKILLS (MODEL B) AUTO UPGRADE I->II->III
        // =============================

        /**
         * Determina o estÃ¡gio do monstro baseado no nÃ­vel
         * @param {number} level - NÃ­vel do monstro
         * @returns {string} - EstÃ¡gio (S0, S1, S2, S3)
         */
        function getMonsterStage(level) {
            const lv = Math.max(1, Number(level) || 1);
            if (lv <= 9) return "S0";
            if (lv <= 24) return "S1";
            if (lv <= 44) return "S2";
            return "S3";
        }

        /**
         * Determina o tier de skill desejado baseado no estÃ¡gio
         * @param {string} stage - EstÃ¡gio do monstro (S0, S1, S2, S3)
         * @returns {number} - Tier desejado (1, 2, ou 3)
         */
        function getDesiredSkillTier(stage) {
            // MVP mapping: S0/S1 => I, S2 => II, S3 => III
            if (stage === "S2") return 2;
            if (stage === "S3") return 3;
            return 1;
        }

        /**
         * ObtÃ©m array de skills do monstro (compatÃ­vel com mÃºltiplos formatos)
         * @param {Object} mon - Monstro
         * @returns {Array} - Array de skill IDs
         */
        function getSkillsArray(mon) {
            if (!mon) return [];
            // formatos comuns: mon.skills (array) ou mon.skillIds (array)
            if (Array.isArray(mon.skills)) return mon.skills.slice();
            if (Array.isArray(mon.skillIds)) return mon.skillIds.slice();
            return [];
        }

        /**
         * Define array de skills no monstro
         * @param {Object} mon - Monstro
         * @param {Array} arr - Array de skill IDs
         */
        function setSkillsArray(mon, arr) {
            if (!mon) return;
            // preferir mon.skills se jÃ¡ existe, senÃ£o criar
            if (Array.isArray(mon.skills) || mon.skills == null) mon.skills = arr.slice();
            else mon.skillIds = arr.slice();
        }

        /**
         * ObtÃ©m catÃ¡logo de skills de mÃºltiplas fontes possÃ­veis
         * @returns {Array} - CatÃ¡logo de skills
         */
        function getSkillCatalog() {
            const candidates = [];
            
            // Verificar SKILLS_CATALOG definido no escopo local
            if (typeof SKILLS_CATALOG !== 'undefined' && Array.isArray(SKILLS_CATALOG)) {
                candidates.push(SKILLS_CATALOG);
            }
            
            if (window.DB) {
                if (Array.isArray(DB.SKILLS)) candidates.push(DB.SKILLS);
                if (Array.isArray(DB.HABILIDADES)) candidates.push(DB.HABILIDADES);
                if (Array.isArray(DB.ABILITIES)) candidates.push(DB.ABILITIES);
            }
            if (Array.isArray(window.SKILLS)) candidates.push(window.SKILLS);
            if (Array.isArray(window.SKILLS_CATALOG)) candidates.push(window.SKILLS_CATALOG);
            if (Array.isArray(window.ABILITIES)) candidates.push(window.ABILITIES);
            return candidates.find(arr => Array.isArray(arr) && arr.length) || [];
        }

        /**
         * Busca skill por ID no catÃ¡logo
         * @param {string} id - ID da skill
         * @returns {Object|null} - Objeto da skill ou null
         */
        function getSkillById(id) {
            const sid = String(id || "");
            if (!sid) return null;
            const cat = getSkillCatalog();
            return cat.find(s => String(s.id) === sid) || null;
        }

        /**
         * Extrai a "famÃ­lia" de uma skill (remove sufixos de tier)
         * @param {Object|string} skillOrId - Skill object ou ID
         * @returns {string} - Chave da famÃ­lia
         */
        function getSkillFamilyKey(skillOrId) {
            const skill = typeof skillOrId === "object" ? skillOrId : getSkillById(skillOrId);
            const id = String(skill?.id ?? skillOrId ?? "");
            const name = String(skill?.name ?? skill?.nome ?? "");

            // 1) por ID (mais confiÃ¡vel)
            if (id) {
                // exemplos: FIREBALL_I, FIREBALL_II, FIREBALL_III
                let base = id
                    .replace(/(_I|_II|_III)$/i, "")
                    .replace(/(-I|-II|-III)$/i, "");
                if (base !== id) return base;
            }

            // 2) por nome
            if (name) {
                const baseName = name.replace(/\s+(I|II|III)$/i, "").trim();
                if (baseName && baseName !== name) return baseName.toLowerCase();
            }

            // 3) fallback: o prÃ³prio id
            return id || name.toLowerCase() || "";
        }

        /**
         * Busca variante de skill pela famÃ­lia e tier desejado
         * @param {string} familyKey - Chave da famÃ­lia da skill
         * @param {number} tier - Tier desejado (1, 2, ou 3)
         * @returns {Object|null} - Skill encontrada ou null
         */
        function findSkillVariantByFamily(familyKey, tier) {
            const cat = getSkillCatalog();
            if (!familyKey || !cat.length) return null;

            const roman = tier === 3 ? "III" : tier === 2 ? "II" : "I";
            const fk = String(familyKey);

            // tentar padrÃµes de ID
            const idCandidates = [
                `${fk}_${roman}`, `${fk}-${roman}`,
                `${fk.toUpperCase()}_${roman}`, `${fk.toUpperCase()}-${roman}`,
            ];

            for (const cand of idCandidates) {
                const hit = cat.find(s => String(s.id) === cand);
                if (hit) return hit;
            }

            // tentar por famÃ­lia via getSkillFamilyKey + nome com sufixo
            const romanNameSuffix = " " + roman;
            const fkLower = fk.toLowerCase();

            // primeira passada: famÃ­lia igual + nome termina com roman
            for (const s of cat) {
                const fam = getSkillFamilyKey(s);
                const nm = String(s.name ?? s.nome ?? "");
                if (fam && String(fam).toLowerCase() === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            // segunda passada: nome base igual + roman
            for (const s of cat) {
                const nm = String(s.name ?? s.nome ?? "");
                const base = nm.replace(/\s+(I|II|III)$/i, "").trim().toLowerCase();
                if (base && base === fkLower && nm.endsWith(romanNameSuffix)) return s;
            }

            return null;
        }
        
        // =============================
        // FEATURE 3.8 â€” BATTLE POLISH (VISUAL FEEDBACK)
        // =============================
        
        /**
         * Mostra texto flutuante (dano/cura) sobre um elemento
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} text - Texto a exibir (ex: "-12", "+8")
         * @param {string} kind - Tipo: "damage", "heal", "crit"
         */
        function showFloatingText(target, text, kind = 'damage') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const floater = document.createElement('div');
                floater.className = `floating-text ${kind}`;
                floater.textContent = text;
                
                // Posicionar no centro do elemento alvo
                const rect = element.getBoundingClientRect();
                floater.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floater.style.top = `${rect.top + rect.height / 2 - 20}px`;
                
                document.body.appendChild(floater);
                
                // Remover apÃ³s animaÃ§Ã£o
                setTimeout(() => floater.remove(), 1000);
            } catch (error) {
                console.error('showFloatingText error:', error);
            }
        }
        
        /**
         * Aplica efeito de flash no alvo
         * @param {string|HTMLElement} target - ID ou elemento do alvo
         * @param {string} type - Tipo: "crit", "fail", "hit"
         */
        function flashTarget(target, type = 'hit') {
            try {
                const element = typeof target === 'string' ? document.getElementById(target) : target;
                if (!element) return;
                
                const className = `flash-${type}`;
                element.classList.add(className);
                
                setTimeout(() => element.classList.remove(className), 400);
            } catch (error) {
                console.error('flashTarget error:', error);
            }
        }
        
        /**
         * Armazena o Ãºltimo roll de d20 no encounter
         * @param {Object} enc - Encounter
         * @param {string} name - Nome de quem rolou
         * @param {number} roll - Valor do d20
         * @param {string} type - "crit", "fail", ou "normal"
         */
        function recordD20Roll(enc, name, roll, type = 'normal') {
            if (!enc) return;
            enc.lastRoll = { name, roll, type };
        }

        /**
         * Tenta fazer upgrade automÃ¡tico das skills quando monstro muda de estÃ¡gio
         * @param {Object} mon - Monstro
         * @param {Array} logArr - Array de log (opcional)
         */
        function maybeUpgradeSkillsModelB(mon, logArr) {
            if (!mon) return;

            const stageNow = getMonsterStage(mon.level);
            const tierNow = getDesiredSkillTier(stageNow);

            // dedupe: sÃ³ roda quando estÃ¡gio muda
            if (mon._skillStage === stageNow) return;

            const skills = getSkillsArray(mon);
            if (!skills.length) {
                // MVP: se nÃ£o tem skills, nÃ£o inventa. Apenas marca estÃ¡gio para nÃ£o spammar.
                mon._skillStage = stageNow;
                return;
            }

            let changed = false;
            const newSkills = skills.map(oldId => {
                const oldSkill = getSkillById(oldId);
                const family = getSkillFamilyKey(oldSkill || oldId);
                if (!family) return oldId;

                const variant = findSkillVariantByFamily(family, tierNow);
                if (!variant) return oldId;

                const newId = String(variant.id);
                if (newId && newId !== String(oldId)) {
                    changed = true;

                    const monName = mon.nickname || mon.name || mon.nome || "Monstrinho";
                    const newName = variant.name || variant.nome || newId;

                    if (Array.isArray(logArr)) {
                        logArr.push(`ğŸ“ ${monName} aprendeu ${newName}!`);
                    }
                    return newId;
                }
                return oldId;
            });

            if (changed) setSkillsArray(mon, newSkills);

            mon._skillStage = stageNow;
        }
        
        // =============================
        // FEATURE 3.7 â€” SKILLS HUD UI
        // =============================
        
        /**
         * Formata o label de um botÃ£o de skill mostrando nome e custo ENE
         * @param {Object} skill - Skill do catÃ¡logo
         * @param {Object} mon - Monstro (para contexto futuro se necessÃ¡rio)
         * @returns {string} - Label formatado
         */
        function formatSkillButtonLabel(skill, mon) {
            if (!skill) return "Habilidade";
            
            const name = skill.name || skill.nome || String(skill.id);
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const power = Number(skill.power ?? skill.POWER ?? skill.pwr ?? 0) || 0;
            
            // emoji opcional: se jÃ¡ tiver no dataset, usa
            const icon = skill.icon || "";
            
            // MVP: nome + ENE (sem poluir)
            const parts = [];
            if (icon) parts.push(icon);
            parts.push(name);
            if (cost > 0) parts.push(`(ENE ${cost})`);
            
            return parts.join(" ");
        }
        
        /**
         * Verifica se o monstro tem ENE suficiente para usar a skill
         * @param {Object} skill - Skill do catÃ¡logo
         * @param {Object} mon - Monstro
         * @returns {boolean} - true se pode usar
         */
        function canUseSkillNow(skill, mon) {
            if (!skill || !mon) return false;
            const cost = Number(skill.energy_cost ?? skill.eneCost ?? skill.cost ?? skill.ene ?? 0) || 0;
            const ene = Number(mon.ene ?? mon.ENE ?? 0) || 0;
            return ene >= cost;
        }
        
        /**
         * Distribui XP para todos participantes vivos de uma batalha em grupo
         * @param {Object} enc - Encounter de grupo
         */
        function distributeGroupXP(enc) {
            if (!enc || !enc.rewards || !enc.rewards.xp) return;
            
            const xp = enc.rewards.xp;
            
            enc.participants.forEach(pid => {
                const player = _getPlayerById(pid);
                const mon = _getActiveMonsterOfPlayer(player);
                
                // SÃ³ ganha XP se estiver vivo
                if (!mon || mon.hp <= 0) return;
                
                giveXP(mon, xp);
            });
        }
        
        /**
         * Distribui XP para o jogador de uma batalha wild (1v1)
         * @param {Object} encounter - Encounter wild
         */
        function distributeWildXP(encounter) {
            if (!encounter || !encounter.rewards || !encounter.rewards.xp) return;
            
            const player = GameState.players.find(p => p.id === encounter.selectedPlayerId);
            const mon = player?.team?.[0];
            
            // SÃ³ ganha XP se estiver vivo
            if (!mon || mon.hp <= 0) return;
            
            giveXP(mon, encounter.rewards.xp);
        }
        
        /**
         * Distribui recompensas de vitÃ³ria de forma idempotente (XP + recompensas futuras)
         * Previne duplicaÃ§Ã£o via flag rewardsGranted
         * @param {Object} enc - Encounter (wild ou group)
         */
        function handleVictoryRewards(enc) {
            if (!enc || enc.rewardsGranted) return;
            enc.rewardsGranted = true;
            
            enc.log = enc.log || [];
            
            // Determinar inimigo derrotado principal (primeiro inimigo)
            const defeated = (enc.enemies && enc.enemies[0]) ? enc.enemies[0] : enc.wildMonster;
            if (!defeated) {
                enc.log.push("â„¹ï¸ (XP) NÃ£o foi possÃ­vel identificar inimigo derrotado.");
                return;
            }
            
            // Calcular XP
            const xp = calculateBattleXP(defeated, enc.type);
            enc.rewards = enc.rewards || {};
            enc.rewards.xp = xp;
            enc.log.push(`ğŸ… Recompensa: ${xp} XP.`);
            
            // Distribuir XP baseado no tipo de batalha
            const isGroup = String(enc.type || '').includes("group") || 
                           String(enc.type || '').toLowerCase() === "boss" ||
                           enc.participants?.length > 0;
            
            if (isGroup) {
                // Grupo: cada participante vivo recebe XP completo
                for (const pid of (enc.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    const mon = p?.team?.[0];
                    if (!mon || (Number(mon.hp) || 0) <= 0) continue;
                    giveXP(mon, xp, enc.log);
                }
            } else {
                // 1v1: jogador atual (ou primeiro se nÃ£o especificado)
                let player = null;
                if (enc.selectedPlayerId || enc.currentPlayerId) {
                    player = GameState.players.find(p => 
                        p.id === (enc.selectedPlayerId || enc.currentPlayerId)
                    );
                }
                if (!player) player = GameState.players?.[0] || null;
                
                const mon = player?.team?.[0];
                if (mon && (Number(mon.hp) || 0) > 0) {
                    giveXP(mon, xp, enc.log);
                }
            }
        }
        
        function renderGroupEncounter(panel, encounter) {
            try {
                if (!encounter) return;
                
                const actor = getCurrentActor(encounter);
                const isPlayerTurn = actor && actor.side === 'player';
                
                let html = '<div class="encounter-panel">';
                html += renderTutorialBanner(encounter);
                html += '<h3>âš”ï¸ Batalha em Grupo</h3>';
                
                // Last d20 roll badge
                if (encounter.lastRoll) {
                    const lr = encounter.lastRoll;
                    const badgeClass = lr.type === 'crit' ? 'crit' : lr.type === 'fail' ? 'fail' : '';
                    const emoji = lr.type === 'crit' ? 'ğŸŒŸ' : lr.type === 'fail' ? 'ğŸ’¥' : 'ğŸ²';
                    html += `<div class="d20-badge ${badgeClass}">${emoji} ${lr.name}: ${lr.roll} ${lr.type === 'crit' ? '(CRIT!)' : lr.type === 'fail' ? '(FALHA!)' : ''}</div>`;
                }
                
                // Indicador de turno atual
                if (actor) {
                    const sideColor = actor.side === 'player' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${sideColor}; color: white; padding: 10px; margin: 10px 0; border-radius: 4px;">`;
                    html += `<strong>âºï¸ Turno: ${actor.name}</strong> (${actor.side === 'player' ? 'Jogador' : 'Inimigo'})`;
                    html += `</div>`;
                }
                
                // Participantes (jogadores)
                html += '<div style="margin: 15px 0;">';
                html += '<h4>ğŸ‘¥ Participantes:</h4>';
                for (const pid of (encounter.participants || [])) {
                    const p = GameState.players.find(x => x.id === pid);
                    if (!p) continue;
                    
                    const mon = p.team?.[0];
                    if (!mon) continue;
                    
                    // Garantir campos de XP
                    ensureXpFields(mon);
                    
                    const hp = Number(mon.hp) || 0;
                    const hpMax = Number(mon.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    
                    const xp = Math.max(0, Number(mon.xp) || 0);
                    const xpNeeded = Math.max(1, Number(mon.xpNeeded) || calcXpNeeded(mon.level));
                    const xpPct = Math.max(0, Math.min(100, Math.floor((xp / xpNeeded) * 100)));
                    
                    const isCurrent = actor && actor.side === 'player' && actor.id === pid;
                    
                    const border = isCurrent ? '3px solid #4CAF50' : '1px solid #ddd';
                    html += `<div id="grpP_${pid}" style="background: #f5f5f5; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border}; position: relative;">`;
                    html += `<strong>${p.name || p.nome}</strong> (${p.class})`;
                    html += `<br>${mon.name || mon.nome} - Nv ${mon.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `<div class="progress-bar" style="margin-top:6px;">`;
                    html += `<div class="progress-fill xp" style="width:${xpPct}%"></div>`;
                    html += `</div>`;
                    html += `<div class="small" style="margin-top:4px;">XP: ${xp}/${xpNeeded} (${xpPct}%)</div>`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // Inimigos
                html += '<div style="margin: 15px 0;">';
                html += '<h4>ğŸ‘¹ Inimigos:</h4>';
                for (let i = 0; i < (encounter.enemies || []).length; i++) {
                    const e = encounter.enemies[i];
                    if (!e) continue;
                    
                    const hp = Number(e.hp) || 0;
                    const hpMax = Number(e.hpMax) || 1;
                    const hpPercent = Math.floor((hp / hpMax) * 100);
                    const isCurrent = actor && actor.side === 'enemy' && actor.id === i;
                    
                    const border = isCurrent ? '3px solid #f44336' : '1px solid #ddd';
                    html += `<div id="grpE_${i}" style="background: #ffebee; padding: 10px; margin: 5px 0; border-radius: 4px; border: ${border}; position: relative;">`;
                    html += `<strong>${e.name || e.nome}</strong> - Nv ${e.level}`;
                    html += `<br>HP: ${hp}/${hpMax} (${hpPercent}%)`;
                    html += `<br>SPD: ${e.spd} | ATK: ${e.atk} | DEF: ${e.def}`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // AÃ§Ãµes (apenas para turno do jogador)
                if (isPlayerTurn && !encounter.finished) {
                    html += '<div style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 4px;">';
                    html += '<h4>AÃ§Ãµes:</h4>';
                    html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">';
                    html += '<button class="btn btn-danger" onclick="groupAttack()">âš”ï¸ Atacar</button>';
                    html += '<button class="btn btn-primary" onclick="groupPassTurn()">â­ï¸ Passar</button>';
                    html += '</div>';
                    
                    // Feature 3.7: Skills buttons for current player
                    if (actor && actor.side === 'player') {
                        const player = GameState.players.find(p => p.id === actor.id);
                        const mon = player?.team?.[0];
                        if (mon) {
                            const skillIds = getSkillsArray(mon);
                            if (skillIds && skillIds.length > 0) {
                                html += '<div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 8px;">';
                                html += '<strong style="font-size: 16px;">âœ¨ Habilidades</strong>';
                                html += '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">';
                                
                                skillIds.forEach((skillId, idx) => {
                                    const skill = getSkillById(skillId);
                                    if (!skill) return;
                                    
                                    const label = formatSkillButtonLabel(skill, mon);
                                    const canUse = canUseSkillNow(skill, mon) && mon.hp > 0;
                                    const tooltip = canUse ? (skill.desc || skill.descricao || '') : 'Sem ENE';
                                    
                                    html += `
                                    <button class="btn btn-info" 
                                            onclick="groupUseSkill(${idx})" 
                                            ${!canUse ? 'disabled style="opacity: 0.5;"' : ''}
                                            title="${tooltip}">
                                        ${label}
                                    </button>
                                    `;
                                });
                                
                                html += '</div>';
                                html += '</div>';
                            }
                        }
                    }
                    
                    html += '</div>';
                }
                
                // Mensagem de fim com recompensas
                if (encounter.finished) {
                    const resultColor = encounter.result === 'victory' ? '#4CAF50' : '#f44336';
                    html += `<div style="background: ${resultColor}; color: white; padding: 15px; margin: 15px 0; border-radius: 4px;">`;
                    html += `<h3>${encounter.result === 'victory' ? 'ğŸ VITÃ“RIA!' : 'ğŸ’€ DERROTA'}</h3>`;
                    
                    // Recompensas na vitÃ³ria
                    if (encounter.result === 'victory') {
                        html += '<div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.2); border-radius: 4px;">';
                        html += '<strong>ğŸ’° Recompensas:</strong><br>';
                        
                        // Dinheiro dividido
                        const totalCoins = Math.floor(Math.random() * 31) + 30; // 30-60
                        const coinsPerPlayer = Math.floor(totalCoins / encounter.participants.length);
                        
                        for (const pid of encounter.participants) {
                            const p = GameState.players.find(pl => pl.id === pid);
                            if (p) {
                                p.coins = (p.coins || 0) + coinsPerPlayer;
                                html += `${p.name}: +${coinsPerPlayer} moedas<br>`;
                            }
                        }
                        
                        html += '<br><em>â„¹ï¸ XP serÃ¡ implementado na Feature 3.3</em>';
                        html += '</div>';
                        saveToLocalStorage();
                    }
                    
                    html += `</div>`;
                    html += '<button class="btn btn-secondary" onclick="GameState.currentEncounter = null; saveToLocalStorage(); renderEncounter();">Fechar</button>';
                }
                
                // Log de combate
                html += '<div style="margin-top: 20px;">';
                html += '<h4>ğŸ“œ Log de Combate:</h4>';
                html += '<div style="background: #f9f9f9; padding: 10px; border-radius: 4px; max-height: 300px; overflow-y: auto;">';
                const logs = encounter.log || [];
                for (let i = Math.max(0, logs.length - 20); i < logs.length; i++) {
                    html += `<div>${logs[i]}</div>`;
                }
                html += '</div>';
                html += '</div>';
                
                html += '</div>';
                
                panel.innerHTML = html;
                
                // Exibir toasts para eventos importantes (level up, evoluÃ§Ã£o)
                maybeToastFromLog(encounter);
                
                // Feature 4.4: Tocar sons para level up e evoluÃ§Ã£o
                maybeSfxFromLog(encounter);
            } catch (error) {
                showError('Failed to render group encounter', error.stack);
            }
        }

        function renderEncounter() {
            try {
                const panel = document.getElementById('encounterPanel');
                if (!panel) return;
                
                const encounter = GameState.currentEncounter;
                
                if (!encounter || !encounter.active) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                if (encounter.type === 'wild') {
                    renderWildEncounter(panel, encounter);
                } else if (encounter.type === 'group_trainer' || encounter.type === 'boss') {
                    renderGroupEncounter(panel, encounter);
                } else {
                    panel.innerHTML = '<div class="encounter-panel"><h3>Encounter type not yet implemented</h3></div>';
                }
            } catch (error) {
                showError('Failed to render encounter', error.stack);
            }
        }

        function renderWildEncounter(panel, encounter) {
            try {
                const monster = encounter.wildMonster;
                if (!monster) return;
                
                // Buscar jogador selecionado
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                const playerMonster = player?.team?.[0];
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const canCapture = hpPercent <= baseThreshold;
                
                const html = `
                    <div class="encounter-panel">
                        ${renderTutorialBanner(encounter)}
                        <h3>Wild ${monster.emoji} ${monster.name} appeared!</h3>
                        ${encounter.lastRoll ? (() => {
                            const lr = encounter.lastRoll;
                            const badgeClass = lr.type === 'crit' ? 'crit' : lr.type === 'fail' ? 'fail' : '';
                            const emoji = lr.type === 'crit' ? 'ğŸŒŸ' : lr.type === 'fail' ? 'ğŸ’¥' : 'ğŸ²';
                            return `<div class="d20-badge ${badgeClass}">${emoji} ${lr.name}: ${lr.roll} ${lr.type === 'crit' ? '(CRIT!)' : lr.type === 'fail' ? '(FALHA!)' : ''}</div>`;
                        })() : ''}
                        ${player ? `<p><strong>Jogador:</strong> ${player.name} (${player.class})</p>` : ''}
                        ${playerMonster ? (() => {
                            const xpCurrent = playerMonster.xp || 0;
                            const xpNeeded = playerMonster.xpNeeded || calcXpNeeded(playerMonster.level);
                            const xpPercent = Math.max(0, Math.min(100, (xpCurrent / xpNeeded) * 100));
                            
                            return `
                        <div id="wildPlayerBox" style="margin: 10px 0; padding: 10px; background: #e8f5e9; border-radius: 8px; position: relative;">
                            <p><strong>Seu Monstrinho:</strong> ${playerMonster.emoji} ${playerMonster.name} (Nv ${playerMonster.level})</p>
                            <div><strong>HP:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                            <div><strong>âš¡ ENE:</strong> ${playerMonster.ene || 0}/${playerMonster.eneMax || 0}</div>
                            <div class="progress-bar" style="height: 15px; margin-top: 5px;">
                                <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                            </div>
                            <small><strong>XP:</strong> ${xpCurrent}/${xpNeeded} (${Math.floor(xpPercent)}%)</small>
                        </div>
                        `;
                        })() : ''}
                        
                        <div id="wildEnemyBox" class="monster-card ${monster.class}" style="display: inline-block; margin: 20px; position: relative;">
                            <div style="font-size: 48px;">${monster.emoji}</div>
                            <strong>${monster.name}</strong>
                            <div class="badge badge-${monster.rarity}">${monster.rarity}</div>
                            <div><strong>Classe:</strong> ${monster.class}</div>
                            <div><strong>Level:</strong> ${monster.level}</div>
                            <div style="margin-top: 8px;">
                                <div><strong>ATK:</strong> ${monster.atk} | <strong>DEF:</strong> ${monster.def}</div>
                                <div><strong>PODER:</strong> ${monster.poder}</div>
                                <div><strong>âš¡ ENE:</strong> ${monster.ene || 0}/${monster.eneMax || 0}</div>
                            </div>
                            <div class="progress-bar" style="margin-top: 10px;">
                                <div class="progress-fill hp" style="width: ${(monster.hp / monster.hpMax) * 100}%">
                                    ${monster.hp}/${monster.hpMax} HP (${Math.floor(hpPercent * 100)}%)
                                </div>
                            </div>
                            ${canCapture ? 
                                '<div style="color: green; margin-top: 5px;">âœ… HP baixo! Pode tentar captura!</div>' : 
                                `<div style="color: orange; margin-top: 5px;">âš ï¸ Abaixe HP para ${Math.floor(baseThreshold * 100)}% para capturar</div>`
                            }
                        </div>
                        
                        <h4>Choose Action:</h4>
                        <div class="flex-center" style="flex-direction: column;">
                            <div style="margin: 10px 0;">
                                <label style="font-weight: bold; font-size: 18px;">ğŸ² Enter your d20 roll:</label>
                                <input type="number" id="diceRoll" min="1" max="20" placeholder="1-20" 
                                       style="width: 120px; text-align: center; font-size: 24px; font-weight: bold; height: 60px; margin: 10px;">
                            </div>
                            
                            ${player ? (() => {
                                const comum = player.inventory?.['CLASTERORB_COMUM'] || 0;
                                const incomum = player.inventory?.['CLASTERORB_INCOMUM'] || 0;
                                const rara = player.inventory?.['CLASTERORB_RARA'] || 0;
                                const hasAnyOrb = comum > 0 || incomum > 0 || rara > 0;
                                
                                return `
                                <div style="margin: 15px 0; background: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #1976d2;">
                                    <strong style="font-size: 16px;">ğŸ¯ Sistema de Captura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>HP% Selvagem:</strong> ${Math.floor(hpPercent * 100)}%</div>
                                        <div><strong>Base Threshold (${monster.rarity}):</strong> ${Math.floor(baseThreshold * 100)}%</div>
                                        <div><strong>BÃ´nus HP Baixo (â‰¤25%):</strong> ${hpPercent <= 0.25 ? '+10%' : '0%'}</div>
                                    </div>
                                    
                                    ${hasAnyOrb ? `
                                    <div style="margin-top: 10px;">
                                        <label style="font-weight: bold;">Escolha sua ClasterOrb:</label>
                                        <select id="captureOrbSelect" onchange="updateCaptureThreshold()" style="width: 100%; padding: 8px; margin: 5px 0; font-size: 14px;">
                                            ${comum > 0 ? `<option value="CLASTERORB_COMUM">âšª Comum (${comum}x) - +0% bonus</option>` : ''}
                                            ${incomum > 0 ? `<option value="CLASTERORB_INCOMUM">ğŸ”µ Incomum (${incomum}x) - +5% bonus</option>` : ''}
                                            ${rara > 0 ? `<option value="CLASTERORB_RARA">ğŸŸ£ Rara (${rara}x) - +10% bonus</option>` : ''}
                                        </select>
                                    </div>
                                    <div id="captureThresholdDisplay" style="margin-top: 10px; padding: 10px; background: #fff; border-radius: 5px;">
                                        <strong>Threshold Final:</strong> <span id="finalThresholdValue">Calculando...</span>
                                    </div>
                                    ` : `
                                    <div style="margin-top: 10px; padding: 10px; background: #ffebee; color: #c62828; border-radius: 5px;">
                                        <strong>âŒ Sem ClasterOrbs!</strong><br>
                                        VocÃª nÃ£o tem orbes de captura disponÃ­veis.
                                    </div>
                                    `}
                                    
                                    <div style="margin-top: 10px;">
                                        <strong>ğŸ“¦ InventÃ¡rio:</strong> 
                                        âšª ${comum} | ğŸ”µ ${incomum} | ğŸŸ£ ${rara} | 
                                        ğŸ’š Cura: ${player.inventory?.['IT_HEAL_01'] || 0}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                            
                            <div class="flex-center">
                                ${player && (player.inventory?.['CLASTERORB_COMUM'] > 0 || player.inventory?.['CLASTERORB_INCOMUM'] > 0 || player.inventory?.['CLASTERORB_RARA'] > 0) ? 
                                    `<button class="btn btn-success btn-large" onclick="attemptCapture()" ${tutorialAllows("capture") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>ğŸ¯ Tentar Capturar</button>` :
                                    `<button class="btn btn-success btn-large" disabled style="opacity: 0.5;">ğŸ¯ Sem Orbes</button>`
                                }
                                <button class="btn btn-danger btn-large" onclick="attackWild()" ${tutorialAllows("attack") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>âš”ï¸ Attack</button>
                                <button class="btn btn-warning btn-large" onclick="fleeEncounter()" ${tutorialAllows("flee") ? "" : "disabled title='Tutorial: ainda nÃ£o liberado'"}>ğŸƒ Flee</button>
                            </div>
                            
                            ${playerMonster && player ? (() => {
                                const healItems = player.inventory?.['IT_HEAL_01'] || 0;
                                const canUseItem = healItems > 0 && playerMonster.hp > 0 && playerMonster.hp < playerMonster.hpMax;
                                
                                return `
                                <div style="margin: 15px 0; padding: 15px; background: #e8f5e9; border-radius: 8px; border: 2px solid #4caf50;">
                                    <strong style="font-size: 16px;">ğŸ’š Usar Item de Cura</strong>
                                    <div style="margin-top: 10px;">
                                        <div><strong>Petisco de Cura disponÃ­vel:</strong> ${healItems}x</div>
                                        <div><strong>HP atual:</strong> ${playerMonster.hp}/${playerMonster.hpMax}</div>
                                        ${!canUseItem && healItems === 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">âŒ Sem itens de cura disponÃ­veis</div>` : 
                                            !canUseItem && playerMonster.hp <= 0 ? 
                                            `<div style="color: #c62828; margin-top: 5px;">âŒ Monstrinho desmaiado, nÃ£o pode usar item</div>` :
                                            !canUseItem && playerMonster.hp >= playerMonster.hpMax ?
                                            `<div style="color: #f57c00; margin-top: 5px;">âš ï¸ HP jÃ¡ estÃ¡ cheio</div>` : ''
                                        }
                                    </div>
                                    <button class="btn btn-primary" 
                                            onclick="useItemInBattle('IT_HEAL_01')"
                                            ${!canUseItem || !tutorialAllows("item") ? 'disabled style="opacity: 0.5;"' : ''}
                                            ${!tutorialAllows("item") ? 'title="Tutorial: ainda nÃ£o liberado"' : ''}
                                            style="margin-top: 10px; width: 100%;">
                                        ğŸ’š Usar Petisco de Cura
                                    </button>
                                </div>
                                `;
                            })() : ''}
                            
                            ${playerMonster ? (() => {
                                // Feature 3.7: Use skill catalog and getSkillsArray
                                const skillIds = getSkillsArray(playerMonster);
                                if (!skillIds || skillIds.length === 0) return '';
                                
                                return `
                                <div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 8px;">
                                    <strong style="font-size: 16px;">âœ¨ Habilidades</strong>
                                    <div class="flex-center" style="margin-top: 10px; gap: 10px;">
                                        ${skillIds.map((skillId, idx) => {
                                            const skill = getSkillById(skillId);
                                            if (!skill) return '';
                                            
                                            const label = formatSkillButtonLabel(skill, playerMonster);
                                            const canUse = canUseSkillNow(skill, playerMonster) && playerMonster.hp > 0;
                                            const tutAllows = tutorialAllows("skill");
                                            const tooltip = !tutAllows ? 'Tutorial: ainda nÃ£o liberado' : (canUse ? (skill.desc || skill.descricao || '') : 'Sem ENE');
                                            
                                            return `
                                            <button class="btn btn-primary" 
                                                    onclick="useSkillWild(${idx})" 
                                                    ${!canUse || !tutAllows ? 'disabled style="opacity: 0.5;"' : ''}
                                                    title="${tooltip}">
                                                ${label}
                                            </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                                `;
                            })() : ''}
                        </div>
                        
                        <div class="combat-log" id="combatLog" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px; max-height: 300px; overflow-y: auto;">
                            ${(encounter.log || []).map(entry => `<div style="margin: 5px 0; padding: 5px; border-bottom: 1px solid #ddd;">${entry}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                panel.innerHTML = html;
                
                // Atualizar threshold inicial
                setTimeout(() => updateCaptureThreshold(), 100);
                
                // Exibir toasts para eventos importantes (level up, evoluÃ§Ã£o)
                maybeToastFromLog(GameState.currentEncounter);
                
                // Feature 4.4: Tocar sons para level up e evoluÃ§Ã£o
                maybeSfxFromLog(GameState.currentEncounter);
            } catch (error) {
                showError('Failed to render wild encounter', error.stack);
            }
        }

        // Atualizar cÃ¡lculo de threshold de captura em tempo real
        function updateCaptureThreshold() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const select = document.getElementById('captureOrbSelect');
                const display = document.getElementById('finalThresholdValue');
                if (!select || !display) return;
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) return;
                
                // Calcular threshold
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                const orbBonus = orbInfo.capture_bonus_pp / 100; // Converter pp para decimal
                const lowHpBonus = hpPercent <= 0.25 ? 0.10 : 0;
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                // Atualizar display
                display.innerHTML = `
                    <span style="font-size: 18px; color: ${hpPercent <= thresholdFinal ? '#2e7d32' : '#c62828'}; font-weight: bold;">
                        ${Math.floor(thresholdFinal * 100)}%
                    </span>
                    <br><small>
                        (Base ${Math.floor(baseThreshold * 100)}% + Orb ${orbInfo.capture_bonus_pp}% + HP ${Math.floor(lowHpBonus * 100)}%)
                        <br>${hpPercent <= thresholdFinal ? 'âœ… Captura provÃ¡vel!' : 'âŒ HP muito alto'}
                    </small>
                `;
            } catch (error) {
                console.error('Failed to update capture threshold:', error);
            }
        }

        function attemptCapture() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const monster = encounter.wildMonster;
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                // ValidaÃ§Ã£o: HP > 0 obrigatÃ³rio
                if (monster.hp <= 0) {
                    alert('âŒ NÃ£o pode capturar um monstrinho desmaiado! HP deve ser > 0.');
                    return;
                }
                
                // Obter ClasterOrb selecionada
                const select = document.getElementById('captureOrbSelect');
                if (!select) {
                    alert('âŒ Erro ao ler seleÃ§Ã£o de ClasterOrb.');
                    return;
                }
                
                const selectedOrbId = select.value;
                const orbInfo = CLASTERORBS[selectedOrbId];
                if (!orbInfo) {
                    alert('âŒ ClasterOrb invÃ¡lida.');
                    return;
                }
                
                // ValidaÃ§Ã£o: precisa ter a orb selecionada
                player.inventory = player.inventory || {};
                const orbCount = player.inventory[selectedOrbId] || 0;
                
                if (orbCount <= 0) {
                    alert(`âŒ VocÃª nÃ£o tem ${orbInfo.name}!`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // SEMPRE CONSOME 1 item (mesmo se falhar)
                player.inventory[selectedOrbId]--;
                encounter.log.push(`${orbInfo.emoji} ${player.name} usou ${orbInfo.name}! (Restam: ${player.inventory[selectedOrbId]})`);
                
                // Calcular threshold de captura
                const hpPercent = monster.hp / monster.hpMax;
                const baseThreshold = GameState.config?.captureThreshold?.[monster.rarity] || 0.35;
                
                // BÃ´nus se HP <= 25%
                let lowHpBonus = 0;
                if (hpPercent <= 0.25) {
                    lowHpBonus = 0.10;
                    encounter.log.push(`âœ¨ HP crÃ­tico! BÃ´nus de +10% na captura!`);
                }
                
                // BÃ´nus da orb (em decimal: 0, 0.05, 0.10)
                const orbBonus = orbInfo.capture_bonus_pp / 100;
                
                const thresholdFinal = Math.min(0.95, baseThreshold + orbBonus + lowHpBonus);
                
                encounter.log.push(`HP: ${Math.floor(hpPercent * 100)}% | Base: ${Math.floor(baseThreshold * 100)}% | Orb: +${orbInfo.capture_bonus_pp}% | HP Bonus: +${Math.floor(lowHpBonus * 100)}%`);
                encounter.log.push(`ğŸ¯ Threshold Final: ${Math.floor(thresholdFinal * 100)}%`);
                
                // Captura determinÃ­stica: sucesso se HP% <= Threshold_final
                if (hpPercent <= thresholdFinal) {
                    encounter.log.push(`âœ… SUCESSO! ${monster.name} foi capturado!`);
                    
                    // Feature 4.4: Capture success sound
                    Audio.playSfx("capture_ok");
                    
                    monster.ownerId = player.id;
                    
                    player.team = player.team || [];
                    player.box = player.box || [];
                    
                    if (player.team.length < (GameState.config?.maxTeamSize || 6)) {
                        player.team.push(monster);
                        encounter.log.push(`${monster.name} foi adicionado ao time de ${player.name}!`);
                    } else {
                        player.box.push(monster);
                        encounter.log.push(`${monster.name} foi enviado para a caixa de ${player.name}!`);
                    }
                    
                    GameState.monsters = GameState.monsters || [];
                    GameState.monsters.push(monster);
                    
                    // Feature 4.2: Tutorial hook
                    tutorialOnAction("capture");
                    
                    encounter.active = false;
                    GameState.currentEncounter = null;
                } else {
                    // FALHA: Monstrinho realiza 1 ataque bÃ¡sico IMEDIATO
                    encounter.log.push(`âŒ FALHA! ${monster.name} quebrou livre!`);
                    
                    // Feature 4.4: Capture fail sound
                    Audio.playSfx("capture_fail");
                    
                    const playerMonster = player.team?.[0];
                    if (playerMonster && playerMonster.hp > 0) {
                        encounter.log.push(`âš¡ ${monster.name} contra-ataca!`);
                        
                        // Monstrinho selvagem ataca imediatamente
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, monster, playerMonster));
                        encounter.log.push(`ğŸ² ${monster.name} rola ${enemyRoll} (ATK: ${monster.atk})`);
                        
                        // Feature 4.4: Enemy counter-attack sound (wild - after failed capture)
                        const enemyIsCrit = (enemyRoll === 20);
                        const enemyIsFail = (enemyRoll === 1);
                        if (enemyIsCrit) {
                            Audio.playSfx("crit");
                        } else if (enemyIsFail || !enemyHit) {
                            Audio.playSfx("miss");
                        } else {
                            Audio.playSfx("hit");
                        }
                        
                        if (enemyHit) {
                            const damage = calculateDamage(monster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${monster.name} acerta! Causa ${damage} de dano!`);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                        } else {
                            encounter.log.push(`âŒ ${monster.name} erra o ataque!`);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Capture attempt failed', error.stack);
            }
        }

        // Feature 3.1: Usar Item em Batalha
        function useItemInBattle(itemId) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('Nenhum jogador selecionado para este encontro');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Jogador nÃ£o tem monstrinhos no time');
                    return;
                }
                
                // VALIDAÃ‡Ã•ES (GAME_RULES.md)
                
                // 1. Validar HP > 0 (monstrinho nÃ£o desmaiado)
                if (playerMonster.hp <= 0) {
                    alert('âŒ NÃ£o pode usar item! Monstrinho estÃ¡ desmaiado (HP = 0).');
                    return;
                }
                
                // 2. Validar HP < HPMax (nÃ£o usar se jÃ¡ estÃ¡ cheio)
                if (playerMonster.hp >= playerMonster.hpMax) {
                    alert('âš ï¸ HP jÃ¡ estÃ¡ no mÃ¡ximo! NÃ£o Ã© necessÃ¡rio usar item de cura.');
                    return;
                }
                
                // 3. Validar item disponÃ­vel no inventÃ¡rio
                player.inventory = player.inventory || {};
                const itemCount = player.inventory[itemId] || 0;
                
                if (itemCount <= 0) {
                    alert('âŒ VocÃª nÃ£o tem Petisco de Cura disponÃ­vel!');
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // CONSUMIR 1 unidade do item
                player.inventory[itemId]--;
                encounter.log.push(`ğŸ’š ${player.name} usou Petisco de Cura! (Restam: ${player.inventory[itemId]})`);
                
                // APLICAR CURA
                // Petisco de Cura: restaura 30 HP ou 30% do HP mÃ¡ximo (o que for maior)
                const healAmount = Math.max(30, Math.floor(playerMonster.hpMax * 0.30));
                const hpBefore = playerMonster.hp;
                playerMonster.hp = Math.min(playerMonster.hpMax, playerMonster.hp + healAmount);
                const actualHeal = playerMonster.hp - hpBefore;
                
                encounter.log.push(`âœ¨ ${playerMonster.name} recuperou ${actualHeal} HP! (${playerMonster.hp}/${playerMonster.hpMax})`);
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("item");
                
                // Feature 4.4: Heal sound
                Audio.playSfx("heal");
                
                // SALVAR ESTADO
                saveToLocalStorage();
                renderEncounter();
                
                // Feature 3.8: Visual feedback for healing
                setTimeout(() => {
                    showFloatingText('wildPlayerBox', `+${actualHeal}`, 'heal');
                }, 50);
                
                // INIMIGO ATACA (contra-ataque automÃ¡tico apÃ³s usar item)
                if (encounter.wildMonster.hp > 0) {
                    encounter.log.push(`âš”ï¸ Vez do inimigo...`);
                    
                    const wildMonster = encounter.wildMonster;
                    
                    // Aplicar ENE regen do inimigo
                    applyEneRegen(wildMonster, encounter);
                    
                    // Atualizar buffs do inimigo
                    updateBuffs(wildMonster);
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const wildSkills = getMonsterSkills(wildMonster);
                    const canUseSkill = wildSkills && wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                    const shouldUseSkill = canUseSkill && Math.random() < 0.5;
                    
                    if (shouldUseSkill) {
                        const skill = wildSkills[0];
                        wildMonster.ene -= skill.cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${skill.name}! (-${skill.cost} ENE)`);
                        
                        // Usar habilidade
                        useSkill(wildMonster, skill, playerMonster, encounter);
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        const enemyHit = enemyRoll === 1 ? false : (enemyRoll === 20 ? true : checkHit(enemyRoll, wildMonster, playerMonster));
                        
                        // Feature 4.4: Enemy counter-attack sound (wild - after item)
                        const enemyIsCrit = (enemyRoll === 20);
                        const enemyIsFail = (enemyRoll === 1);
                        if (enemyIsCrit) {
                            Audio.playSfx("crit");
                        } else if (enemyIsFail || !enemyHit) {
                            Audio.playSfx("miss");
                        } else {
                            Audio.playSfx("hit");
                        }
                        
                        if (enemyHit) {
                            const power = BASIC_ATTACK_POWER[wildMonster.class] || 12;
                            
                            const atkMods = getBuffModifiers(wildMonster);
                            const effectiveAtk = Math.max(1, wildMonster.atk + atkMods.atk);
                            
                            const defMods = getBuffModifiers(playerMonster);
                            const effectiveDef = Math.max(1, playerMonster.def + defMods.def);
                            
                            const classAdv = GameState.config?.classAdvantages?.[wildMonster.class];
                            let damageMult = 1.0;
                            if (classAdv?.strong === playerMonster.class) {
                                damageMult = 1.10;
                            } else if (classAdv?.weak === playerMonster.class) {
                                damageMult = 0.90;
                            }
                            
                            const damage = calcDamage({
                                atk: effectiveAtk,
                                def: effectiveDef,
                                power: power,
                                damageMult: damageMult
                            });
                            
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Verificar se jogador perdeu
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ’€ ${playerMonster.name} fainted! Defeat!`);
                                
                                // Feature 4.4: Defeat sound (com idempotÃªncia)
                                if (!encounter._loseSfxPlayed) {
                                    Audio.playSfx("lose");
                                    encounter._loseSfxPlayed = true;
                                }
                                
                                encounter.active = false;
                                GameState.currentEncounter = null;
                                saveToLocalStorage();
                                renderEncounter();
                                return;
                            }
                        } else {
                            if (enemyRoll === 1) {
                                encounter.log.push(`ğŸ’€ FALHA CRÃTICA! ${wildMonster.name} erra!`);
                            } else {
                                encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                            }
                        }
                    }
                }
                
                // RENDER atualizado
                saveToLocalStorage();
                renderEncounter();
                
            } catch (error) {
                showError('Failed to use item in battle', error.stack);
            }
        }

        function attackWild() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) {
                    alert('No player selected for this encounter');
                    return;
                }
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('Player has no monsters in team');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho Ã© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`âš ï¸ VocÃª sÃ³ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} Ã© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Get dice roll from input field
                const diceInput = document.getElementById('diceRoll');
                const playerRoll = parseInt(diceInput?.value || '0');
                
                if (playerRoll < 1 || playerRoll > 20) {
                    alert('Please enter a valid roll between 1 and 20');
                    return;
                }
                
                // Clear the input for next roll
                if (diceInput) diceInput.value = '';
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno do jogador
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs (reduzir duraÃ§Ã£o)
                updateBuffs(playerMonster);
                
                // CRIT 20 ou FALHA 1 (GAME_RULES.md)
                let isCrit20 = false;
                let isFail1 = false;
                let critBonus = null;
                
                if (playerRoll === 20) {
                    isCrit20 = true;
                    encounter.log.push(`â­ CRÃTICO 20! â­`);
                    // Escolher bÃ´nus aleatÃ³rio
                    const bonusRoll = Math.floor(Math.random() * 3);
                    if (bonusRoll === 0) {
                        critBonus = 'double_power';
                        encounter.log.push(`ğŸ’¥ Poder dobrado neste ataque!`);
                    } else if (bonusRoll === 1) {
                        critBonus = 'item';
                        player.inventory = player.inventory || {};
                        player.inventory['IT_HEAL_01'] = (player.inventory['IT_HEAL_01'] || 0) + 1;
                        encounter.log.push(`ğŸ Ganhou 1 Petisco de Cura!`);
                    } else {
                        critBonus = 'money';
                        const moneyGain = 20 + Math.floor(Math.random() * 31); // 20-50
                        player.money = (player.money || 0) + moneyGain;
                        encounter.log.push(`ğŸ’° Ganhou ${moneyGain} moedas!`);
                    }
                } else if (playerRoll === 1) {
                    isFail1 = true;
                }
                
                // Fase 1: Ataque do jogador
                encounter.log.push(`ğŸ² ${player.name}'s ${playerMonster.name} rolls ${playerRoll} (ATK: ${playerMonster.atk})`);
                
                // Feature 3.8: Record d20 roll
                const rollType = isCrit20 ? 'crit' : isFail1 ? 'fail' : 'normal';
                recordD20Roll(encounter, player.name, playerRoll, rollType);
                
                // d20=1 sempre erra, d20=20 sempre acerta
                const playerHit = isFail1 ? false : (isCrit20 ? true : checkHit(playerRoll, playerMonster, encounter.wildMonster));
                
                // Feature 4.4: Play attack sound
                if (isCrit20) {
                    Audio.playSfx("crit");
                } else if (isFail1 || !playerHit) {
                    Audio.playSfx("miss");
                } else {
                    Audio.playSfx("hit");
                }
                
                if (playerHit) {
                    // Calcular dano com power modificado se CRIT 20
                    let power = BASIC_ATTACK_POWER[playerMonster.class] || 12;
                    if (isCrit20 && critBonus === 'double_power') {
                        power *= 2; // Dobrar POWER antes do cÃ¡lculo
                    }
                    
                    // Calcular dano com nova fÃ³rmula
                    const atkMods = getBuffModifiers(playerMonster);
                    const effectiveAtk = Math.max(1, playerMonster.atk + atkMods.atk);
                    
                    const defMods = getBuffModifiers(encounter.wildMonster);
                    const effectiveDef = Math.max(1, encounter.wildMonster.def + defMods.def);
                    
                    const classAdv = GameState.config?.classAdvantages?.[playerMonster.class];
                    let damageMult = 1.0;
                    if (classAdv?.strong === encounter.wildMonster.class) {
                        damageMult = 1.10;
                    } else if (classAdv?.weak === encounter.wildMonster.class) {
                        damageMult = 0.90;
                    }
                    
                    const damage = calcDamage({
                        atk: effectiveAtk,
                        def: effectiveDef,
                        power: power,
                        damageMult: damageMult
                    });
                    
                    encounter.wildMonster.hp = Math.max(0, encounter.wildMonster.hp - damage);
                    encounter.log.push(`ğŸ’¥ ${playerMonster.name} hits! Deals ${damage} damage!`);
                    
                    // Feature 4.2: Tutorial hook
                    tutorialOnAction("attack");
                    
                    // Feature 3.8: Visual feedback
                    saveToLocalStorage();
                    renderEncounter();
                    setTimeout(() => {
                        showFloatingText('wildEnemyBox', `-${damage}`, isCrit20 ? 'crit' : 'damage');
                        flashTarget('wildEnemyBox', isCrit20 ? 'crit' : 'hit');
                    }, 50);
                    
                    if (encounter.wildMonster.hp <= 0) {
                        encounter.log.push(`ğŸ† ${encounter.wildMonster.name} fainted! Victory!`);
                        
                        // Feature 4.4: Victory sound (com idempotÃªncia)
                        if (!encounter._winSfxPlayed) {
                            Audio.playSfx("win");
                            encounter._winSfxPlayed = true;
                        }
                        
                        // Feature 3.3: Distribuir recompensas (XP) com idempotÃªncia
                        handleVictoryRewards(encounter);
                        
                        encounter.active = false;
                        GameState.currentEncounter = null;
                        saveToLocalStorage();
                        renderEncounter();
                        return;
                    }
                } else {
                    if (isFail1) {
                        encounter.log.push(`ğŸ’€ FALHA CRÃTICA! Ataque erra automaticamente!`);
                    } else {
                        encounter.log.push(`âŒ ${playerMonster.name} misses!`);
                    }
                    
                    // Feature 3.8: Flash fail on player
                    saveToLocalStorage();
                    renderEncounter();
                    setTimeout(() => flashTarget('wildPlayerBox', 'fail'), 50);
                }
                
                // Fase 2: Contra-ataque do monstrinho selvagem (se ainda vivo)
                if (encounter.wildMonster.hp > 0) {
                    const wildMonster = encounter.wildMonster;
                    const wildSkill = wildMonster.skill;
                    
                    // IA: 50% chance de usar habilidade se tiver ENE
                    const useSkill = wildSkill && (wildMonster.ene || 0) >= wildSkill.energy_cost && Math.random() < 0.5;
                    
                    if (useSkill) {
                        wildMonster.ene -= wildSkill.energy_cost;
                        encounter.log.push(`âœ¨ ${wildMonster.name} usa ${wildSkill.name}! (-${wildSkill.energy_cost} ENE)`);
                        
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² ${wildMonster.name} rolls ${enemyRoll}`);
                        
                        // Feature 3.8: Record enemy d20 roll
                        const enemyRollType = enemyRoll === 20 ? 'crit' : enemyRoll === 1 ? 'fail' : 'normal';
                        recordD20Roll(encounter, wildMonster.name, enemyRoll, enemyRollType);
                        
                        if (enemyHit) {
                            const baseDamage = wildMonster.atk + wildSkill.power - playerMonster.def;
                            const damage = Math.max(1, baseDamage);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildSkill.name} acerta! Causa ${damage} de dano!`);
                            
                            // Feature 3.8: Visual feedback
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => {
                                showFloatingText('wildPlayerBox', `-${damage}`, enemyRoll === 20 ? 'crit' : 'damage');
                                flashTarget('wildPlayerBox', enemyRoll === 20 ? 'crit' : 'hit');
                            }, 50);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                            return;
                        } else {
                            encounter.log.push(`âŒ ${wildSkill.name} erra!`);
                            
                            // Feature 3.8: Flash fail on enemy
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => flashTarget('wildEnemyBox', 'fail'), 50);
                        }
                    } else {
                        // Ataque bÃ¡sico
                        const enemyRoll = Math.floor(Math.random() * 20) + 1;
                        const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                        encounter.log.push(`ğŸ² Wild ${wildMonster.name} rolls ${enemyRoll} (ATK: ${wildMonster.atk})`);
                        
                        // Feature 3.8: Record enemy d20 roll
                        const enemyRollType = enemyRoll === 20 ? 'crit' : enemyRoll === 1 ? 'fail' : 'normal';
                        recordD20Roll(encounter, wildMonster.name, enemyRoll, enemyRollType);
                        
                        if (enemyHit) {
                            const damage = calculateDamage(wildMonster, playerMonster);
                            playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                            encounter.log.push(`ğŸ’¥ ${wildMonster.name} hits! Deals ${damage} damage!`);
                            
                            // Feature 3.8: Visual feedback
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => {
                                showFloatingText('wildPlayerBox', `-${damage}`, enemyRoll === 20 ? 'crit' : 'damage');
                                flashTarget('wildPlayerBox', enemyRoll === 20 ? 'crit' : 'hit');
                            }, 50);
                            
                            if (playerMonster.hp <= 0) {
                                encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                                playerMonster.status = 'fainted';
                                encounter.active = false;
                                GameState.currentEncounter = null;
                            }
                            return;
                        } else {
                            encounter.log.push(`âŒ ${wildMonster.name} misses!`);
                            
                            // Feature 3.8: Flash fail on enemy
                            saveToLocalStorage();
                            renderEncounter();
                            setTimeout(() => flashTarget('wildEnemyBox', 'fail'), 50);
                        }
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Attack failed', error.stack);
            }
        }

        // Usar habilidade contra o selvagem (por Ã­ndice 0, 1, 2)
        function useSkillWild(skillIndex) {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter?.wildMonster) return;
                
                const playerId = encounter.selectedPlayerId;
                const player = GameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const playerMonster = player.team?.[0];
                if (!playerMonster) {
                    alert('No monster available');
                    return;
                }
                
                // GAME_RULES.md: Validar que monstrinho Ã© da mesma classe do jogador
                if (playerMonster.class !== player.class) {
                    alert(`âš ï¸ VocÃª sÃ³ pode usar monstrinhos da classe ${player.class} em batalha!\n\nEste ${playerMonster.name} Ã© da classe ${playerMonster.class}.\nTroque-o por um monstrinho da sua classe.`);
                    return;
                }
                
                // Obter habilidades disponÃ­veis
                const skills = getMonsterSkills(playerMonster);
                if (!skills || skillIndex >= skills.length || !skills[skillIndex]) {
                    alert('Skill not available');
                    return;
                }
                
                const skill = skills[skillIndex];
                
                // Validar ENE suficiente
                if ((playerMonster.ene || 0) < skill.cost) {
                    alert(`âŒ ENE insuficiente! Precisa de ${skill.cost} ENE.`);
                    return;
                }
                
                encounter.log = encounter.log || [];
                
                // ENE REGEN no inÃ­cio do turno
                applyEneRegen(playerMonster, encounter);
                
                // Atualizar buffs
                updateBuffs(playerMonster);
                
                // Usar habilidade
                const success = useSkill(playerMonster, skill, encounter.wildMonster, encounter);
                
                if (!success) {
                    alert('Failed to use skill');
                    return;
                }
                
                // Feature 4.2: Tutorial hook
                tutorialOnAction("skill");
                
                // Verificar se o selvagem foi derrotado
                if (encounter.wildMonster.hp <= 0) {
                    encounter.log.push(`ğŸ† ${encounter.wildMonster.name} foi derrotado!`);
                    const xpGained = calculateBattleXP(encounter.wildMonster);
                    giveXP(playerMonster, xpGained, encounter.log);
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    saveToLocalStorage();
                    renderEncounter();
                    return;
                }
                
                // Fase 2: Contra-ataque do selvagem
                const wildMonster = encounter.wildMonster;
                
                // Atualizar buffs do selvagem
                updateBuffs(wildMonster);
                
                // IA: 50% chance de usar habilidade se tiver ENE
                const wildSkills = getMonsterSkills(wildMonster);
                const canUseSkill = wildSkills.length > 0 && (wildMonster.ene || 0) >= wildSkills[0].cost;
                const useWildSkill = canUseSkill && Math.random() < 0.5;
                
                if (useWildSkill) {
                    // Selvagem usa habilidade
                    useSkill(wildMonster, wildSkills[0], playerMonster, encounter);
                    
                    if (playerMonster.hp <= 0) {
                        encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                        playerMonster.status = 'fainted';
                        encounter.active = false;
                        GameState.currentEncounter = null;
                    }
                } else {
                    // Ataque bÃ¡sico do selvagem
                    const enemyRoll = Math.floor(Math.random() * 20) + 1;
                    const enemyHit = checkHit(enemyRoll, wildMonster, playerMonster);
                    encounter.log.push(`ğŸ² ${wildMonster.name} rola ${enemyRoll} (ATK: ${wildMonster.atk})`);
                    
                    if (enemyHit) {
                        const mods = getBuffModifiers(wildMonster);
                        const effectiveAtk = wildMonster.atk + mods.atk;
                        const damage = calculateDamage(wildMonster, playerMonster);
                        playerMonster.hp = Math.max(0, playerMonster.hp - damage);
                        encounter.log.push(`ğŸ’¥ ${wildMonster.name} acerta! Causa ${damage} de dano!`);
                        
                        if (playerMonster.hp <= 0) {
                            encounter.log.push(`ğŸ˜µ ${playerMonster.name} desmaiou!`);
                            playerMonster.status = 'fainted';
                            encounter.active = false;
                            GameState.currentEncounter = null;
                        }
                    } else {
                        encounter.log.push(`âŒ ${wildMonster.name} erra!`);
                    }
                }
                
                saveToLocalStorage();
                renderEncounter();
            } catch (error) {
                showError('Skill use failed', error.stack);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SISTEMA DE DANO - FÃ³rmulas Oficiais (GAME_RULES.md)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Verifica se um ataque acerta o alvo
         * FÃ“RMULA: d20 + ATK + ClassBonus >= DEF
         * 
         * @param {number} d20Roll - Resultado do dado d20 (1-20)
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {boolean} true se acertou, false se errou
         * 
         * VANTAGEM DE CLASSE (Acerto):
         * - Vantagem: +2 ATK
         * - Desvantagem: -2 ATK
         * 
         * REGRAS ESPECIAIS:
         * - d20 = 1: sempre erra (falha crÃ­tica)
         * - d20 = 20: sempre acerta (acerto crÃ­tico)
         */
        function checkHit(d20Roll, attacker, defender) {
            try {
                if (!attacker || !defender) return false;
                
                const atkMod = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // Vantagem de classe: +2 ATK se forte, -2 ATK se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let atkBonus = 0;
                if (classAdv?.strong === defender.class) {
                    atkBonus = 2;
                } else if (classAdv?.weak === defender.class) {
                    atkBonus = -2;
                }
                
                const totalAtk = d20Roll + atkMod + atkBonus;
                return totalAtk >= defValue;
            } catch (error) {
                console.error('Hit check failed:', error);
                return false;
            }
        }

        /**
         * Calcula dano de um ataque
         * FÃ“RMULA BASE: floor(POWER * (ATK / (ATK + DEF))) * damageMult
         * DANO MÃNIMO: sempre 1
         * 
         * @param {object} params - ParÃ¢metros de dano
         * @param {number} params.atk - Ataque efetivo (com buffs)
         * @param {number} params.def - Defesa efetiva (com buffs)
         * @param {number} params.power - Poder da habilidade/ataque
         * @param {number} params.damageMult - Multiplicador (1.0 padrÃ£o, 1.10 vantagem, 0.90 desvantagem)
         * @returns {number} Dano final (mÃ­nimo 1)
         * 
         * VANTAGEM DE CLASSE (Dano):
         * - Vantagem: 1.10 (110% do dano base)
         * - Desvantagem: 0.90 (90% do dano base)
         * - Neutro: 1.0 (100% do dano base)
         * 
         * EXEMPLO:
         * ATK=10, DEF=5, POWER=15
         * ratio = 10/(10+5) = 0.666
         * baseD = floor(15 * 0.666) = floor(9.99) = 9
         * finalD = floor(9 * 1.0) = 9
         */
        function calcDamage({ atk, def, power, damageMult = 1.0 }) {
            try {
                // ratio = ATK / (ATK + DEF)
                const ratio = atk / (atk + def);
                
                // danoBase = floor(POWER * ratio)
                const baseD = Math.floor(power * ratio);
                
                // Aplicar multiplicador de classe
                const finalD = Math.floor(baseD * damageMult);
                
                // Dano mÃ­nimo sempre 1
                return Math.max(1, finalD);
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        /**
         * Wrapper de compatibilidade - calcula dano com ataque bÃ¡sico
         * Aplica automaticamente buffs e vantagens de classe
         * 
         * @param {object} attacker - Monstrinho atacante
         * @param {object} defender - Monstrinho defensor
         * @returns {number} Dano final
         * 
         * FLUXO:
         * 1. ObtÃ©m stats base (atk, def)
         * 2. Aplica modificadores de buffs
         * 3. ObtÃ©m POWER bÃ¡sico da classe
         * 4. Calcula multiplicador de classe
         * 5. Chama calcDamage() com todos os parÃ¢metros
         */
        function calculateDamage(attacker, defender) {
            try {
                if (!attacker || !defender) return 1;
                
                const atkValue = attacker.atk || 5;
                const defValue = defender.def || 3;
                
                // POWER bÃ¡sico por classe
                const basicPower = BASIC_ATTACK_POWER[attacker.class] || 12;
                
                // Aplicar modificadores de buff
                const atkMods = getBuffModifiers(attacker);
                const effectiveAtk = Math.max(1, atkValue + atkMods.atk);
                
                const defMods = getBuffModifiers(defender);
                const effectiveDef = Math.max(1, defValue + defMods.def);
                
                // Vantagem de classe: +10% dano se forte, -10% dano se fraco
                const classAdv = GameState.config?.classAdvantages?.[attacker.class];
                let damageMult = 1.0;
                if (classAdv?.strong === defender.class) {
                    damageMult = 1.10;
                } else if (classAdv?.weak === defender.class) {
                    damageMult = 0.90;
                }
                
                return calcDamage({
                    atk: effectiveAtk,
                    def: effectiveDef,
                    power: basicPower,
                    damageMult: damageMult
                });
            } catch (error) {
                console.error('Damage calculation failed:', error);
                return 1;
            }
        }

        function fleeEncounter() {
            try {
                const encounter = GameState.currentEncounter;
                if (!encounter) return;
                
                if (confirm('Flee from this encounter?')) {
                    encounter.log = encounter.log || [];
                    encounter.log.push('ğŸƒ Fled from encounter');
                    encounter.active = false;
                    GameState.currentEncounter = null;
                    
                    saveToLocalStorage();
                    renderEncounter();
                }
            } catch (error) {
                showError('Flee failed', error.stack);
            }
        }

        function getCurrentPlayer() {
            try {
                if (!GameState.currentSession) return null;
                
                const turnIndex = GameState.currentSession.currentTurnIndex || 0;
                const playerId = GameState.currentSession.turnOrder?.[turnIndex];
                
                return GameState.players?.find(p => p?.id === playerId) || null;
            } catch (error) {
                console.error('Failed to get current player:', error);
                return null;
            }
        }

        // THERAPY MANAGEMENT
        function addObjective() {
            try {
                const text = document.getElementById('newObjective')?.value?.trim();
                const weight = parseInt(document.getElementById('objectiveWeight')?.value || '1');
                
                if (!text) {
                    alert('Please enter objective description');
                    return;
                }
                
                const objective = {
                    id: Date.now(),
                    text: text,
                    weight: weight
                };
                
                GameState.objectives = GameState.objectives || [];
                GameState.objectives.push(objective);
                
                document.getElementById('newObjective').value = '';
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to add objective', error.stack);
            }
        }

        function toggleObjectiveForPlayer(playerId, objectiveId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                therapy.completedObjectives = therapy.completedObjectives || [];
                
                const index = therapy.completedObjectives.indexOf(objectiveId);
                if (index > -1) {
                    therapy.completedObjectives.splice(index, 1);
                } else {
                    therapy.completedObjectives.push(objectiveId);
                }
                
                therapy.pm = 0;
                therapy.completedObjectives.forEach(objId => {
                    const obj = GameState.objectives?.find(o => o?.id === objId);
                    if (obj) {
                        therapy.pm += obj.weight || 0;
                    }
                });
                
                updateMedals(playerId);
                
                saveToLocalStorage();
                updateAllViews();
            } catch (error) {
                showError('Failed to toggle objective', error.stack);
            }
        }

        function updateMedals(playerId) {
            try {
                if (!GameState.currentSession) return;
                
                const therapy = GameState.currentSession.therapy?.perPlayer?.[playerId];
                if (!therapy) return;
                
                const pm = therapy.pm || 0;
                const tiers = GameState.config?.medalTiers || { bronze: 10, silver: 25, gold: 50 };
                
                therapy.medals = therapy.medals || [];
                
                if (pm >= tiers.gold && !therapy.medals.includes('gold')) {
                    therapy.medals.push('gold');
                } else if (pm >= tiers.silver && !therapy.medals.includes('silver')) {
                    therapy.medals.push('silver');
                } else if (pm >= tiers.bronze && !therapy.medals.includes('bronze')) {
                    therapy.medals.push('bronze');
                }
            } catch (error) {
                console.error('Failed to update medals:', error);
            }
        }

        // UI UPDATE FUNCTIONS
        function updateAllViews() {
            try {
                updateHomeStats();
                updatePlayersList();
                updateSessionView();
                updateTherapyView();
                updateReportView();
                updateEncounterPlayerDropdown();
                updateEncounterUI();
                renderEncounter();
            } catch (error) {
                console.error('Failed to update views:', error);
            }
        }

        function updateEncounterPlayerDropdown() {
            try {
                const select = document.getElementById('encounterPlayer');
                if (!select) return;
                
                select.innerHTML = '<option value="">-- Select Player --</option>';
                
                if (GameState.players && GameState.players.length > 0) {
                    GameState.players.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.name} (${player.class || 'No class'})`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to update encounter player dropdown:', error);
            }
        }
        
        function updateEncounterUI() {
            try {
                const type = document.getElementById('encounterType')?.value;
                const playerSelectDiv = document.getElementById('playerSelectDiv');
                const groupSelectDiv = document.getElementById('groupSelectDiv');
                
                if (!playerSelectDiv || !groupSelectDiv) return;
                
                if (type === 'wild') {
                    playerSelectDiv.classList.remove('hidden');
                    groupSelectDiv.classList.add('hidden');
                } else if (type === 'trainer' || type === 'boss') {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.remove('hidden');
                    updateGroupParticipantsList();
                } else {
                    playerSelectDiv.classList.add('hidden');
                    groupSelectDiv.classList.add('hidden');
                }
            } catch (error) {
                console.error('Failed to update encounter UI:', error);
            }
        }
        
        function updateGroupParticipantsList() {
            try {
                const container = document.getElementById('groupParticipantsList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p style="color: #666;">No players available. Add players first.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    // Initialize activeIndex if not set
                    if (typeof player.activeIndex !== 'number') {
                        player.activeIndex = firstAliveIndex(player.team);
                    }
                    
                    const mon = _getActiveMonsterOfPlayer(player);
                    const monName = mon ? (mon.name || mon.nome || 'No monster') : 'No monster';
                    const hasValidMonster = mon && mon.hp > 0;
                    
                    html += `<div style="padding: 5px;">`;
                    html += `<label style="cursor: pointer; display: flex; align-items: center;">`;
                    html += `<input type="checkbox" name="groupParticipant" value="${player.id}" ${!hasValidMonster ? 'disabled' : ''}>`;
                    html += `<span style="margin-left: 8px;">${player.name} (${player.class})`;
                    if (hasValidMonster) {
                        html += ` - ${monName} Nv${mon.level}`;
                    } else {
                        html += ` - <span style="color: #999;">No valid monster</span>`;
                    }
                    html += `</span>`;
                    html += `</label>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
                
                // Also update team reorder UI
                updateTeamReorderUI();
            } catch (error) {
                console.error('Failed to update group participants list:', error);
            }
        }

        function updateTeamReorderUI() {
            try {
                const container = document.getElementById('teamReorderContainer');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<p style="color: #666;">No players available.</p>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player || !Array.isArray(player.team) || player.team.length === 0) return;
                    
                    html += `<div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background: white;">`;
                    html += `<strong>${player.name || player.nome}</strong> (${player.class})<br>`;
                    html += `<small style="color: #666;">PosiÃ§Ã£o 0 = LÃ­der (primeiro a lutar se vivo)</small>`;
                    html += `<div style="margin-top: 8px;">`;
                    
                    player.team.forEach((monster, idx) => {
                        if (!monster) return;
                        
                        const isAlive = _isAlive(monster);
                        const hpPercent = Math.floor((monster.hp / monster.hpMax) * 100);
                        const isActive = idx === player.activeIndex;
                        
                        html += `<div style="display: flex; align-items: center; padding: 5px; margin: 3px 0; background: ${isActive ? '#e8f5e9' : '#fafafa'}; border: ${isActive ? '2px solid #4CAF50' : '1px solid #ddd'}; border-radius: 4px;">`;
                        html += `<span style="font-weight: bold; margin-right: 8px;">${idx}</span>`;
                        html += `<div style="flex: 1;">`;
                        html += `${monster.emoji || ''} ${monster.name || monster.nome} - Nv${monster.level}`;
                        html += `<br><small>HP: ${monster.hp}/${monster.hpMax} (${hpPercent}%)`;
                        if (!isAlive) html += ` <strong style="color: red;">ğŸ’€ DESMAIADO</strong>`;
                        if (isActive) html += ` <strong style="color: green;">âš¡ ATIVO</strong>`;
                        html += `</small>`;
                        html += `</div>`;
                        html += `<div style="display: flex; flex-direction: column; gap: 2px;">`;
                        if (idx > 0) {
                            html += `<button onclick="movePlayerTeamMember('${player.id}', ${idx}, ${idx - 1})" style="padding: 2px 8px; font-size: 12px;">â¬†ï¸</button>`;
                        }
                        if (idx < player.team.length - 1) {
                            html += `<button onclick="movePlayerTeamMember('${player.id}', ${idx}, ${idx + 1})" style="padding: 2px 8px; font-size: 12px;">â¬‡ï¸</button>`;
                        }
                        html += `</div>`;
                        html += `</div>`;
                    });
                    
                    html += `</div>`;
                    html += `</div>`;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update team reorder UI:', error);
            }
        }

        function movePlayerTeamMember(playerId, fromIdx, toIdx) {
            try {
                const player = _getPlayerById(playerId);
                if (!player) return;
                
                moveTeamMember(player, fromIdx, toIdx);
                updateTeamReorderUI();
                updateGroupParticipantsList();
            } catch (error) {
                showError('Failed to move team member', error.stack);
            }
        }

        function updateHomeStats() {
            try {
                const statPlayers = document.getElementById('statPlayers');
                const statMonsters = document.getElementById('statMonsters');
                const statSession = document.getElementById('statSession');
                
                if (statPlayers) statPlayers.textContent = GameState.players?.length || 0;
                if (statMonsters) statMonsters.textContent = GameState.monsters?.length || 0;
                if (statSession) statSession.textContent = GameState.currentSession ? 'Yes' : 'No';
            } catch (error) {
                console.error('Failed to update home stats:', error);
            }
        }

        function updatePlayersList() {
            try {
                const container = document.getElementById('playersList');
                if (!container) return;
                
                if (!GameState.players || GameState.players.length === 0) {
                    container.innerHTML = '<div class="card"><p>No players yet. Add one above!</p></div>';
                    return;
                }
                
                let html = '';
                GameState.players.forEach(player => {
                    if (!player) return;
                    
                    const teamCount = player.team?.length || 0;
                    const boxCount = player.box?.length || 0;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <div class="badge badge-${player.playerClassId}">${player.playerClassId}</div>
                            <p>ğŸ’° Money: ${player.money || 0} | â­ Afterlife: ${player.afterlifeCurrency || 0}</p>
                            <p>ğŸ‘¥ Team: ${teamCount}/${GameState.config?.maxTeamSize || 6} | ğŸ“¦ Box: ${boxCount}</p>
                            
                            <h4>Team:</h4>
                            <div class="flex">
                                ${(player.team || []).map(m => renderMonsterCard(m)).join('')}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update players list:', error);
            }
        }

        function renderMonsterCard(monster) {
            try {
                if (!monster) return '';
                
                const hpPercent = ((monster.hp || 0) / (monster.hpMax || 1)) * 100;
                const xpNeeded = (monster.level || 1) * 100;
                const xpPercent = ((monster.xp || 0) / xpNeeded) * 100;
                
                return `
                    <div class="monster-card ${monster.class || 'common'}">
                        <div style="font-size: 36px;">${monster.emoji || 'ğŸ”®'}</div>
                        <strong>${monster.name || 'Unknown'}</strong>
                        <div class="badge badge-${monster.rarity || 'common'}">${monster.rarity || 'common'}</div>
                        <div>Lv ${monster.level || 1}</div>
                        <div class="progress-bar" style="height: 20px;">
                            <div class="progress-fill hp" style="width: ${hpPercent}%"></div>
                        </div>
                        <small>${monster.hp || 0}/${monster.hpMax || 0} HP</small>
                        <div class="progress-bar" style="height: 15px;">
                            <div class="progress-fill xp" style="width: ${xpPercent}%"></div>
                        </div>
                        <small>${monster.xp || 0}/${xpNeeded} XP</small>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to render monster card:', error);
                return '<div class="monster-card">Error</div>';
            }
        }

        function updateSessionView() {
            try {
                const panel = document.getElementById('activeSessionPanel');
                if (!panel) return;
                
                if (!GameState.currentSession) {
                    panel.classList.add('hidden');
                    return;
                }
                
                panel.classList.remove('hidden');
                
                const session = GameState.currentSession;
                document.getElementById('activeSessionName').textContent = session.name || 'Unnamed';
                document.getElementById('sessionCreated').textContent = new Date(session.createdAt).toLocaleString();
                
                const turnList = document.getElementById('turnOrderList');
                if (turnList) {
                    let html = '<div class="flex">';
                    (session.turnOrder || []).forEach((playerId, index) => {
                        const player = GameState.players?.find(p => p?.id === playerId);
                        if (player) {
                            const isCurrent = index === (session.currentTurnIndex || 0);
                            html += `
                                <div class="stat-box" style="${isCurrent ? 'background: var(--success); color: white;' : ''}">
                                    ${isCurrent ? 'â–¶ ' : ''}${player.name}
                                </div>
                            `;
                        }
                    });
                    html += '</div>';
                    turnList.innerHTML = html;
                }
            } catch (error) {
                console.error('Failed to update session view:', error);
            }
        }

        function updateTherapyView() {
            try {
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    let html = '<h4>Current Objectives:</h4>';
                    (GameState.objectives || []).forEach(obj => {
                        if (!obj) return;
                        html += `
                            <div class="objective-item">
                                <strong>Weight ${obj.weight}:</strong> ${obj.text}
                            </div>
                        `;
                    });
                    objectivesList.innerHTML = html;
                }
                
                const therapyPlayersList = document.getElementById('therapyPlayersList');
                if (!therapyPlayersList) return;
                
                if (!GameState.currentSession) {
                    therapyPlayersList.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                let html = '';
                (GameState.players || []).forEach(player => {
                    if (!player) return;
                    
                    const therapy = GameState.currentSession.therapy?.perPlayer?.[player.id];
                    if (!therapy) return;
                    
                    html += `
                        <div class="card">
                            <h3>${player.name}</h3>
                            <p><strong>PM (Merit Points):</strong> ${therapy.pm || 0}</p>
                            <p><strong>Medals:</strong> 
                                ${(therapy.medals || []).map(m => {
                                    const emoji = { bronze: 'ğŸ¥‰', silver: 'ğŸ¥ˆ', gold: 'ğŸ¥‡' }[m] || 'ğŸ…';
                                    return `<span class="medal">${emoji}</span>`;
                                }).join('')}
                            </p>
                            
                            <h4>Objectives:</h4>
                            ${(GameState.objectives || []).map(obj => {
                                if (!obj) return '';
                                const completed = therapy.completedObjectives?.includes(obj.id);
                                return `
                                    <div class="objective-item">
                                        <input type="checkbox" 
                                               ${completed ? 'checked' : ''}
                                               onchange="toggleObjectiveForPlayer(${player.id}, ${obj.id})"
                                               style="width: 30px; height: 30px; cursor: pointer;">
                                        <span>${obj.text} (${obj.weight} PM)</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                });
                
                therapyPlayersList.innerHTML = html;
            } catch (error) {
                console.error('Failed to update therapy view:', error);
            }
        }

        function updateReportView() {
            try {
                const container = document.getElementById('reportContent');
                if (!container) return;
                
                if (!GameState.currentSession) {
                    container.innerHTML = '<div class="card"><p>No active session</p></div>';
                    return;
                }
                
                const session = GameState.currentSession;
                
                let html = `
                    <div class="card">
                        <h3>Session: ${session.name}</h3>
                        <p>Started: ${new Date(session.createdAt).toLocaleString()}</p>
                        ${session.completedAt ? `<p>Ended: ${new Date(session.completedAt).toLocaleString()}</p>` : '<p>Status: Active</p>'}
                    </div>
                    
                    <div class="card">
                        <h3>Player Summary</h3>
                        ${(GameState.players || []).map(player => {
                            if (!player) return '';
                            const therapy = session.therapy?.perPlayer?.[player.id];
                            if (!therapy) return '';
                            
                            return `
                                <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 10px;">
                                    <h4>${player.name}</h4>
                                    <p>PM Earned: ${therapy.pm || 0}</p>
                                    <p>Medals: ${(therapy.medals || []).join(', ') || 'None yet'}</p>
                                    <p>Objectives Completed: ${therapy.completedObjectives?.length || 0}/${GameState.objectives?.length || 0}</p>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Failed to update report view:', error);
            }
        }

        // DATA MANAGEMENT
        function exportData() {
            try {
                const data = JSON.stringify(GameState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monstrinhomon_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                showError('Export failed', error.stack);
            }
        }

        function importData() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target?.files?.[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target?.result || '{}');
                            Object.assign(GameState, data);
                            saveToLocalStorage();
                            updateAllViews();
                            alert('Data imported successfully!');
                        } catch (error) {
                            showError('Import failed', error.stack);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError('Import failed', error.stack);
            }
        }

        function clearAllData() {
            try {
                if (confirm('Are you sure? This will delete ALL data!')) {
                    if (confirm('Really sure? This cannot be undone!')) {
                        localStorage.removeItem('monstrinhomon_state');
                        location.reload();
                    }
                }
            } catch (error) {
                showError('Clear data failed', error.stack);
            }
        }

        function toggleTherapistMode() {
            try {
                const checked = document.getElementById('therapistMode')?.checked;
                mmSetTherapistMode(checked);
                
                // Also update the old config panel if it exists
                const configPanel = document.getElementById('configPanel');
                if (configPanel) {
                    if (checked) {
                        configPanel.classList.remove('hidden');
                    } else {
                        configPanel.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle therapist mode:', error);
            }
        }

        // Feature 4.4: Global click listener for button sounds
        document.addEventListener("click", (e) => {
            const btn = e.target.closest("button");
            if (!btn) return;
            // Avoid spam on disabled buttons
            if (btn.disabled) return;
            // Avoid double-sound on audio control buttons
            if (btn.id === "mmMuteBtn" || btn.textContent.includes("Testar som")) return;
            Audio.playSfx("ui_click");
        });

        // ===== Feature 4.0: Menu / Flow =====
        const MM_SAVE_KEY = "monstrinhomon_state"; // Using the same key as the existing save system

        function mmEl(id){ return document.getElementById(id); }

        function mmCloseAllOverlays(){
            ["mmIntro","mmMenu","mmNewGame","mmConfig","mmStartChoice"].forEach(id => mmEl(id)?.classList.remove("show"));
        }

        function mmShow(id){
            mmCloseAllOverlays();
            mmEl(id)?.classList.add("show");
        }

        function mmHasSave(){
            try {
                const data = localStorage.getItem(MM_SAVE_KEY);
                if (!data) return false;
                const parsed = JSON.parse(data);
                // Consider it a valid save if it has players or sessions
                return (parsed.players && parsed.players.length > 0) || 
                       (parsed.sessions && parsed.sessions.length > 0);
            } catch(e){ 
                return false; 
            }
        }

        function mmBoot(){
            // Show intro on boot
            mmShow("mmIntro");
        }

        function mmShowMainMenu(){
            mmShow("mmMenu");
            const btn = mmEl("mmBtnContinue");
            const ok = mmHasSave();
            if (btn) {
                btn.disabled = !ok;
                btn.textContent = ok ? "ğŸ“– Continuar" : "ğŸ“– Continuar (sem save)";
            }
            // Update therapist button visibility
            mmUpdateTherapistUI();
        }

        function mmShowConfig(){
            mmShow("mmConfig");
        }

        // Feature 4.6: Therapist Mode Panel Functions
        function mmOpenTherapistPanel() {
            if (!mmRequireGameOrAlert()) return;
            mmShow("mmTherapist");
            mmRenderTherapistPanel();
        }

        function mmRenderTherapistPanel() {
            const host = document.getElementById("mmTherapistBody");
            if (!host) return;
            
            if (!mmIsTherapistMode()) {
                host.innerHTML = `<div style="opacity:.8;">Ative o Therapist Mode nas ConfiguraÃ§Ãµes.</div>`;
                return;
            }
            
            if (!mmRequireGameOrAlert()) {
                host.innerHTML = "";
                return;
            }

            const players = GameState.players || [];
            
            // Build player options
            const playerOptions = players.map(p => `<option value="${p.id}">${escapeHtml(p.name)} (${escapeHtml(p.class || 'N/A')})</option>`).join("");

            // Build item options (ClasterOrbs + healing items)
            const itemOptions = `
                <option value="CLASTERORB_COMUM">âšª ClasterOrb Comum</option>
                <option value="CLASTERORB_INCOMUM">ğŸ”µ ClasterOrb Incomum</option>
                <option value="CLASTERORB_RARA">ğŸŸ£ ClasterOrb Rara</option>
                <option value="IT_HEAL_01">ğŸ’š Petisco de Cura</option>
            `;

            // Build monster options from catalog
            const monOptions = MONSTER_CATALOG.map(m => 
                `<option value="${m.id}">${escapeHtml(m.name)} [${escapeHtml(m.class)}] (${escapeHtml(m.rarity)})</option>`
            ).join("");

            host.innerHTML = `
                <div style="display:grid; gap:10px;">
                    <div>
                        <div style="font-weight:800; margin-bottom:6px;">Jogador alvo</div>
                        <select id="mmTherPlayer" class="mm-input">${playerOptions}</select>
                    </div>

                    <div style="padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px;">
                        <div style="font-weight:800; margin-bottom:6px;">âœ¨ Dar XP (monstro ativo)</div>
                        <div class="mm-row">
                            <input id="mmTherXp" class="mm-input" type="number" min="1" value="50" style="flex:1;">
                            <button class="mm-btn" onclick="mmTherGiveXP()">+ XP</button>
                        </div>
                        <div style="opacity:.8; font-size:12px; margin-top:6px;">Aplica no player.team[0].</div>
                    </div>

                    <div style="padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px;">
                        <div style="font-weight:800; margin-bottom:6px;">ğŸ’ Dar Item</div>
                        <div class="mm-row">
                            <select id="mmTherItem" class="mm-input" style="flex:1;">${itemOptions}</select>
                            <input id="mmTherItemQty" class="mm-input" type="number" min="1" value="1" style="width:90px;">
                            <button class="mm-btn" onclick="mmTherGiveItem()">Adicionar</button>
                        </div>
                    </div>

                    <div style="padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px;">
                        <div style="font-weight:800; margin-bottom:6px;">ğŸ¾ Dar Monstrinhomon</div>
                        <div class="mm-row">
                            <select id="mmTherMon" class="mm-input" style="flex:1;">${monOptions}</select>
                            <input id="mmTherMonLv" class="mm-input" type="number" min="1" value="5" style="width:90px;">
                        </div>
                        <div class="mm-row" style="margin-top:8px;">
                            <select id="mmTherMonDest" class="mm-input" style="flex:1;">
                                <option value="auto">Auto (Time se <6, senÃ£o Caixa)</option>
                                <option value="team">ForÃ§ar Time</option>
                                <option value="box">ForÃ§ar Caixa</option>
                            </select>
                            <button class="mm-btn" onclick="mmTherGiveMonster()">Adicionar</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Therapist action: Give XP
        function mmTherGiveXP() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const amt = Math.max(1, parseInt(document.getElementById("mmTherXp")?.value || "0", 10));

            const player = GameState.players.find(p => p.id === pid);
            const mon = player?.team?.[0];
            
            if (!mon) {
                alert("Jogador sem monstrinho ativo (team[0]).");
                return;
            }

            const logArr = GameState.currentEncounter?.log || [];

            // Use existing giveXP function
            if (typeof giveXP === "function") {
                giveXP(mon, amt, logArr);
            } else {
                // Fallback if giveXP doesn't exist
                mon.xp = (mon.xp || 0) + amt;
            }

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof showToast === "function") {
                showToast(`âœ¨ ${player.name} recebeu +${amt} XP!`);
            } else {
                alert(`âœ¨ ${player.name} recebeu +${amt} XP!`);
            }
        }

        // Therapist action: Give Item
        function mmTherGiveItem() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const itemId = document.getElementById("mmTherItem")?.value;
            const qty = Math.max(1, parseInt(document.getElementById("mmTherItemQty")?.value || "1", 10));

            const player = GameState.players.find(p => p.id === pid);
            if (!player) return;

            player.inventory = player.inventory || {};
            player.inventory[itemId] = (player.inventory[itemId] || 0) + qty;

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            
            // Get item name from CLASTERORBS or fallback to itemId
            let itemName = itemId;
            if (window.CLASTERORBS && window.CLASTERORBS[itemId]) {
                itemName = window.CLASTERORBS[itemId].name;
            }
            
            if (typeof showToast === "function") {
                showToast(`ğŸ’ ${player.name} recebeu ${qty}x ${itemName}`);
            } else {
                alert(`ğŸ’ ${player.name} recebeu ${qty}x ${itemName}`);
            }
        }

        // Therapist action: Give Monster
        function mmTherGiveMonster() {
            if (!mmRequireGameOrAlert()) return;

            const pid = document.getElementById("mmTherPlayer")?.value;
            const monId = document.getElementById("mmTherMon")?.value;
            const lv = Math.max(1, parseInt(document.getElementById("mmTherMonLv")?.value || "1", 10));
            const dest = document.getElementById("mmTherMonDest")?.value || "auto";

            const player = GameState.players.find(p => p.id === pid);
            if (!player) return;

            // COMMIT 8 (Wave A): Use Award API for canonical monster creation
            const inst = awardMonster(
                monId,      // templateId
                lv,         // level
                null,       // rarity (use template default)
                dest,       // destination ('auto', 'team', or 'box')
                player      // player object
            );
            
            if (!inst) {
                alert("âŒ Erro ao conceder monstro via Award API.");
                return;
            }

            if (typeof renderEncounter === "function") renderEncounter();
            
            // Determine where it actually went (Award API handles team limit)
            const inTeam = player.team.some(m => m.instanceId === inst.instanceId);
            const destText = inTeam ? "time" : "caixa";
            
            if (typeof showToast === "function") {
                showToast(`ğŸ¾ ${player.name} recebeu ${inst.name || monId} (Lv ${lv}) no ${destText}`);
            } else {
                alert(`ğŸ¾ ${player.name} recebeu ${inst.name || monId} (Lv ${lv}) no ${destText}`);
            }
        }

        function mmContinue(){
            // Check if there's a last slot saved - if so, load from it
            try {
                const lastSlot = localStorage.getItem("mm_last_slot");
                if (lastSlot) {
                    const slotNum = parseInt(lastSlot, 10);
                    if ([1, 2, 3].includes(slotNum)) {
                        // Load from slot - this will call mmPostGameStartFlow()
                        mmLoadFromSlot(slotNum);
                        return;
                    }
                }
            } catch (e) {
                console.warn("Failed to check last slot", e);
            }

            // Fallback: load from main localStorage
            try {
                loadFromLocalStorage();
                updateAllViews();
            } catch(e){
                console.warn("mmContinue failed", e);
                alert("Erro ao carregar o save: " + e.message);
                mmCloseAllOverlays();
                return;
            }
            // Feature 4.1.1: Show tutorial choice or go to game based on preference
            mmPostGameStartFlow();
        }

        function mmResetSaveConfirm(){
            const ok = confirm("Apagar o save do navegador? Isso nÃ£o pode ser desfeito.");
            if (!ok) return;
            try {
                localStorage.removeItem(MM_SAVE_KEY);
                alert("Save apagado com sucesso!");
            } catch(e){
                alert("Erro ao apagar save: " + e.message);
            }
            mmShowMainMenu();
        }

        // ---- New Game Wizard (MVP) ----
        const MM_NEW = {
            step: 0,
            numPlayers: 1,
            difficulty: "medium",
            players: [] // {name, class}
        };

        const MM_CLASSES = ["Guerreiro","Mago","Curandeiro","BÃ¡rbaro","Ladino","Bardo","CaÃ§ador","Animalista"];

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function mmStartNewGame(){
            MM_NEW.step = 0;
            MM_NEW.numPlayers = 1;
            MM_NEW.difficulty = "medium";
            MM_NEW.players = [];
            mmShow("mmNewGame");
            mmRenderNewGameStep();
        }

        function mmRenderNewGameStep(){
            const host = mmEl("mmNewGameStep");
            if (!host) return;

            if (MM_NEW.step === 0) {
                host.innerHTML = `
                    <p class="mm-sub">Quantos jogadores?</p>
                    <div class="mm-field">
                        <label>NÃºmero de jogadores (1â€“6)</label>
                        <input id="mmNumPlayers" type="number" min="1" max="6" value="${MM_NEW.numPlayers}">
                        <div class="mm-hint">Dica: em grupo, cada jogador usa monstrinhos da prÃ³pria classe.</div>
                    </div>
                `;
                return;
            }

            if (MM_NEW.step === 1) {
                host.innerHTML = `
                    <p class="mm-sub">Selecione a dificuldade</p>
                    <div class="mm-field">
                        <label>Dificuldade</label>
                        <select id="mmDifficulty">
                            <option value="easy" ${MM_NEW.difficulty==="easy"?"selected":""}>FÃ¡cil</option>
                            <option value="medium" ${MM_NEW.difficulty==="medium"?"selected":""}>MÃ©dio</option>
                            <option value="hard" ${MM_NEW.difficulty==="hard"?"selected":""}>DifÃ­cil</option>
                        </select>
                        <div class="mm-hint">MVP: afeta encontros futuros conforme seu sistema de difficulty.</div>
                    </div>
                `;
                return;
            }

            // Step 2: players
            if (MM_NEW.step === 2) {
                // garante array
                while (MM_NEW.players.length < MM_NEW.numPlayers) {
                    MM_NEW.players.push({ name: "", class: MM_CLASSES[0] });
                }
                while (MM_NEW.players.length > MM_NEW.numPlayers) {
                    MM_NEW.players.pop();
                }

                const rows = MM_NEW.players.map((p, i) => `
                    <div style="border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:12px; margin:10px 0;">
                        <div style="font-weight:900; margin-bottom:8px;">Jogador ${i+1}</div>
                        <div class="mm-field">
                            <label>Nome</label>
                            <input id="mmPName_${i}" maxlength="14" placeholder="Ex.: Ana" value="${escapeHtml(p.name || "")}">
                        </div>
                        <div class="mm-field">
                            <label>Classe</label>
                            <select id="mmPClass_${i}">
                                ${MM_CLASSES.map(c => `<option value="${escapeHtml(c)}" ${p.class===c?"selected":""}>${escapeHtml(c)}</option>`).join("")}
                            </select>
                        </div>
                    </div>
                `).join("");

                host.innerHTML = `
                    <p class="mm-sub">Crie os jogadores</p>
                    ${rows}
                    <p class="mm-hint">O monstrinho inicial deve seguir a classe do jogador (MVP).</p>
                `;
                return;
            }

            // Step 3: confirm
            if (MM_NEW.step === 3) {
                host.innerHTML = `
                    <p class="mm-sub">Tudo pronto!</p>
                    <div style="opacity:0.9; line-height:1.45;">
                        <div><b>Jogadores:</b> ${MM_NEW.numPlayers}</div>
                        <div><b>Dificuldade:</b> ${escapeHtml(MM_NEW.difficulty)}</div>
                        <div style="margin-top:8px;">
                            ${MM_NEW.players.map(p => `â€¢ ${escapeHtml(p.name || "Sem nome")} â€” ${escapeHtml(p.class)}`).join("<br/>")}
                        </div>
                    </div>
                    <button class="mm-btn" onclick="mmFinishNewGame()">ğŸš€ ComeÃ§ar Aventura</button>
                    <p class="mm-hint">Isso criarÃ¡ uma nova sessÃ£o e sobrescreverÃ¡ o save atual.</p>
                `;
            }
        }

        function mmNewGameBack(){
            if (MM_NEW.step === 0) { mmShowMainMenu(); return; }
            MM_NEW.step = Math.max(0, MM_NEW.step - 1);
            mmRenderNewGameStep();
        }

        function mmNewGameNext(){
            // capturar inputs do step atual
            if (MM_NEW.step === 0) {
                const n = Number(mmEl("mmNumPlayers")?.value || 1);
                MM_NEW.numPlayers = Math.max(1, Math.min(6, n));
            }
            if (MM_NEW.step === 1) {
                MM_NEW.difficulty = String(mmEl("mmDifficulty")?.value || "medium");
            }
            if (MM_NEW.step === 2) {
                for (let i=0;i<MM_NEW.players.length;i++){
                    const name = String(mmEl(`mmPName_${i}`)?.value || "").trim();
                    const cls = String(mmEl(`mmPClass_${i}`)?.value || MM_CLASSES[0]);
                    MM_NEW.players[i] = { name, class: cls };
                }
            }

            MM_NEW.step = Math.min(3, MM_NEW.step + 1);
            mmRenderNewGameStep();
        }

        function mmFinishNewGame(){
            try {
                // valida nomes (MVP: auto-preenche)
                MM_NEW.players = MM_NEW.players.map((p, idx) => ({
                    name: p.name?.trim() ? p.name.trim() : `Jogador ${idx+1}`,
                    class: p.class || MM_CLASSES[0]
                }));

                // Clear existing state
                GameState.players = [];
                GameState.monsters = [];
                GameState.sessions = [];
                GameState.currentSession = null;
                GameState.currentEncounter = null;

                // Create players
                MM_NEW.players.forEach((p, idx) => {
                    const playerId = `p_${Date.now()}_${idx}`;
                    
                    // Find a starter monster of the same class
                    const starterTemplate = MONSTER_CATALOG.find(m => 
                        m.class && p.class && m.class.toLowerCase() === p.class.toLowerCase()
                    ) || MONSTER_CATALOG[0]; // Fallback to first monster if no match
                    
                    // Create player first (Award API needs player object)
                    const player = {
                        id: playerId,
                        name: p.name,
                        class: p.class,
                        team: [],
                        box: [],
                        inventory: {
                            'Monstribola': 5,
                            'PoÃ§Ã£o': 3
                        }
                    };
                    
                    GameState.players.push(player);
                    
                    // COMMIT 8 (Wave A): Use Award API for canonical monster creation
                    const starterMonster = awardMonster(
                        starterTemplate.id,  // templateId
                        1,                   // level
                        null,                // rarity (use template default)
                        'party',             // destination
                        player               // player object
                    );
                    
                    if (!starterMonster) {
                        console.error('Failed to award starter monster to new player:', p.name);
                    }
                });

                // Save difficulty
                if (!GameState.config) GameState.config = {};
                GameState.config.difficulty = MM_NEW.difficulty;

                // Save to localStorage
                saveToLocalStorage();
                
                // Feature 4.3: Also save to chosen slot if specified
                if (GameState.saveSlot) {
                    const envelope = mmBuildSaveEnvelope();
                    const key = MM_SAVE_KEYS[GameState.saveSlot];
                    if (key) {
                        try {
                            localStorage.setItem(key, JSON.stringify(envelope));
                        } catch (e) {
                            console.error("Failed to save to slot", e);
                            alert(`âš ï¸ Jogo criado, mas falhou ao salvar no Slot ${GameState.saveSlot}`);
                        }
                    }
                }
                
                // Update UI
                updateAllViews();
                
            } catch(e) {
                console.error("mmFinishNewGame failed", e);
                alert("Erro ao criar novo jogo: " + e.message);
                mmCloseAllOverlays();
                return;
            }

            // Feature 4.1.1: Show tutorial choice instead of going directly to game
            mmPostGameStartFlow();
        }

        // ===== Feature 4.3: Save Slots + Export/Import =====
        const MM_SAVE_KEYS = {
            1: "mm_save_slot_1",
            2: "mm_save_slot_2",
            3: "mm_save_slot_3",
        };
        const MM_LEGACY_KEYS = [
            "monstrinhomon_state", "mm_save", "GameState", "mm_state"
        ];
        const MM_MIGRATED_FLAG = "mm_slots_migrated_v1";

        function mmOpenSaves() {
            mmMigrateLegacySaveToSlot1();
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSavesScreen");
            mmRenderSavesScreen();
            
            // Bind import file input once
            const fileInput = document.getElementById("mmImportFile");
            if (fileInput && !fileInput._bound) {
                fileInput._bound = true;
                fileInput.addEventListener("change", (e) => mmHandleImportFile(e));
            }
        }

        function mmCloseSaves() {
            mmHideOverlay("mmSavesScreen");
            mmShowMainMenu();
        }

        function mmShowOverlay(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove("hidden");
                el.classList.add("show");
            }
        }

        function mmHideOverlay(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.add("hidden");
                el.classList.remove("show");
            }
        }

        function mmReadSlot(slot) {
            const key = MM_SAVE_KEYS[slot];
            if (!key) return null;
            const raw = localStorage.getItem(key);
            if (!raw) return null;
            try { 
                return JSON.parse(raw); 
            } catch { 
                return null; 
            }
        }

        function mmWriteSlot(slot, saveObj) {
            const key = MM_SAVE_KEYS[slot];
            if (!key) return false;
            try {
                localStorage.setItem(key, JSON.stringify(saveObj));
                return true;
            } catch (e) {
                console.error("Failed to write slot", slot, e);
                return false;
            }
        }

        function mmBuildSaveEnvelope() {
            // Create snapshot of current state
            try {
                const payload = {
                    version: "mm_slot_v1",
                    timestamp: Date.now(),
                    sessionName: GameState?.currentSession?.name || "SessÃ£o",
                    playersCount: Array.isArray(GameState?.players) ? GameState.players.length : 0,
                    state: JSON.parse(JSON.stringify(GameState)) // Deep copy (requires serializable state)
                };
                return payload;
            } catch (e) {
                console.error("Failed to create save envelope (state may have non-serializable values)", e);
                throw new Error("Falha ao criar envelope de save");
            }
        }

        function mmSaveToSlot(slot) {
            if (!confirm(`Salvar o jogo atual no Slot ${slot}? Isso vai sobrescrever.`)) return;
            const env = mmBuildSaveEnvelope();
            if (mmWriteSlot(slot, env)) {
                showToast(`ğŸ’¾ Salvo no Slot ${slot}!`);
                mmRenderSavesScreen();
            } else {
                alert("Falha ao salvar no slot.");
            }
        }

        function mmLoadFromSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env || !env.state) {
                alert("Slot vazio ou invÃ¡lido.");
                return;
            }
            if (!confirm(`Carregar Slot ${slot}? Isso substitui o estado atual.`)) return;
            
            try {
                // Update GameState properties instead of reassigning
                Object.assign(GameState, env.state);
                
                // Update slot tracking
                GameState.saveSlot = slot;
                localStorage.setItem("mm_last_slot", String(slot));
                
                saveToLocalStorage();  // Update the main save too
                
                // Update all views
                if (typeof updateAllViews === "function") updateAllViews();
                if (typeof renderEncounter === "function") renderEncounter();
                
                showToast(`ğŸ“‚ Carregado do Slot ${slot}!`);
                mmCloseSaves();
                
                // Feature 4.1.1: Show tutorial choice or go to game based on preference
                mmPostGameStartFlow();
            } catch (e) {
                console.error("Failed to load from slot", e);
                alert("Erro ao carregar o slot.");
            }
        }

        function mmDeleteSlot(slot) {
            if (!confirm(`Apagar Slot ${slot}? Esta aÃ§Ã£o nÃ£o pode ser desfeita.`)) return;
            localStorage.removeItem(MM_SAVE_KEYS[slot]);
            showToast(`ğŸ—‘ï¸ Slot ${slot} apagado.`);
            mmRenderSavesScreen();
        }

        function mmExportSlot(slot) {
            const env = mmReadSlot(slot);
            if (!env) { 
                alert("Slot vazio."); 
                return; 
            }
            
            try {
                const blob = new Blob([JSON.stringify(env, null, 2)], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `monstrinhomon_slot_${slot}_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(a.href); // Free memory
                showToast(`â¬‡ï¸ Exportado Slot ${slot}.`);
            } catch (e) {
                console.error("Failed to export slot", e);
                alert("Erro ao exportar o slot.");
            }
        }

        function mmHandleImportFile(e) {
            const fileInput = e.target;
            const file = fileInput.files?.[0];
            if (!file) return;

            const slotPick = document.getElementById("mmImportSlotPick");
            const slot = Number(slotPick?.value || 1);

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const obj = JSON.parse(String(reader.result || ""));
                    if (!obj || !obj.state) {
                        throw new Error("JSON invÃ¡lido (sem state).");
                    }
                    
                    // Basic validation of state structure
                    if (typeof obj.state !== 'object') {
                        throw new Error("State invÃ¡lido.");
                    }
                    
                    if (mmWriteSlot(slot, obj)) {
                        showToast(`â¬†ï¸ Importado para Slot ${slot}!`);
                        mmRenderSavesScreen();
                    } else {
                        throw new Error("Falha ao gravar no slot.");
                    }
                } catch (err) {
                    console.error("Import failed", err);
                    const msg = err?.message || "Arquivo invÃ¡lido ou corrompido";
                    alert("Falha ao importar: " + msg);
                } finally {
                    fileInput.value = ""; // Allow re-import of same file
                }
            };
            reader.readAsText(file);
        }

        function mmRenderSavesScreen() {
            const host = document.getElementById("mmSavesSlots");
            if (!host) return;

            const slotHtml = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>SessÃ£o:</b> ${escapeHtml(env.sessionName || "SessÃ£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot">
                        <h3>Slot ${slot}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmLoadFromSlot(${slot})">ğŸ“‚ Carregar</button>
                            <button class="mm-btn" style="width:auto;" onclick="mmSaveToSlot(${slot})">ğŸ’¾ Salvar aqui</button>
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmExportSlot(${slot})">â¬‡ï¸ Exportar</button>
                            <button class="mm-btn" style="width:auto;" ${empty ? "disabled" : ""} onclick="mmDeleteSlot(${slot})">ğŸ—‘ï¸ Apagar</button>
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = slotHtml;
        }

        // Slot Picker functions for New Game flow
        function mmGetLastSlot() {
            const n = Number(localStorage.getItem("mm_last_slot") || "1");
            return [1, 2, 3].includes(n) ? n : 1;
        }

        function mmOpenSlotPickerForNewGame() {
            mmMigrateLegacySaveToSlot1(); // Ensure migration happens first
            mmHideOverlay("mmMenu");
            mmShowOverlay("mmSlotPicker");
            mmRenderSlotPicker();
        }

        function mmCancelSlotPicker() {
            mmHideOverlay("mmSlotPicker");
            mmShowMainMenu();
        }

        function mmRenderSlotPicker() {
            const host = document.getElementById("mmSlotPickerList");
            if (!host) return;

            const last = mmGetLastSlot();
            const cards = [1, 2, 3].map(slot => {
                const env = mmReadSlot(slot);
                const empty = !env || !env.state;
                const date = env?.timestamp ? new Date(env.timestamp).toLocaleString('pt-BR') : "";
                const meta = empty
                    ? `<div class="mm-slot-meta">Vazio</div>`
                    : `<div class="mm-slot-meta">
                         <div><b>SessÃ£o:</b> ${escapeHtml(env.sessionName || "SessÃ£o")}</div>
                         <div><b>Jogadores:</b> ${env.playersCount ?? "?"}</div>
                         <div><b>Data:</b> ${date}</div>
                       </div>`;

                return `
                    <div class="mm-slot" style="${slot === last ? "outline:2px solid rgba(160,120,255,0.8);" : ""}">
                        <h3 style="margin:0 0 6px 0;">Slot ${slot} ${slot === last ? "â­" : ""}</h3>
                        ${meta}
                        <div class="mm-slot-actions">
                            <button class="mm-btn" style="width:auto;"
                                onclick="mmChooseSlotAndStartNewGame(${slot})">
                                ${empty ? "âœ… Usar este slot" : "âœ… Usar (sobrescrever)"}
                            </button>
                        </div>
                    </div>
                `;
            }).join("");

            host.innerHTML = cards;
        }

        function mmChooseSlotAndStartNewGame(slot, force = false) {
            const env = mmReadSlot(slot);
            const occupied = !!(env && env.state);

            if (occupied && !force) {
                const ok = confirm(`Slot ${slot} jÃ¡ tem um save. Sobrescrever?`);
                if (!ok) return;
            }

            // Store chosen slot
            if (!window.GameState) window.GameState = {};
            GameState.saveSlot = slot;
            localStorage.setItem("mm_last_slot", String(slot));

            mmHideOverlay("mmSlotPicker");
            // Call existing wizard from Feature 4.0
            mmStartNewGame();
        }

        function mmMigrateLegacySaveToSlot1() {
            // Migrate once: legacy save -> slot1 if slot1 is empty
            if (localStorage.getItem(MM_MIGRATED_FLAG) === "1") return;

            const slot1 = mmReadSlot(1);
            if (slot1 && slot1.state) {
                // Slot 1 already has data, mark as migrated
                localStorage.setItem(MM_MIGRATED_FLAG, "1");
                return;
            }

            // Try to find legacy save
            for (const key of MM_LEGACY_KEYS) {
                const raw = localStorage.getItem(key);
                if (!raw) continue;

                try {
                    const parsed = JSON.parse(raw);
                    
                    // Check if it's already an envelope or raw GameState
                    const env = (parsed && parsed.state) ? parsed : {
                        version: "mm_slot_v1",
                        timestamp: Date.now(),
                        sessionName: parsed?.currentSession?.name || "SessÃ£o",
                        playersCount: Array.isArray(parsed?.players) ? parsed.players.length : 0,
                        state: parsed
                    };
                    
                    if (mmWriteSlot(1, env)) {
                        showToast("âœ… Save antigo migrado para Slot 1!");
                        break;
                    }
                } catch (e) {
                    console.warn("Failed to migrate legacy save from key:", key, e);
                    // Continue to next key
                }
            }

            localStorage.setItem(MM_MIGRATED_FLAG, "1");
        }

        // ===== Feature 4.2: Tutorial (Optional) =====
        const TUTORIAL_STEPS = [
            {
                id: "tut_attack",
                title: "Tutorial 1/3 â€” Ataque bÃ¡sico",
                instructions: "Clique em ATACAR 2 vezes para vencer.",
                required: { attack: 2 },
                lock: { attack:true, skill:false, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Attack()
            },
            {
                id: "tut_skill",
                title: "Tutorial 2/3 â€” Habilidades",
                instructions: "Use 1 habilidade (gasta ENE) para vencer.",
                required: { skill: 1 },
                lock: { attack:true, skill:true, item:false, capture:false, flee:false, pass:false },
                start: () => startTutorialEncounter_Skill()
            },
            {
                id: "tut_capture",
                title: "Tutorial 3/3 â€” Captura",
                instructions: "Abaixe o HP do inimigo atÃ© ficar baixo e capture com ClasterOrb.",
                required: { capture: 1 },
                lock: { attack:true, skill:true, item:false, capture:true, flee:false, pass:false },
                start: () => startTutorialEncounter_Capture()
            }
        ];

        function ensureTutorialState() {
            if (!window.GameState) window.GameState = {};
            if (!GameState.tutorial) GameState.tutorial = { active:false, stepIndex:0, done:{} };
            if (!GameState.tutorial.done) GameState.tutorial.done = {};
            return GameState.tutorial;
        }

        function getTutorialStep() {
            const tut = ensureTutorialState();
            if (!tut.active) return null;
            return TUTORIAL_STEPS[tut.stepIndex] || null;
        }

        function mmStartTutorial() {
            const tut = ensureTutorialState();
            
            // Se nÃ£o hÃ¡ jogadores, precisa criar um jogo primeiro
            if (!GameState.players || GameState.players.length === 0) {
                alert("Por favor, crie um novo jogo primeiro!");
                return;
            }
            
            const restart = !tut.active ? true : confirm("Continuar tutorial atual? (OK = continuar / Cancelar = reiniciar)");
            if (!restart) {
                tut.active = false;
                tut.stepIndex = 0;
                tut.done = {};
            }
            tut.active = true;
            
            // Inicia step atual
            const step = TUTORIAL_STEPS[tut.stepIndex] || TUTORIAL_STEPS[0];
            mmCloseAllOverlays();
            step.start();
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
        }

        function exitTutorial() {
            const tut = ensureTutorialState();
            tut.active = false;
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            showToast("ğŸ‘‹ Tutorial encerrado!");
        }

        function renderTutorialBanner(enc) {
            const step = getTutorialStep();
            if (!step) return "";
            const tut = ensureTutorialState();
            const done = tut.done || {};
            const req = step.required || {};
            const lines = Object.keys(req).map(k => {
                const v = req[k];
                const cur = done[k] || 0;
                return `â€¢ ${k}: ${cur}/${v}`;
            }).join("<br/>");

            return `
                <div style="padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.15); background:rgba(255,255,255,0.06); margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                        <div style="font-weight:900;">ğŸ“ ${step.title}</div>
                        <button class="btn" style="width:auto; margin:0; padding:8px 10px;" onclick="exitTutorial()">Sair</button>
                    </div>
                    <div style="opacity:0.9; margin-top:6px;">${step.instructions}</div>
                    <div style="opacity:0.8; margin-top:6px; font-size:12px;">${lines}</div>
                </div>
            `;
        }

        function tutorialAllows(actionKey) {
            const step = getTutorialStep();
            if (!step) return true;
            const lock = step.lock || {};
            // Se nÃ£o definido, permite
            if (typeof lock[actionKey] === "undefined") return true;
            return !!lock[actionKey];
        }

        function tutorialOnAction(type) {
            const step = getTutorialStep();
            if (!step) return;

            const tut = ensureTutorialState();
            tut.done[type] = (tut.done[type] || 0) + 1;

            // Checa se completou
            const req = step.required || {};
            const ok = Object.keys(req).every(k => (tut.done[k] || 0) >= req[k]);

            if (ok) {
                showToast("ğŸ‰ Passo concluÃ­do!");
                
                // Se Ã© o Ãºltimo step
                if (tut.stepIndex === TUTORIAL_STEPS.length - 1) {
                    tut.active = false;
                    showToast("ğŸ Tutorial completo!");
                    if (typeof saveToLocalStorage === "function") saveToLocalStorage();
                    return;
                }
                
                // AvanÃ§a para prÃ³ximo step
                tut.stepIndex = Math.min(TUTORIAL_STEPS.length - 1, tut.stepIndex + 1);
                tut.done = {}; // Reseta contadores do prÃ³ximo step

                const next = getTutorialStep();
                if (next) {
                    setTimeout(() => {
                        next.start();
                    }, 1500); // Pequeno delay para o usuÃ¡rio ver a mensagem
                }
            }

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
        }

        function createTutorialEnemy(level) {
            // Tenta pegar um template real do catÃ¡logo
            const cat = MONSTER_CATALOG || [];
            const t = cat[0];
            if (typeof createMonsterInstance === "function" && t) {
                const m = createMonsterInstance(t, null, level);
                // Deixa mais fÃ¡cil
                m.hpMax = Math.max(20, Math.floor(m.hpMax * 0.6));
                m.hp = m.hpMax;
                return m;
            }
            // Fallback mÃ­nimo
            return { 
                id: Date.now() + Math.random(),
                name:"Treinomon", 
                level, 
                hpMax: 25+level*5, 
                hp: 25+level*5, 
                atk: 4+level, 
                def: 3+level, 
                spd: 5, 
                ene: 0, 
                eneMax: 0,
                class: "Guerreiro",
                rarity: "Comum",
                emoji: "ğŸ¾",
                poder: 6
            };
        }

        function startTutorialEncounter_Attack() {
            const player = GameState.players?.[0];
            if (!player) {
                alert("Nenhum jogador disponÃ­vel para o tutorial!");
                return;
            }
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(1),
                log: ["ğŸ“ Tutorial: Encontro de Ataque", "Ataque 2 vezes para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Skill() {
            const player = GameState.players?.[0];
            if (!player) return;
            
            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(2),
                log: ["ğŸ“ Tutorial: Encontro de Habilidades", "Use 1 habilidade para vencer!"],
                rewardsGranted: false,
                active: true
            };
            
            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        function startTutorialEncounter_Capture() {
            const player = GameState.players?.[0];
            if (!player) return;

            // Garante 1 orb no inventÃ¡rio (para nÃ£o travar tutorial)
            player.inventory = player.inventory || {};
            const orbId = "CLASTERORB_COMUM";
            player.inventory[orbId] = Math.max(1, Number(player.inventory[orbId] || 0));

            GameState.currentEncounter = {
                type: "wild",
                selectedPlayerId: player.id,
                wildMonster: createTutorialEnemy(3),
                log: ["ğŸ“ Tutorial: Encontro de Captura", "Abaixe o HP e capture o monstrinho!"],
                rewardsGranted: false,
                active: true
            };

            if (typeof saveToLocalStorage === "function") saveToLocalStorage();
            if (typeof renderEncounter === "function") renderEncounter();
            if (typeof switchTab === "function") switchTab("encounter");
        }

        // ===== Feature 4.1.1: Start Choice (Tutorial Selection) =====
        
        function mmGetSlotTutorialPref(slotNum){
            try {
                const k = `mm_slot_pref_tutorial_${slotNum}`;
                const v = localStorage.getItem(k);
                return v || null; // "always" | "never"
            } catch { return null; }
        }

        function mmSetSlotTutorialPref(slotNum, pref){
            try {
                const k = `mm_slot_pref_tutorial_${slotNum}`;
                localStorage.setItem(k, pref);
            } catch {}
        }

        // Helper to get the active slot from multiple possible sources
        function mmGetActiveSlot(){
            return (
                GameState?.ui?.activeSlot ??
                GameState?.activeSaveSlot ??
                GameState?.saveSlot ??
                GameState?.currentSaveSlot ??
                (function() {
                    try {
                        const lastSlot = localStorage.getItem("mm_last_slot");
                        return lastSlot ? parseInt(lastSlot, 10) : null;
                    } catch {
                        return null;
                    }
                })() ??
                null
            );
        }

        // Decide what to do after loading/creating a game
        function mmPostGameStartFlow(){
            const slot = mmGetActiveSlot();

            // 1) Slot-specific preference
            const slotPref = slot ? mmGetSlotTutorialPref(slot) : null;
            if (slotPref === "always") return mmStartTutorial();
            if (slotPref === "never")  return mmEnterGameUI();

            // 2) Optional global fallback
            const globalPref = localStorage.getItem("mm_pref_tutorial") || "ask";
            if (globalPref === "always") return mmStartTutorial();
            if (globalPref === "never")  return mmEnterGameUI();

            // 3) Default: ask
            return mmShowStartChoiceOverlay(true);
        }

        function mmShowStartChoiceOverlay(show){
            const el = document.getElementById("mmStartChoice");
            if (!el) return;
            if (show) {
                el.classList.add("show");
                el.classList.remove("hidden");
            } else {
                el.classList.remove("show");
                el.classList.add("hidden");
            }
        }

        function mmStartTutorialFromChoice(){
            mmPersistTutorialChoice("always");
            mmShowStartChoiceOverlay(false);
            mmStartTutorial();
        }

        function mmSkipTutorialFromChoice(){
            mmPersistTutorialChoice("never");
            mmShowStartChoiceOverlay(false);
            mmEnterGameUI();
        }

        function mmPersistTutorialChoice(pref){
            const remember = !!document.getElementById("mmRememberTutorialChoice")?.checked;
            if (!remember) return;

            const slot = mmGetActiveSlot();
            if (slot) {
                mmSetSlotTutorialPref(slot, pref);
                return;
            }
            // fallback global
            try { localStorage.setItem("mm_pref_tutorial", pref); } catch {}
        }

        // Make sure this brings user to the normal tabs/game screen
        function mmEnterGameUI(){
            mmCloseAllOverlays();
            if (typeof updateAllViews === "function") updateAllViews();
            if (typeof renderEncounter === "function") renderEncounter();
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            init(); // Call the existing init function
            mmBoot(); // Show the intro overlay
        });
    </script>
    <div id="mmToastHost"></div>
</body>
</html>
